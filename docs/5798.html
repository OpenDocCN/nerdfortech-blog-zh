<html>
<head>
<title>Handling Images, Part 2: Configuring Rails 6 Models, Serializers, and Controllers with Active Storage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理映像，第 2 部分:用活动存储配置 Rails 6 模型、序列化程序和控制器</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/handling-images-part-2-configuring-rails-6-models-serializers-and-controllers-with-active-51a86bf94cd4?source=collection_archive---------1-----------------------#2021-11-17">https://medium.com/nerd-for-tech/handling-images-part-2-configuring-rails-6-models-serializers-and-controllers-with-active-51a86bf94cd4?source=collection_archive---------1-----------------------#2021-11-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/67b27ccf5a953313f7e005fee659a7b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qDWMNR24f4VlO4FULmMv7w.png"/></div></div></figure><p id="73b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在关于处理图片上传的系列文章的第 1 部分<a class="ae jo" rel="noopener" href="/nerd-for-tech/handling-images-part-1-using-active-storage-in-rails-6-with-amazon-s3-buckets-92b739fa790?source=user_profile---------0-------------------------------">中，我展示了创建一个亚马逊 S3 桶并将其连接到一个只有 Rails API 的后端的步骤。然而，尽管这些信息(希望)是有用的，是时候深入研究如何在 Rails 中实际实现处理图像上传和删除的方法了！</a></p><h1 id="f940" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">步骤 1:设置您的 Rails 模型</h1><p id="991d" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">首先，让我们从 Rails 模型开始。我们需要向模型中添加一个活动存储宏，以建立一对多关系。</p><p id="6c55" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我的例子中，我有一个模型 ReceiptRecord，它可以有许多图像:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="8678" class="lb jq hi kx b fi lc ld l le lf">has_many_attached :receipt_images, dependent: :destroy</span></pre><p id="c2c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你的模型只需要一个图像(例如，一个用户模型只需要一个头像图像)，你可以使用<code class="du lg lh li kx b">has_one_attached</code>宏来代替。至于名字，<code class="du lg lh li kx b">:receipt_images</code>，你可以给这个起任何你喜欢的名字(这是我在我的项目里用的)。最后，添加<code class="du lg lh li kx b">dependent: :destroy</code>意味着如果删除一个带有图像的 ReceiptRecord 对象，那么对象和图像都会被一起删除。</p><h1 id="4c18" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">步骤 2:为您的模型创建一个序列化程序</h1><p id="7a2e" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">接下来，如果您还没有，您将需要为包含图像的模型创建一个序列化程序。在 Rails 项目的根目录下打开一个终端，并运行以下命令:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="f44e" class="lb jq hi kx b fi lc ld l le lf">rails g serializer &lt;name-of-your-model&gt;</span></pre><p id="976f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一旦创建了序列化程序，继续添加您需要的任何属性。然后，在序列化程序的第 2 行添加以下内容:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="4b6d" class="lb jq hi kx b fi lc ld l le lf">include Rails.application.routes.url_helpers</span></pre><p id="b721" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这引入了一些有用的方法来为你上传的图片创建图片 URL。</p><h1 id="10d5" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">步骤 3:生成图像 URL</h1><p id="2bd0" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">接下来，开始创建一个方法，以您对图像的命名命名(在我的例子中，它是 receipt_images)。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="6101" class="lb jq hi kx b fi lc ld l le lf">def receipt_images<br/>  return unless object.receipt_images.attached?<br/>end</span></pre><p id="a488" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除非 ReceiptRecord 对象附有收据图像，否则该方法将不返回任何内容。现在，将以下内容添加到该方法中以完成它:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="2550" class="lb jq hi kx b fi lc ld l le lf">object.receipt_images.map do |receipt_image|<br/>  receipt_image.blob.attributes<br/>    .slice('filename', 'byte_size', 'id')<br/>    .merge(url: receipt_image_url(receipt_image)<br/>end</span></pre><p id="1a94" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为 ReceiptRecord 对象可以有多个图像，所以我们必须映射每个图像。然后，我们从<code class="du lg lh li kx b">active_storage_blob</code>表中访问收据图像的 blob 信息，并获取一些我们计划稍后在 JSON 中呈现的属性。然后，我们合并一个我们自己创建的新属性，这就是我们的 URL。然而，<code class="du lg lh li kx b">#receipt_image_url</code>方法还没有定义，所以我们现在就开始吧！</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="bf5b" class="lb jq hi kx b fi lc ld l le lf">def receipt_image_url(image)<br/>  rails_blob_path(image, only_path: true)<br/>end</span></pre><p id="3a9e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个方法接收一个单独的图像，并使用 Rails 内置的方法为我们生成一个 URL。</p><p id="94b4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在你的模型只有一张图片的情况下，你不需要担心贴图的问题(因为只有一张图片)。您的代码可能看起来像这样:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="f52d" class="lb jq hi kx b fi lc ld l le lf">def image<br/>  return unless object.image.attached?</span><span id="ff60" class="lb jq hi kx b fi lj ld l le lf">  object.image.blob.attributes<br/>    .slice('filename', 'byte_size', 'id')<br/>    .merge(url: image_url(object.image)<br/>end</span><span id="76b1" class="lb jq hi kx b fi lj ld l le lf">def image_url<br/>  rails_blob_path(image, only_path: true)<br/>end</span></pre><p id="4530" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在继续之前，我们还需要做最后一件事:在您的<code class="du lg lh li kx b">development.rb</code>文件中(在<code class="du lg lh li kx b">config/environments</code>下)，添加下面一行:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="ec34" class="lb jq hi kx b fi lc ld l le lf">Rails.application.routes.default_url_options[:host] = 'localhost:3000'</span></pre><p id="ad1f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将允许我们实际上生成一个我们在亚马逊 S3 上存储的图像的 URL。如果您计划进行部署，您将需要在您的<code class="du lg lh li kx b">production.rb</code>文件中有同样的一行；把<code class="du lg lh li kx b">'localhost:3000'</code>换成你的活域名就行了。</p><h1 id="5e11" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">步骤 4:设置控制器</h1><p id="8604" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我假设您将为包含图像的资源实现完整的 CRUD，所以我将逐步创建<code class="du lg lh li kx b">#index</code>、<code class="du lg lh li kx b">#create</code>、<code class="du lg lh li kx b">#update</code>和<code class="du lg lh li kx b">#destroy</code>方法。</p><h2 id="3d9c" class="lb jq hi bd jr lk ll lm jv ln lo lp jz jb lq lr kd jf ls lt kh jj lu lv kl lw bi translated">指数法</h2><p id="8828" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">下面是<code class="du lg lh li kx b">#index</code>的样子(没什么花哨的！):</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="6557" class="lb jq hi kx b fi lc ld l le lf">def index<br/>  receipt_records = ReceiptRecord.all.with_attached_receipt_images<br/>  render json: receipt_records, include: ['receipt_images'], status: :ok<br/>end</span></pre><p id="e796" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意<code class="du lg lh li kx b">with_attached_&lt;your-image-name&gt;</code>方法；这是一种防止<a class="ae jo" href="https://www.sitepoint.com/silver-bullet-n1-problem/" rel="noopener ugc nofollow" target="_blank"> N+1 查询问题</a>的特殊方法。</p><p id="99a9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我还添加了<code class="du lg lh li kx b">include: ['receipt_images']</code>,这样每个作为 JSON 返回的 ReceiptRecord 对象也带有嵌套格式的相关图像。</p><h2 id="2668" class="lb jq hi bd jr lk ll lm jv ln lo lp jz jb lq lr kd jf ls lt kh jj lu lv kl lw bi translated">创建方法</h2><p id="afb9" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">活动存储使创建带有附加图像的新对象变得容易，因为您可以像往常一样传入参数，活动存储将自动附加相关图像:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="4fd1" class="lb jq hi kx b fi lc ld l le lf">def create<br/>  receipt_record = ReceiptRecord.create!(receipt_record_params)<br/>  render json: {<br/>    receipt_record: receipt_record,<br/>    status: { code: 201, message: "Receipt successfully created!" }<br/>  }, status: created<br/>end</span></pre><p id="b172" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，您需要在 params 方法中定义 images 参数:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="b2bb" class="lb jq hi kx b fi lc ld l le lf">def receipt_record_params<br/>  # Note: I omitted all of my params except for the images here to make my example clearer<br/>  params.permit(receipt_images: [])<br/>end</span></pre><p id="5c11" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你像我一样有多个图像，你会希望你的参数指向一个空数组。如果你的模型只有一个图像，那么你需要像 normal 一样命名你的参数(<code class="du lg lh li kx b">:&lt;your-image-name&gt;</code>)。</p><h2 id="e0cb" class="lb jq hi bd jr lk ll lm jv ln lo lp jz jb lq lr kd jf ls lt kh jj lu lv kl lw bi translated">更新方法</h2><p id="fa1a" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">这个比较棘手，因为我希望能够在不更新图像的情况下更新 ReceiptRecord 对象，反之亦然。这是我想到的，我将通过我的例子:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="5a50" class="lb jq hi kx b fi lc ld l le lf">def update<br/>  receipt_record = ReceiptRecords.find(params[:id])<br/>  to_delete = params[:receipt_images_to_delete]<br/>  receipt_record.update(receipt_record_params)</span><span id="55f1" class="lb jq hi kx b fi lj ld l le lf">  if to_delete<br/>    image_ids = to_delete.split(",").map(&amp;:to_i)<br/>    image_ids.map do |id|<br/>      image = receipt_record.receipt_images.find(id)<br/>      image.purge_later<br/>    end<br/>  end</span><span id="99c4" class="lb jq hi kx b fi lj ld l le lf">  render json: {<br/>    receipt_record: receipt_record,<br/>    status: { code: 202, message: "Receipt successfully updated" }<br/>  }, status: :accepted<br/>end</span></pre><p id="e117" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，我首先找到我希望更新的 ReceiptRecord 对象。我计划从我的前端传递我希望删除的内部参数的图像的 id，所以我将这些 id 保存到<code class="du lg lh li kx b">to_delete</code>。然后，我在下面一行更新 ReceiptRecord 对象本身。</p><p id="7602" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，如果<code class="du lg lh li kx b">to_delete</code>为空(如果我没有传入任何 id)，那么<code class="du lg lh li kx b">if</code>语句被跳过，ReceiptRecord 对象被呈现。如果<code class="du lg lh li kx b">to_delete</code>不为空，我首先必须将字符串转换为数组(参数作为字符串传递)，映射到每个新创建的元素，并将每个元素转换为整数。我将结果保存到<code class="du lg lh li kx b">image_ids</code>。</p><p id="b84d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我在<code class="du lg lh li kx b">image_ids</code>中有了一个整数数组，我映射每个整数，找到具有匹配 id 的图像，并通过调用图像上的<code class="du lg lh li kx b">purge_later</code>删除它。<code class="du lg lh li kx b">Purge_later</code>是另一种主动存储方法，它不仅从<code class="du lg lh li kx b">active_storage_blobs</code>表中删除图像，还从<code class="du lg lh li kx b">active_storage_attachments</code>表中删除相关的行。(如果只想删除 blob，可以调用<code class="du lg lh li kx b">purge</code>方法代替)。</p><h2 id="f3a3" class="lb jq hi bd jr lk ll lm jv ln lo lp jz jb lq lr kd jf ls lt kh jj lu lv kl lw bi translated">销毁方法</h2><p id="6d3b" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">幸运的是，这里的最后一个方法并不难:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="d0cb" class="lb jq hi kx b fi lc ld l le lf">def destroy<br/>  receipt_record = ReceiptRecords.find(params[:id])<br/>  receipt_record.destroy</span><span id="0255" class="lb jq hi kx b fi lj ld l le lf">  render json: {<br/>    status: { code: 202, message: "Receipt successfully deleted" }<br/>  }, status: :accepted<br/>end</span></pre><p id="6564" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我只是找到了我想删除的 ReceiptRecord 对象，并在下面一行中删除它！因为我们在模型中添加了<code class="du lg lh li kx b">dependent: :destroy</code>选项，所以对象及其相关图像在这里都被删除了。</p><h1 id="71b2" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">步骤 4:最后一个(可选)设置</h1><p id="d731" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们已经基本上完成了 Rails 后端，但是我需要指出一件重要的事情。默认情况下，当您上传一个(或多个)图像时，Active Storage 会自动用新上传的图像替换该对象的任何现有图像。在某些情况下，这是可取的行为(比如当上传一个新的头像图片时；您希望它替换旧的)，但在我的情况下，我希望能够返回并添加更多的图像，而不是在这个过程中替换旧的图像。</p><p id="3605" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您更喜欢后一种行为，您将需要在您的<code class="du lg lh li kx b">config/environments</code>目录下的<code class="du lg lh li kx b">development.rb</code>文件中添加一个设置(我将它放在第 1 部分中您的<code class="du lg lh li kx b">config.active_storage.service = :amazon</code>行的正下方):</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="7b25" class="lb jq hi kx b fi lc ld l le lf">config.active.storage.replace_on_assign_to_many = false</span></pre><p id="133a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您计划稍后部署，您还必须将这个设置添加到您的<code class="du lg lh li kx b">production.rb</code>文件中。</p><p id="f79a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就结束了！我还必须介绍如何设置 React 前端来处理图像上传和删除，所以请关注第 3 部分！:)</p></div></div>    
</body>
</html>