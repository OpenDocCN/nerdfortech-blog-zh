<html>
<head>
<title>Testing REST API in Go with Testify and Mockery</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试REST API在Go中的验证和模拟</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/testing-rest-api-in-go-with-testify-and-mockery-c31ea2cc88f9?source=collection_archive---------2-----------------------#2021-06-07">https://medium.com/nerd-for-tech/testing-rest-api-in-go-with-testify-and-mockery-c31ea2cc88f9?source=collection_archive---------2-----------------------#2021-06-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/95c5a5037a7aef4d33f2ce20234a9869.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zhBK1WA5wMMWA9UK"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">由<a class="ae iu" href="https://unsplash.com/@qmikola?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">miko aj</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><blockquote class="iv iw ix"><p id="1c55" class="iy iz ja jb b jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw hb bi translated">"当低价的甜蜜被遗忘后，劣质的苦涩依然久久不散."<strong class="jb hj"> —本杰明·富兰克林</strong></p></blockquote><p id="98dd" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">让我们以一句引语开始这篇文章，当你读到这句引语时，你想到了什么？</p><p id="83ac" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">对我来说，顾名思义，和软件测试有关。</p><p id="2d45" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">有时，当我们写一些代码时，焦点只是尽快创建一个工作代码，而不考虑可读性、清晰性、有效性和可维护性。通过忘记这些顾虑，我们可能会有一个功能代码。我们的代码工作一段时间，直到有一些需要改变或其他开发人员介入。因为我们的代码首先是不可维护的，任何未来的改变都将是困难的。然后，如果其他开发人员介入并需要在我们的代码中更改或扩展一些功能，但我们的代码非常脏，那么我保证那个开发人员会因为这样脏的工作而对你生气。</p><p id="9c94" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">这种灾难将持续一段时间，直到发生彻底的变化或者应用程序崩溃。我们可以防止这种灾难的许多方法之一是编写单元测试。</p><p id="15e5" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">就像鲍勃大叔在<em class="ja"> Clean Code里说的“测试代码和生产代码一样重要”。我们的测试代码需要思考、设计和细心。它必须像产品代码一样保持干净。如果我们的生产代码可以保持干净，那么同样的事情也必须应用到测试代码中。要做到这一点，在围棋中使用证明和嘲弄来学习单元测试是有好处的。</em></p><h1 id="bc58" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">介绍</h1><figure class="kz la lb lc fd ij er es paragraph-image"><div class="er es ky"><img src="../Images/2463b1352f7ed3bc618f73e1917d1a31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*BC2jn86A6zHs4SAKCVcQYg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">按作者</figcaption></figure><p id="b291" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">在本文中，我们将为遵循这种架构的应用程序编写单元测试。有三个主要组件，处理程序、用例以及存储库。它们每个都有自己的任务，Handler负责处理传入和传出的数据，Usecase用于在与数据库联系之前和之后处理数据，Repository是我们用来与数据库通信的一层。简单地说，处理程序依赖于用例，用例依赖于存储库来工作。因此，因为我们想写单元测试而不是集成测试，所以我们需要嘲讽，我们将在这里学习。</p><p id="a7a6" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">免责声明:本文将涵盖概念，但为了便于阅读，忽略了一些细节。这里可以看到完整的代码<a class="ae iu" href="https://github.com/agusrichard/go-workbook/tree/master/restapi-test-app" rel="noopener ugc nofollow" target="_blank">https://github . com/agusrichard/go-workbook/tree/master/restapi-test-app</a>。</p><p id="46ca" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">有三个工具我经常使用，它们是Assert、Suite和Mock。先说Assert。</p><h1 id="b396" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">维护</h1><p id="2324" class="pw-post-body-paragraph iy iz hi jb b jc ld je jf jg le ji jj jx lf jm jn jy lg jq jr jz lh ju jv jw hb bi translated">Assert将是我们可以用于单元测试的最小的工具。如果你有一些使用Go内置包<code class="du li lj lk ll b">testing</code>的经验，很多时候，我们要写If语句来断言我们的实际输出是否正确。但是借助于testify，我们可以直接断言实际的输出，而不需要编写if语句。</p><p id="88af" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">使用assert的一般模式如下:</p><pre class="kz la lb lc fd lm ll ln lo aw lp bi"><span id="a710" class="lq kb hi ll b fi lr ls l lt lu">func TestSomething(t *testing.T) {<br/>   // define expected and actual<br/>   assert.Equal(t, expected, actual, "some message about this test")<br/>}</span></pre><p id="c78c" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">或者，如果您不想在每次使用时都将<code class="du li lj lk ll b">t</code>置为assert，您可以这样编写测试。</p><pre class="kz la lb lc fd lm ll ln lo aw lp bi"><span id="4bdf" class="lq kb hi ll b fi lr ls l lt lu">func TestSomething(t *testing.T) {<br/>   // define expected and actual<br/>   assert := assert.New(t)<br/>   assert.Equal(expected, actual, "some message about this test")<br/>}</span></pre><p id="c5b1" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">请注意，还有其他可用的断言，如Error、False、NotEqual、NoError、Nil等。你可以在https://pkg.go.dev/github.com/stretchr/testify/assert<a class="ae iu" href="https://pkg.go.dev/github.com/stretchr/testify/assert" rel="noopener ugc nofollow" target="_blank">的官方文件中得到完整的名单。</a></p><h1 id="ff0d" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">套房</h1><p id="f8a0" class="pw-post-body-paragraph iy iz hi jb b jc ld je jf jg le ji jj jx lf jm jn jy lg jq jr jz lh ju jv jw hb bi translated">大多数时候，当运行测试时，我们需要一些设置和拆卸功能。例如，当我们需要在运行所有测试用例之前建立一个连接，并需要清除数据库中所有注入的数据以开始一个新的会话时，为此，evidence为我们提供了一个套件。使用Suite，我们可以对相关的测试用例进行分组，在所有测试或单个测试之前进行一些设置，在所有测试或单个测试之后进行一些拆卸。</p><p id="fd9c" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">使用Suite的一般模式如下。</p><pre class="kz la lb lc fd lm ll ln lo aw lp bi"><span id="da4d" class="lq kb hi ll b fi lr ls l lt lu">type MySuite struct {<br/>   suite.Suite<br/>}<br/><br/>func (m *MySuite) SetupSuite() {<br/>   //... do some setup<br/>   // this function runs only once before all tests in a suite<br/>}<br/><br/>func (m *MySuite) TearDownSuite() {<br/>   //... do some teardown<br/>   // this function runs only once after all tests in a suite<br/>}<br/><br/>func (m *MySuite) SetupTest() {<br/>   //... do some setup<br/>   // this function runs before each test<br/>}<br/><br/>func (m *MySuite) TearDownTest() {<br/>   //... do some teardown<br/>   // this function runs after each test<br/>}</span><span id="1dad" class="lq kb hi ll b fi lv ls l lt lu">func (m *MySuite) TestOne() {<br/>   // we can write our test here<br/>}<br/><br/>func TestMySuite(t *testing.T) {<br/>   /// we still need this to run all tests in our suite<br/>   suite.Run(t, new(MySuite))<br/>}</span></pre><h1 id="e996" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">模拟的</h1><p id="abdf" class="pw-post-body-paragraph iy iz hi jb b jc ld je jf jg le ji jj jx lf jm jn jy lg jq jr jz lh ju jv jw hb bi translated">第三个是Mock。有时候，我们希望孤立地测试我们的功能。但是为了让我们的功能发挥作用，我们需要一些外部依赖。例如，在某个函数中，有一个对外部资源的API调用，如果我们在测试我们的函数时不想进行API调用，该怎么办？那么，我们如何独立地测试我们的功能，而不依赖于其他外部依赖呢？这就是我们需要嘲笑的时候。</p><p id="0876" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">这是用法示例:</p><pre class="kz la lb lc fd lm ll ln lo aw lp bi"><span id="32cd" class="lq kb hi ll b fi lr ls l lt lu">// main.go</span><span id="b074" class="lq kb hi ll b fi lv ls l lt lu">type MyStruct struct {<br/>   // some properties if needed <br/>}<br/><br/>type MyStructInterface struct {<br/>   DoAmazingStuff(input int) (bool, error)<br/>}</span><span id="d89a" class="lq kb hi ll b fi lv ls l lt lu">func (m *MyStruct) DoAmazingStuff(input int) (bool, error) {<br/>   // do something amazing in here    <br/>}</span><span id="87c6" class="lq kb hi ll b fi lv ls l lt lu">func AmazingFunction(m MyStructInterface) {<br/>   m.DoAmazingStuff(123)<br/>}</span><span id="600f" class="lq kb hi ll b fi lv ls l lt lu"><br/>// main_test.go</span><span id="73cf" class="lq kb hi ll b fi lv ls l lt lu">type MyStructMocked struct {<br/>   mock.Mock<br/>}<br/><br/>func (m *MyStructMocked) DoAmazingStuff(input int) (bool, error) {<br/>   // this is a mocked process<br/>   args := m.Called(input)<br/>   <br/>   // return the values based on the specified types   <br/>   return args.Bool(0), args.Error(1)<br/>}</span><span id="5051" class="lq kb hi ll b fi lv ls l lt lu">func TestAmazingFunction(t *testing.T) {<br/>   // create a mocked instance<br/>   testObj := new(MyStructMocked)<br/>   <br/>   // DoAmazingStuff will be called when AmazingFunction runs<br/>   // therefore you need to specify the arguments (the second <br/>   // position of method On) and its return values<br/>   testObj.On("DoAmazingStuff", 123).Return(true, nil)<br/>   <br/>   AmazingFunction(testObj)<br/>   testObj.AssertExpectations(t)<br/>}</span></pre><p id="8655" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">在这里，我们定义了我的结构。这是我们使用AmazingFunction需要的依赖项，因为我们必须向它传递MyStruct的一个实例。然后，我们定义了MyStruct的模拟版本，即MyStructMocked。请注意，要使用AmazingFunction，我们需要传递一个实现MyStructInterface的结构，因此，如果我们想将MyStructMocked的一个实例传递给AmazingFunction，MyStructMocked需要实现该接口。幸运的是，在Go中，实现一个接口我们不需要显式指定，因为在Go中接口是隐式实现的，而不是显式实现的。我们要做的只是创建与指定接口具有相同签名的相同方法。</p></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><h1 id="22ef" class="ka kb hi bd kc kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx bi translated">应用程序的实际使用情况</h1><p id="8cfd" class="pw-post-body-paragraph iy iz hi jb b jc ld je jf jg le ji jj jx lf jm jn jy lg jq jr jz lh ju jv jw hb bi translated">好的，之前我们已经学习了作证的基本用法。现在，我们如何在现实生活中使用它？</p><p id="e2d7" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">让我们从存储库开始。在这种情况下，如果想要获取、插入、更新或删除记录，存储库需要一个数据库连接。我们不会模拟数据库连接，我们将使用真实的数据库。为了简单起见，我将给出一个创建事务的例子(并忽略一些细节)。你可以在这里寻找完整的代码<a class="ae iu" href="https://github.com/agusrichard/go-workbook/tree/master/restapi-test-app" rel="noopener ugc nofollow" target="_blank">https://github . com/agusrichard/go-workbook/tree/master/restapi-test-app</a>。</p><h2 id="dcf4" class="lq kb hi bd kc mi mj mk kg ml mm mn kk jx mo mp ko jy mq mr ks jz ms mt kw mu bi translated">贮藏室ˌ仓库</h2><figure class="kz la lb lc fd ij"><div class="bz dy l di"><div class="mv mw l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">仓库的主文件</figcaption></figure><figure class="kz la lb lc fd ij"><div class="bz dy l di"><div class="mv mw l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">仓库的测试文件</figcaption></figure><p id="5c7f" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">正如我在上一节中解释的那样，当我们想要在套件中运行任何测试之前做一些设置时，使用SetupSuite如果我们想要在每次测试之后做一些事情，例如，清理我们使用过的任何表，则使用TearDownTest。</p><h2 id="09c8" class="lq kb hi bd kc mi mj mk kg ml mm mn kk jx mo mp ko jy mq mr ks jz ms mt kw mu bi translated">用例</h2><p id="5b02" class="pw-post-body-paragraph iy iz hi jb b jc ld je jf jg le ji jj jx lf jm jn jy lg jq jr jz lh ju jv jw hb bi translated">对于用例，因为我们需要存储库才能正常工作，但是我们不想实际使用存储库并调用数据库。这意味着我们需要模仿存储库。现在，嘲弄会给我们做这种嘲弄的东西很好的帮助。</p><p id="7240" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">还记得在存储库中，我们有一个它所使用的所有操作的接口吗？现在，我们需要模拟版本，通过输入命令<code class="du li lj lk ll b">mockery --name=TweetRepository</code>。这个命令将生成一个库的模拟版本。结果会是这样的。</p><figure class="kz la lb lc fd ij"><div class="bz dy l di"><div class="mv mw l"/></div></figure><p id="2787" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">在这之后，我们可以在用例中调用被嘲笑的版本。</p><figure class="kz la lb lc fd ij"><div class="bz dy l di"><div class="mv mw l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">用例的主文件</figcaption></figure><figure class="kz la lb lc fd ij"><div class="bz dy l di"><div class="mv mw l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">用例的测试文件</figcaption></figure><h2 id="6e4f" class="lq kb hi bd kc mi mj mk kg ml mm mn kk jx mo mp ko jy mq mr ks jz ms mt kw mu bi translated">处理者</h2><p id="aec1" class="pw-post-body-paragraph iy iz hi jb b jc ld je jf jg le ji jj jx lf jm jn jy lg jq jr jz lh ju jv jw hb bi translated">处理程序与用例有些类似，因为在用例中，我们模拟了存储库，那么对于处理程序，这意味着我们需要模拟用例。为了生成用例的模拟版本，您必须做与上一节相同的事情。不同之处在于赋予名称的值是Usecase接口。(<code class="du li lj lk ll b">mockery --name=TweetUsecase</code>)。这个命令将生成模拟版本，然后它就可以被我们的处理程序使用了。</p><figure class="kz la lb lc fd ij"><div class="bz dy l di"><div class="mv mw l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">处理程序的主文件</figcaption></figure><figure class="kz la lb lc fd ij"><div class="bz dy l di"><div class="mv mw l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">处理程序的测试文件</figcaption></figure></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><p id="8a7b" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">就是这样，我们已经测试了所有(有点😄)作为独立单元的我们的应用程序的构建块。尽管我使用的模型架构由处理程序、用例以及存储库组成。我相信同样的概念可以适用于更一般的情况。</p><h1 id="5ff3" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">结论</h1><p id="3869" class="pw-post-body-paragraph iy iz hi jb b jc ld je jf jg le ji jj jx lf jm jn jy lg jq jr jz lh ju jv jw hb bi translated">如果我们想让我们的测试更简单，证明和嘲弄将是我们需要的便利工具。因此，学习如何使用它们，对我们来说肯定是一个很好的点。总的来说，我们可以使用Assert来验证我们的函数是否做了正确的事情，有很多Assert提供的断言可以使用。当我们想要分组一些测试，做一些设置和拆卸时，我们使用Suite。最后，当我们的函数依赖于其他依赖项，但我们不想实际使用这些依赖项时，我们使用Mock。</p><p id="6ccc" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">感谢阅读，你可以在这里寻找完整代码<a class="ae iu" href="https://github.com/agusrichard/go-workbook/tree/master/restapi-test-app" rel="noopener ugc nofollow" target="_blank">https://github . com/agusrichard/go-workbook/tree/master/restapi-test-app</a>。</p><p id="cc76" class="pw-post-body-paragraph iy iz hi jb b jc jd je jf jg jh ji jj jx jl jm jn jy jp jq jr jz jt ju jv jw hb bi translated">如果这篇文章对你有帮助，请随意分享和鼓掌😁。</p></div></div>    
</body>
</html>