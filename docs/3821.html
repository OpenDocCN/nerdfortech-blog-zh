<html>
<head>
<title>Using JavaScripts bind, call and apply</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 JavaScripts 绑定、调用和应用</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/using-javascripts-bind-call-and-apply-868c4347cea9?source=collection_archive---------13-----------------------#2021-06-25">https://medium.com/nerd-for-tech/using-javascripts-bind-call-and-apply-868c4347cea9?source=collection_archive---------13-----------------------#2021-06-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/30fa904a13326397da5c652e12df5a6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ghVa--riy7Fq4p-iQUjGUQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@helloimnik" rel="noopener ugc nofollow" target="_blank">尼克</a>通过<a class="ae iu" href="https://unsplash.com/photos/4iQ3cUsE42U" rel="noopener ugc nofollow" target="_blank">unsplash.com</a>拍摄</figcaption></figure><p id="a5cb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="jt">关于 JavaScript 介绍性面试主题的迷你系列的第 3 部分。</em>T13】</strong></p><p id="65dc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我的上一篇文章，<a class="ae iu" rel="noopener" href="/nerd-for-tech/javascript-this-and-arrow-functions-215a90973a05"> JavaScript: this 和 arrow 函数</a>，探讨了 Arrow 函数如何使用它们的词法范围来确定<code class="du ju jv jw jx b">this</code>的值。这篇文章将深入讨论 bind()、call()和 apply()以及它们如何与我们的<code class="du ju jv jw jx b">this</code>系列相结合。</p><p id="8c2d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了充分理解这些功能，我想向您展示它们的共同点、主要区别以及各自的一些示例。先从他们的共同点说起。</p></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><p id="f24d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所有这三个函数有一个主要的共同点:它们给函数<code class="du ju jv jw jx b">this</code>赋值，这允许我们控制<code class="du ju jv jw jx b">this</code>所引用的上下文。这种相似性是我们到目前为止在这个迷你系列中所有其他帖子的联系。由于<code class="du ju jv jw jx b">this</code>可能会令人困惑，并且根据执行范围的不同而不同，我们可以使用 bind、call 和 apply 来简化一切。这三个让我们设定范围，为自己定义<code class="du ju jv jw jx b">this</code>应该是什么。</p><figure class="kg kh ki kj fd ij er es paragraph-image"><div class="er es kf"><img src="../Images/5f41cb672c6074f992035d8b67d7286b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*JViE8fKzeoQwitMnunK3JQ.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">经由<a class="ae iu" href="https://imgflip.com/memegenerator" rel="noopener ugc nofollow" target="_blank">imgflip.com</a></figcaption></figure><p id="5b13" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">也就是说，它们都有一些不同的地方。让我们很快看看这些区别是什么。</p><h1 id="2d96" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated"><span class="l li lj lk bm ll lm ln lo lp di"> A </span>参数</h1><p id="c967" class="pw-post-body-paragraph iv iw hi ix b iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo lu jq jr js hb bi translated">这三个函数的第一个不同之处在于它们接收参数的方式。bind 和 call 都接受单个逗号分隔的参数。另一方面，Apply 接受一组参数。我记得 apply 和 array 都是以字母 a 开头的。</p><h1 id="9e38" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">执行时间</h1><p id="543a" class="pw-post-body-paragraph iv iw hi ix b iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo lu jq jr js hb bi translated">另一个区别是它们执行的时间。调用时，call 和 apply 都会立即执行。另一方面，Bind 在它返回的函数被调用后执行。</p><p id="7c33" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">时间不同的原因是因为我们的下一个不同点…</p><h1 id="e83f" class="kk kl hi bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh bi translated">返回值</h1><p id="a4bd" class="pw-post-body-paragraph iv iw hi ix b iy lq ja jb jc lr je jf jg ls ji jj jk lt jm jn jo lu jq jr js hb bi translated">call 和 apply 立即执行的原因是，它们的返回值是调用它们的函数返回的值。为了返回那个值，他们需要立即执行。</p><p id="d5d6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Bind 返回一个新的函数，这个函数必须首先被调用，这就是为什么它不立即执行的原因。</p><p id="e3d7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">比较结束后，让我们看一些例子。</p><pre class="kg kh ki kj fd lv jx lw lx aw ly bi"><span id="6d04" class="lz kl hi jx b fi ma mb l mc md">Bind</span><span id="ae0c" class="lz kl hi jx b fi me mb l mc md">1.  const person = {<br/>2.    name: 'Bob',<br/>3.    sayHi: function() { return this.name }<br/>4.  }</span><span id="7fa6" class="lz kl hi jx b fi me mb l mc md">5.  const globalHello = person.sayHi<br/>6.  console.log(`Hello ${globalHello()}`) <br/>7.  // logs 'Hello'</span><span id="5c19" class="lz kl hi jx b fi me mb l mc md">8.  const boundHello = globallHello.bind(person)<br/>9.  console.log(`Hello ${boundHello()}`)<br/>10. // logs 'Hello Bob'</span></pre><p id="d354" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如您所见,<code class="du ju jv jw jx b">globalHello</code>并没有记录您所期望的内容。从全局范围调用时，<code class="du ju jv jw jx b">this.name</code>实际上是指全局<code class="du ju jv jw jx b">this</code>，并且是未定义的。在<code class="du ju jv jw jx b">boundHello</code>中将<code class="du ju jv jw jx b">person</code>绑定到<code class="du ju jv jw jx b">globalHello</code>会将<code class="du ju jv jw jx b">this</code>的值分配给 person，因此当<code class="du ju jv jw jx b">sayHi</code>被调用时，它可以访问<code class="du ju jv jw jx b">person</code>并可以访问其<code class="du ju jv jw jx b">name</code>属性 Bob。</p><p id="acb8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我发现 bind 对于事件和异步回调特别有用。因为您可以在添加事件侦听器或启动异步函数时绑定它，然后在事件被触发或承诺被返回时等待执行。</p><pre class="kg kh ki kj fd lv jx lw lx aw ly bi"><span id="b0b5" class="lz kl hi jx b fi ma mb l mc md">Call</span><span id="1870" class="lz kl hi jx b fi me mb l mc md">1.  const person = {<br/>2.    sayHi: function(lastName) { return this.name + ' ' + lastName}<br/>3.  }</span><span id="97df" class="lz kl hi jx b fi me mb l mc md">4.  const firstPerson = {<br/>5.    name: 'Bob'<br/>6.  }</span><span id="1f95" class="lz kl hi jx b fi me mb l mc md">7.  console.log(`Hi ${person.sayHi.call(firstPerson, 'Jones')}`)<br/>8.  // logs 'Hi Bob Jones'</span></pre><p id="435f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">用<code class="du ju jv jw jx b">call</code>指出两件事。首先像我们之前讨论的一样，<code class="du ju jv jw jx b">call</code>被立即执行，其次它接受逗号分隔的参数。如果我们想通过一个年龄和职业，它会是这样的:</p><pre class="kg kh ki kj fd lv jx lw lx aw ly bi"><span id="76e8" class="lz kl hi jx b fi ma mb l mc md">person.sayHi.call(firstPerson, 'Jones', 25, 'Blogger')</span></pre><p id="ddf1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了简单起见，我将对 apply 使用相同的示例，因为它们是同时执行的，因此除了参数之外看起来是一样的。这是最后一个添加了年龄和职业的例子。</p><pre class="kg kh ki kj fd lv jx lw lx aw ly bi"><span id="66fa" class="lz kl hi jx b fi ma mb l mc md">person.sayHi.apply(firstPerson, ['Jones', 25, 'Blogger'])</span></pre><p id="8122" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">调用和应用可以互换使用，参数是最大的区别。</p><p id="7b83" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">热门提示:您可以使用 apply 从数组中找到最大值，这非常有用，因为 JavaScript 数组没有 max 方法。</em></p><pre class="kg kh ki kj fd lv jx lw lx aw ly bi"><span id="f647" class="lz kl hi jx b fi ma mb l mc md">1. let arr = [1, 2, 3, 4, 5]<br/>2. Math.max(arr) =&gt; NaN<br/>3. Math.max.apply(null, arr) =&gt; 5</span></pre><p id="3a2f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">记住，对于所有三个函数，bind、call 和 apply，第一个参数将是它的值，之后的所有参数都将传递给被调用的函数。</p></div><div class="ab cl jy jz gp ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hb hc hd he hf"><p id="7764" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">希望读完这篇文章后，你能更好地理解这三个函数是如何工作的，以及为什么它们在 JavaScript 中如此重要。没有它们<code class="du ju jv jw jx b">this</code>很容易混淆，尤其是在较大的程序中。tmed</p><p id="8a4b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">一如既往地在下面留下我错过的任何东西或其他用例的评论！</p><p id="a8a8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" rel="noopener" href="/nerd-for-tech/what-is-this-javascripts-this-keyword-23cc6fab741a"> <strong class="ix hj"> <em class="jt">第一部分这是什么？JavaScripts 这个关键字</em> </strong> </a></p><p id="08b5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" rel="noopener" href="/nerd-for-tech/javascript-this-and-arrow-functions-215a90973a05"> <strong class="ix hj"> <em class="jt">第二部分:JavaScript:本和箭头功能</em> </strong> </a></p></div></div>    
</body>
</html>