<html>
<head>
<title>Apache Kafka Internals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">阿帕奇卡夫卡内部</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/apache-kafka-internals-d488a26c9cfb?source=collection_archive---------7-----------------------#2021-07-11">https://medium.com/nerd-for-tech/apache-kafka-internals-d488a26c9cfb?source=collection_archive---------7-----------------------#2021-07-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="2fc3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">卡夫卡无处不在。每个组织都以某种形式使用Kafka，事件源、跨系统移动数据、不可变数据存储、解耦服务。Kafka已经成为每个数据驱动组织的神经系统，这是正确的，因为它确实为您提供了一系列配置，您可以调整这些配置，使其适合不同的用例。通过正确的配置，它可以充当可靠的不可变数据存储，或者极快的消息传递系统。</p><p id="b422" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有分布式系统都涉及到可伸缩性、性能、可用性和可靠性之间的权衡。而这正是Kafka的闪光点，Kafka将这些决策以配置的形式委托给开发者。开发人员可以根据需要从高可靠到高可用进行配置。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/69d9c5f60558ba7b42caa4b5fc3514c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ebR_NbbSj9gLBtth_SULpQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">阿帕奇·卡夫卡作为公司内部的中枢神经系统</figcaption></figure><p id="0c51" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Apache Kafka最初是一个发布/订阅消息系统，通常被描述为“分布式提交日志”，但现在它的功能更强大了。如今，它可以用作流处理引擎、不可变数据存储或消息传递系统。</p><p id="97ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们要看一看卡夫卡的一些基本概念，这些概念让它变得如此强大。我还试图在Kafka源代码中提供一些指针，以便更好地理解。</p><h1 id="3648" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">分割</h1><p id="5bc0" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">在Kafka中，分区是主要的并发机制。通过分区，Kafka可以在Kafka集群中扩展主题的负载。对主题进行分区也会带来性能和吞吐量，假设一个Kafka主题有4个分区。现在，我们可以从同一个主题同时读/写4个分区。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kw"><img src="../Images/1f8899a638ca7320fa04eb4ff39e1899.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HCEbq7P46EZDTOgu"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">卡夫卡主题的平行消费</figcaption></figure><h2 id="3f3e" class="kx ju hi bd jv ky kz la jz lb lc ld kd iq le lf kh iu lg lh kl iy li lj kp lk bi translated">消息到分区的映射</h2><p id="0718" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">默认情况下，如果没有指定自定义分区器，Kafka会使用<a class="ae ll" href="https://github.com/apache/kafka/blob/3.0/clients/src/main/java/org/apache/kafka/clients/producer/internals/DefaultPartitioner.java#L34" rel="noopener ugc nofollow" target="_blank"> DefaultPartitioner </a>。映射策略如下:</p><ul class=""><li id="7e8e" class="lm ln hi ih b ii ij im in iq lo iu lp iy lq jc lr ls lt lu bi translated">如果分区号已经在ProducerRecord中指定，那么只需<a class="ae ll" href="https://github.com/apache/kafka/blob/3.0/clients/src/main/java/org/apache/kafka/clients/producer/KafkaProducer.java#L1281" rel="noopener ugc nofollow" target="_blank">使用它</a>。</li><li id="b03a" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">否则，如果密钥出现在消息中，则使用<a class="ae ll" href="https://github.com/apache/kafka/blob/3.0/clients/src/main/java/org/apache/kafka/clients/producer/internals/DefaultPartitioner.java#L71" rel="noopener ugc nofollow" target="_blank">确定性散列算法</a>将密钥映射到分区号。</li><li id="068d" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">如果key不存在，那么它会在分区之间公平地分发消息，以平衡Kafka集群的负载</li></ul><blockquote class="ma mb mc"><p id="af07" class="if ig md ih b ii ij ik il im in io ip me ir is it mf iv iw ix mg iz ja jb jc hb bi translated">确定性散列确保具有相同密钥的每条消息最终出现在相同的分区中，在本文撰写之时，Kafka使用<a class="ae ll" href="https://github.com/apache/kafka/blob/3.0/clients/src/main/java/org/apache/kafka/common/utils/Utils.java#L439" rel="noopener ugc nofollow" target="_blank"> murmur2散列</a>算法。</p></blockquote><h1 id="135e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">分身术</h1><p id="0a35" class="pw-post-body-paragraph if ig hi ih b ii kr ik il im ks io ip iq kt is it iu ku iw ix iy kv ja jb jc hb bi translated">在任何分布式系统中，节点失效都是不可避免的，因此在这样的系统中，容错策略必须考虑周全。对于容错，像许多数据库一样，Kafka依赖于分区的复制。复制确保在发生任何故障时，集群中至少有一个分区副本可用。</p><p id="773f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">数据库中3种流行的复制策略(单领导、多领导和无领导复制)。卡夫卡使用单头复制。我们在设置主题时指定了复制因子。</p><p id="583c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有两种类型的副本:</p><p id="e7d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">领导者副本:</strong>每个分区有一个副本被指定为领导者。为了保证一致性，所有的生产和消费请求都要经过领导者。</p><p id="8808" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">跟随者副本:</strong>一个分区中所有不是领导者的副本都被称为跟随者。追随者不会为客户的要求服务；他们唯一的工作就是复制来自领导者的信息，并与领导者拥有的最新信息保持同步。</p><p id="e7f6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果一个分区的主副本崩溃，一个从副本将被提升为该分区的新主副本。该故障转移由<a class="ae ll" href="https://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/controller/KafkaController.scala#L71" rel="noopener ugc nofollow" target="_blank"> KafkaController </a>协调</p><h1 id="8e20" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">卡夫卡制片人概述</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mh"><img src="../Images/9df9016bd40fea1755271ee3febbc5c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*yUaGRY8PWevliBNIb7Woiw.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">Kafka Producer的高级概述</figcaption></figure><p id="8435" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">向卡夫卡发送信息的步骤包括:</p><ol class=""><li id="182f" class="lm ln hi ih b ii ij im in iq lo iu lp iy lq jc mi ls lt lu bi translated">我们通过创建一个ProducerRecord开始向Kafka发送消息，它必须包括我们要将记录发送到的主题和一个值。或者，我们也可以指定一个键和/或一个分区。</li><li id="8d81" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc mi ls lt lu bi translated">首先我们序列化<a class="ae ll" href="https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/KafkaProducer.java#L921" rel="noopener ugc nofollow" target="_blank">键</a>和<a class="ae ll" href="https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/KafkaProducer.java#L929" rel="noopener ugc nofollow" target="_blank">值</a></li><li id="6969" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc mi ls lt lu bi translated">接下来，数据被发送到<a class="ae ll" href="https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/KafkaProducer.java#L935" rel="noopener ugc nofollow" target="_blank">分区器</a>以找出分区号</li><li id="9915" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc mi ls lt lu bi translated">然后，记录被添加到<a class="ae ll" href="https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/KafkaProducer.java#L954" rel="noopener ugc nofollow" target="_blank">队列</a>中，以便发送给Kafka代理。</li><li id="32e4" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc mi ls lt lu bi translated">最后，一个后台<a class="ae ll" href="https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/internals/Sender.java#L72" rel="noopener ugc nofollow" target="_blank">线程</a>从队列中挑选记录，并将其发送到Kafka集群。</li></ol><p id="5dd5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这绝对不是一个全面的卡夫卡指南，将尝试创建它的另一部分，更侧重于卡夫卡消费端。</p><p id="4b45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢您的阅读</p></div></div>    
</body>
</html>