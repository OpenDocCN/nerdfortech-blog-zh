<html>
<head>
<title>Promises in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript 中的承诺</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/promises-in-javascript-88da85b1c65e?source=collection_archive---------26-----------------------#2021-06-11">https://medium.com/nerd-for-tech/promises-in-javascript-88da85b1c65e?source=collection_archive---------26-----------------------#2021-06-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="c63f" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">什么是承诺？</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/445328523daf862844a2cea24edeefd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uh8D23FvqoUOqVIH5Z_r6A.jpeg"/></div></div></figure><p id="5e48" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">来自 MDN 的一个很棒的定义:<em class="kf">promise 对象表示异步操作的最终完成(或失败)及其结果值。</em></p><p id="e750" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">JavaScript 承诺类似于我们在现实生活中对承诺的看法。一个承诺要么被履行(“解决”)，要么被打破(“拒绝”)。我们的承诺是从一个构造函数创建的，并接受一个带有两个参数的回调函数，一个用于<em class="kf"> resolve </em>，一个用于<em class="kf"> reject </em>。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kg"><img src="../Images/b7477034caf6a56c7e9ee7e0a7e50c3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*8SYgq39Xxs4O4ZuGRE_Z-w.png"/></div></figure><p id="1b93" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">承诺本质上是异步的，并且在 JavaScript 调用栈上运行了所有同步代码之后返回。它们非常适合执行通常需要很长时间才能运行的代码(例如，从服务器获取数据)，而不会导致调用堆栈被阻塞。基于承诺中的条件，它要么被解决，要么被拒绝。让我们看看这是什么样子:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es kh"><img src="../Images/72eeed8683427470e7f562e5b25cbe2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*DioUkgxmzdIAIOyqWTihKw.png"/></div></figure><p id="8427" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果条件在承诺中得到满足，我们希望解决承诺，否则，我们拒绝它。在上面的例子中，我们看到我们的承诺应该被解决，因为 sum === 5 为真。但是我们实际上如何返回<em class="kf">解析</em>中的数据呢？</p><h2 id="2823" class="ki kj hi bd kk kl km kn ko kp kq kr ks js kt ku kv jw kw kx ky ka kz la lb lc bi translated">用<em class="ld">进行承诺链接。然后()</em>和。catch()</h2><p id="9ce3" class="pw-post-body-paragraph jj jk hi jl b jm le ij jo jp lf im jr js lg ju jv jw lh jy jz ka li kc kd ke hb bi translated">为了看到我们承诺的结果，我们需要添加或“链接”一个方法。为了返回一个已解决的承诺，我们链接<em class="kf">。然后()</em>。该方法接受一个回调，该回调可以选择访问我们解析的数据作为参数。让我们看两个例子:第一个例子是利用匿名回调中的可选参数来显示我们解析的数据，第二个例子是传递一个现有的回调而不使用解析的数据。两个回调都不会运行，直到调用堆栈为空，并且承诺已经通过回调队列并返回到调用堆栈。我添加了一个同步 console.log 来演示:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lj"><img src="../Images/a806908a170a88d85c088fd6151c9442.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RtXCShSWR8WzWHZgncEPaA.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">记录来自已解决承诺的数据的示例</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lo"><img src="../Images/c8eb18ea29af563721173add418098c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QQQ1wHQ-cZZyaW0hAZj7pA.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">执行现有回调而不是使用已解析承诺中的数据的示例</figcaption></figure><p id="5f73" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果一个承诺被拒绝，我们需要在<em class="kf">上加上锁链。catch() </em>方法返回承诺。数据可以作为回调的参数访问，就像<em class="kf">一样。然后()</em>作品。注意<em class="kf">。catch() </em>只会返回已被拒绝的承诺:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lp"><img src="../Images/086af8f85414ad63424ffe0ba40a5c58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ev76yWTqLtO7FDWg59dRbg.png"/></div></div></figure><p id="e3e6" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated"><strong class="jl hj">边注:</strong>可以用<em class="kf">退回被拒绝的承诺。然后()，</em>然而，这并不是一个很常用的方法:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lq"><img src="../Images/199d791ffcb7d5a176a2bccd9bed74c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n73uWlfmQEVDtb8Uk2Pdog.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">退回被拒绝的承诺。然后()</figcaption></figure><h2 id="0572" class="ki kj hi bd kk kl km kn ko kp kq kr ks js kt ku kv jw kw kx ky ka kz la lb lc bi translated"><strong class="ak">承诺的三种状态</strong></h2><p id="abe6" class="pw-post-body-paragraph jj jk hi jl b jm le ij jo jp lf im jr js lg ju jv jw lh jy jz ka li kc kd ke hb bi translated">我们的承诺有三种状态:<strong class="jl hj">未决、已解决、</strong>或<strong class="jl hj">拒绝</strong>。承诺在到达事件循环中的调用堆栈后处于“待定”状态，并被发送到 Web APIs 容器(参见我的<a class="ae lr" href="https://javascript.plainenglish.io/what-is-the-javascript-event-loop-84d21ef276ee" rel="noopener ugc nofollow" target="_blank">关于 JavaScript 事件循环的博客</a>)。我们的 promise 主体将在 WebAPIs 容器中执行，并确定是被解析还是被拒绝，而其余的同步代码在调用堆栈中运行。一旦调用栈为空，<em class="kf"> resolve </em>或<em class="kf"> reject </em>方法(取决于我们的承诺)将访问调用栈，我们将可以在<em class="kf">中访问它的数据。然后()</em>或者<em class="kf">。catch() </em>方法。</p><h2 id="5709" class="ki kj hi bd kk kl km kn ko kp kq kr ks js kt ku kv jw kw kx ky ka kz la lb lc bi translated">承诺和回访</h2><p id="c275" class="pw-post-body-paragraph jj jk hi jl b jm le ij jo jp lf im jr js lg ju jv jw lh jy jz ka li kc kd ke hb bi translated">承诺解决嵌套回调过多的问题，也称为“回调地狱”。关于这个话题的更多信息，我建议观看 Dev Ed 的伟大的 YouTube 视频。</p></div></div>    
</body>
</html>