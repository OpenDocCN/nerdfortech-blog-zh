<html>
<head>
<title>Why I am disappointed in GitHub</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我对GitHub感到失望</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/why-i-am-dissapointed-in-github-16fd664754ef?source=collection_archive---------8-----------------------#2021-06-11">https://medium.com/nerd-for-tech/why-i-am-dissapointed-in-github-16fd664754ef?source=collection_archive---------8-----------------------#2021-06-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/e3802e7e5da4082be72e42db62fa6564.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7voUL8Pn7qpd9Udx.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">(如果github不允许这个图片，我可以删除它)</figcaption></figure><div class=""/><p id="b639" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们从我为什么使用GitHub开始。</p><p id="a3f6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">从一开始，我们公司就是一个微软商店。我们的第一个平台是用。NET FW，我们的云提供商是Azure，所以我们使用后来成为Azure DevOps的Visual Studio Online是很自然的。我们的整个代码库都在那里，我们也有许多管道，让我们自动化部署已经很多年了。</p><p id="ddb6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但是现在，由于一些内部情况，以及多样化提供者的需要(另外Azure Pipelines在过去几个月出现了很多问题)，我们希望开始使用GitHub作为我们的代码库，自然，我们也将使用GitHub操作。GitHub有一个非常便宜的团队层，它为我们提供了我们需要的东西(理论上)。</p><p id="9f1b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们要转移的代码对应于我们正在构建的平台的第二个版本(大部分在NodeJs中，但仍在Azure中)。</p></div><div class="ab cl js jt gp ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="hb hc hd he hf"><p id="3561" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们的第一步是将所有代码从Azure Repos转移到GitHub。我在周末花了大约两个小时来做这件事(这样车队就不会被堵住了),一切顺利，没有任何麻烦。</p><p id="0a57" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="jz">提示建议:千万不要用导入，只需做一个普通的</em> <code class="du ka kb kc kd b"><em class="jz">git clone</em></code> <em class="jz">，改变git原点，然后做一个</em><code class="du ka kb kc kd b"><em class="jz">git push</em></code><em class="jz"/><code class="du ka kb kc kd b"><em class="jz">master</em></code><em class="jz">分支。这样更简单快捷。你得到了全部的大师历史。如果你有其他分支，你可以做同样的程序。</em></p><p id="3302" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">周一，一旦我们有了GitHub中的所有代码，我们在Azure Pipelines中再次创建了所有管道(但仍然使用位于每个回购中的相同的<code class="du ka kb kc kd b">azure-pipelines.yml</code>脚本),但现在它们将从GitHub中检出。我们这样做是为了不阻碍团队继续他们的冲刺，因为GHA脚本需要更长的时间来转换。</p><figure class="kf kg kh ki fd hk er es paragraph-image"><div class="er es ke"><img src="../Images/7b7f93f98a292c625995838b11d943cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*zwPjM6bc3n4lmXDE3m9M4w.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">我们计划好的旅行</figcaption></figure><p id="9780" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在是时候做一个概念验证来运行一个完整的迁移了，这是我们开始这篇文章的中心部分。</p><h1 id="51b5" class="kj kk hx bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">第一步，Azure工件到GitHub包</h1><p id="1502" class="pw-post-body-paragraph iu iv hx iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr hb bi translated">像往常一样，在每个有许多模块和应用程序的平台中(特别是现在有了微服务模式)，总是需要共享一个不可避免地需要在私有feed中发布的公共基础或框架，在这种情况下是<strong class="iw hy">Azure Artifacts</strong>(Azure devo PS的一个模块)。</p><p id="fdd7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">GitHub中的对应物叫做<strong class="iw hy"> GitHub包</strong>。这两个解决方案是相似的，但是GitHub包也允许Docker图像，这是一个很好的补充(在我们的例子中，它允许我们消除Azure容器注册，并把所有东西放在一个地方)。</p><p id="fab4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">将NodeJs包发布到GHP非常容易，您只需将名称与org匹配，并在您的<code class="du ka kb kc kd b">package.json</code>文件中放入一个<code class="du ka kb kc kd b">publishConfig</code>部分，如下所示:</p><pre class="kf kg kh ki fd lm kd ln lo aw lp bi"><span id="9c9a" class="lq kk hx kd b fi lr ls l lt lu">"name": "@myorg/mypack",<br/>"repository": "<a class="ae lv" href="https://github.com/jztechpe/infra.git" rel="noopener ugc nofollow" target="_blank">https://github.com/myorg/mypack.git</a>",<br/>"publishConfig": {<br/>    "registry": "<a class="ae lv" href="https://npm.pkg.github.com" rel="noopener ugc nofollow" target="_blank">https://npm.pkg.github.com</a>"<br/> },</span></pre><p id="d667" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后对注册中心执行一个<code class="du ka kb kc kd b">npm login</code>(使用您用户名、PAT和您的电子邮件)来将您的凭证和令牌存储在您的本地机器中，然后您可以运行<code class="du ka kb kc kd b">npm publish</code>来发布这个包。</p><p id="b47e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所以，运行这些步骤很简单。我们所有的内部包现在都正确地发布到了GitHub包中。</p><p id="e3f5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果不能使用这些包，发布就没有任何意义，所以下一步是构建一个Docker映像，其中包含我们第一个需要这些包的微服务。请记住，这在使用Azure DevOps之前就已经完成了，因此我们可以肯定地知道映像已经正确构建并运行。</p><p id="1500" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们的第一个问题就是从这一点开始的。</p><p id="c785" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们的Dockerfile会像往常一样复制代码，运行<code class="du ka kb kc kd b">npm ci</code>，然后启动<code class="du ka kb kc kd b">node index.js</code>。为了从我们的内部feed安装软件包，我们必须在<code class="du ka kb kc kd b">package.json</code>文件旁边有一个名为<code class="du ka kb kc kd b">.npmrc</code>的文件。该文件的内容应该类似于:</p><pre class="kf kg kh ki fd lm kd ln lo aw lp bi"><span id="a3f1" class="lq kk hx kd b fi lr ls l lt lu"><a class="ae lv" href="http://twitter.com/jztechpe" rel="noopener ugc nofollow" target="_blank">@m</a>yorg:registry=<a class="ae lv" href="https://npm.pkg.github.com/" rel="noopener ugc nofollow" target="_blank">https://npm.pkg.github.com/</a><br/><a class="ae lv" href="http://twitter.com/jztechpe" rel="noopener ugc nofollow" target="_blank">@m</a>yorg:always-auth=true</span></pre><p id="c106" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">其中<code class="du ka kb kc kd b">myorg</code>是您的github组织。</p><p id="2dd8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我第一次尝试构建映像时，由于403未授权而失败，这意味着您没有访问该私有提要的权限。</p><p id="dd06" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在绞尽脑汁了一天，阅读了一些github问题和文章后，我发现了一条关于<code class="du ka kb kc kd b">package-lock.json</code>文件的非常微妙但关键的信息。</p><p id="f59d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">事实上，问题就在那里:所有注册的包都连接到我们的Azure Artifacts私有feed(甚至那些应该在公共注册表中的包，我们稍后会解释原因)，这显然是我们想要避免的。</p><p id="f8db" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我尝试的第一件事是删除文件，并再次运行一个<code class="du ka kb kc kd b">npm install</code>。它不起作用。它不断生成AA feed的链接。所以我接下来做的是:</p><ol class=""><li id="deb3" class="lw lx hx iw b ix iy jb jc jf ly jj lz jn ma jr mb mc md me bi translated">运行<code class="du ka kb kc kd b">npm cache clean --force</code>以避免任何缓存。</li><li id="1b31" class="lw lx hx iw b ix mf jb mg jf mh jj mi jn mj jr mb mc md me bi translated">删除我的机器npmrc文件(在<code class="du ka kb kc kd b">%USERPROFILE%/npm</code>)。</li></ol><p id="ce50" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这些步骤的结果是，我现在运行了一个新的npm副本。没有缓存，也没有登录的干扰，我再次运行了一个<code class="du ka kb kc kd b">npm install</code>。</p><p id="9adf" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这次成功了！。所有在npmjs.org发现的包裹，现在都与此相关，我们的私人包裹如我们所料来自GHP。</p><p id="82d5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">于是我终于再次运行<code class="du ka kb kc kd b">docker build</code>，镜像构建成功。这个docker构建是使用GitHub操作完成的(获取示例非常容易),我的docker文件如下所示:</p><pre class="kf kg kh ki fd lm kd ln lo aw lp bi"><span id="e80d" class="lq kk hx kd b fi lr ls l lt lu">FROM node:15-alpine AS builder</span><span id="ae91" class="lq kk hx kd b fi mk ls l lt lu">ARG NPM_INSTALL_TOKEN<br/>ENV NPM_INSTALL_TOKEN $NPM_INSTALL_TOKEN</span><span id="044a" class="lq kk hx kd b fi mk ls l lt lu">ENV NODE_ENV=production<br/>WORKDIR /app<br/>COPY package*.json ./<br/>COPY .npmrc ./</span><span id="a319" class="lq kk hx kd b fi mk ls l lt lu"># npmrc needs to have a blank ending line for this to work<br/>RUN echo //npm.pkg.github.com/:_authToken=$NPM_INSTALL_TOKEN &gt;&gt; ./.npmrc</span><span id="dcf4" class="lq kk hx kd b fi mk ls l lt lu"># install all dependencies<br/>RUN npm ci<br/>RUN npm install pino-papertrail<br/>COPY . .</span><span id="fb54" class="lq kk hx kd b fi mk ls l lt lu">ENTRYPOINT node "/app/src/index.js"</span></pre><p id="2b74" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里有两个关键点。</p><p id="d776" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">第一个是ARG NPM _安装_令牌，这是您使用<code class="du ka kb kc kd b">packages:read</code>权限创建的PAT，需要作为构建参数传递给<code class="du ka kb kc kd b">docker build</code>命令。</p><p id="a98d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">注意:在文档的某些部分说你可以使用GITHUB_TOKEN，但是我停止使用它了，因为我的包是作为org-level安装的，并且这个TOKEN只能在你正在处理的库内工作。</p><p id="68ab" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">第二个是使用(<code class="du ka kb kc kd b">RUN echo //npm.pkg.github.com/:_authToken=$NPM_INSTALL_TOKEN &gt;&gt; ./.npmrc</code>)将这个令牌添加到npmrc文件中。</p><p id="4a10" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="jz">我知道将令牌写入npm文件可能不安全，但在我的情况下，docker映像将位于私有注册表中，因此风险很低。</em></p><p id="8ce9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我的GitHub操作工作流程如下所示:</p><pre class="kf kg kh ki fd lm kd ln lo aw lp bi"><span id="9232" class="lq kk hx kd b fi lr ls l lt lu">on:<br/>  workflow_dispatch: # to allow manual execution<br/>  push:<br/>    branches: [main]<br/>jobs:<br/>  build:<br/>    env:<br/>      srcPath: core<br/>      imageBase: ${{ github.repository }}<br/>      ORG_BUILD_DEPLOY_TOKEN: "${{ secrets.ORG_BUILD_DEPLOY_TOKEN }}"<br/>    runs-on: ubuntu-latest<br/>    steps:<br/>    - uses: actions/checkout@v2<br/>    - uses: nanzm/get-time-action@v1.1<br/>      id: time<br/>      with:<br/>        timeZone: -5 # Peru<br/>        format: 'YYYYMMDD_HHmmss'<br/>    - uses: docker/login-action@v1<br/>      name: Log in to GitHub Docker Registry<br/>      with:<br/>        registry: ghcr.io<br/>        username: ${{ github.actor }}<br/>        password: ${{ env.ORG_BUILD_DEPLOY_TOKEN }}<br/>    - uses: docker/build-push-action@v2<br/>      name: Build docker image and push<br/>      env:<br/>        imageTag: ${{ steps.time.outputs.time }}<br/>        imageUri: ghcr.io/${{ env.imageBase }}<br/>      with:<br/>        context: ${{ env.srcPath }}<br/>        build-args: NPM_INSTALL_TOKEN=${{ env.ORG_BUILD_DEPLOY_TOKEN }}<br/>        push: true<br/>        tags: |<br/>          ${{ env.imageUri }}:${{ env.imageTag }}<br/>          ${{ env.imageUri }}:latest</span></pre><p id="a415" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">此外，还有一个因素使事情变得更糟。有一样东西是AA有而GHP没有的，那就是上游信号源<strong class="iw hy">。在NPM(例如与nuget相反)，您只能配置一个注册中心来获取软件包。因此，为了获得应用程序需要的私有和公共包(如axios)，您必须通过上游源将私有注册中心连接到公共注册中心(npm在私有提要中查找，如果没有找到，它就在公共提要中查找)。因为AA的这个功能，我所有的<code class="du ka kb kc kd b">package-lock.json</code>引用都指向我的私有注册表。我们必须适应新的环境。</strong></p><p id="8d75" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">尽管我能够解决我的问题，但我确实认为拥有上游资源是必须的，令人惊讶的是GHP却没有。</strong></p><p id="ab18" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">既然我们已经构建并发布了docker映像，现在我们需要将它部署到我们的试运行和生产环境中。这就是我现在被困的地方。</p><p id="f4b9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">总结</strong></p><p id="a1bf" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">优点:GitHub包允许Docker镜像。易于连接。</p><p id="fe4a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">缺点:没有上游来源</p><h1 id="4a66" class="kj kk hx bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">第二步，Azure管道到GitHub动作</h1><p id="2acc" class="pw-post-body-paragraph iu iv hx iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr hb bi translated">在我们的例子中，我们的开发工作流需要在转移到生产环境之前在试运行环境中进行一些手动检查，因此在测试完成之后，我们手动允许它被推到生产环境中。</p><p id="c452" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这在Azure Pipelines中工作得很好，他们有环境的概念，然后为每个环境(STG和PROD)设置一个只能被某些人接受的批准检查。因此，通过这种方式，我们可以控制应用程序向生产环境的流动。</p><p id="ed25" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">GitHub Actions也有这个概念。然而<strong class="iw hy">只适用于GitHub企业级(我们负担不起)</strong>。<strong class="iw hy">所以现在我们在死路一条，要把整个栈转换成GitHub。</strong></p><pre class="kf kg kh ki fd lm kd ln lo aw lp bi"><span id="057b" class="lq kk hx kd b fi lr ls l lt lu">{{ TYPICAL PIPELINE STRUCTURE WITH THREE SERIAL STAGES OR JOBS }}</span><span id="09d9" class="lq kk hx kd b fi mk ls l lt lu">code &gt; [build] &gt; artifact<br/>artifact &gt; [deploy] &gt; stg<br/>artifact &gt; [deploy] &gt; prod</span></pre><p id="8de5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">以上是管道必须完成的典型结构:构建一个工件，并部署为该管道冻结的工件。理论上，我们不应该分离流程，因为您将面临部署“不同”的东西的风险(我知道您可以在一次提交中进行检查，但这更难执行)。</p><p id="7fc3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我试过了:</p><ol class=""><li id="be4c" class="lw lx hx iw b ix iy jb jc jf ly jj lz jn ma jr mb mc md me bi translated">创建单独的工作流以部署到STG或PROD。</li></ol><p id="04d9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这并不简单，因为构建工作流结果(工件)应该通过管道进入部署工作流。但是如果它们是分开的，那么就不可能保持两者之间的强连接(例如，用相同的提交号启动两者)，甚至可能会出现同步问题(或人为错误)。</p><p id="632a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">2.经过调查，默认的github动作不允许您从其他工作流下载工件。</p><p id="e6e4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然而，我发现这个动作<a class="ae lv" href="https://github.com/dawidd6/action-download-artifact" rel="noopener ugc nofollow" target="_blank">https://github.com/dawidd6/action-download-artifact</a>似乎解决了这个问题，然而，困难的部分仍然是如何将工件从构建到部署没有错误。</p><p id="317b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我试图生成一个<code class="du ka kb kc kd b">result.json</code>文件，并将其作为构建工作流工件上传。然后，在我的部署工作流中，使用这个定制操作，连接到构建工作流以获取工件，读取它，等等。然而，这导致了一个先有鸡还是先有蛋的问题，因为构建工作流的运行标识符在工件中，而我不能到达工件，因为我没有运行标识符。</p><figure class="kf kg kh ki fd hk er es paragraph-image"><div class="er es ml"><img src="../Images/fdb7c98de3d21aba87c897f23006216e.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/0*tylT6xDKt4_Ym940.jpg"/></div></figure><p id="57ce" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">3.很明显，正确的方法是让一个工作流包含三个任务(相互依赖)，这样可以很容易地共享同一个工件，避免阶段之间的任何不同步。但是，由于我们缺少团队层中的环境批准检查，似乎没有其他方法可以做到这一点(如果我们尝试使用手动批准来执行我们当前的工作流)。</p><p id="1a6e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">另一方面，GitHub Actions确实存在其他问题:</p><ul class=""><li id="a6f1" class="lw lx hx iw b ix iy jb jc jf ly jj lz jn ma jr mm mc md me bi translated">工作流文件必须位于。github/workflows文件夹。虽然这只是一个习惯的问题，但当你有一个monorepo时，这是一种处理工作流的更混乱的方式。正确的做法应该是每个应用程序在自己的文件夹结构中有自己的工作流文件。</li><li id="e134" class="lw lx hx iw b ix mf jb mg jf mh jj mi jn mj jr mm mc md me bi translated">尽管Marketplace确实有许多可以使用的操作，但许多人只是觉得脱节或不够健壮。在Azure Pipelines的例子中，有更多的官方行动随之而来，你知道它们只是工作。</li><li id="76af" class="lw lx hx iw b ix mf jb mg jf mh jj mi jn mj jr mm mc md me bi translated">在AP中，你可以链接变量。虽然这不是一个主要问题，但它确实可以让你的脚本更整洁。所以你可以这样做:</li></ul><pre class="kf kg kh ki fd lm kd ln lo aw lp bi"><span id="0299" class="lq kk hx kd b fi lr ls l lt lu">variables:<br/>  myvar: ABC<br/>  myvar2: $(myvar)DEF</span></pre><ul class=""><li id="ad59" class="lw lx hx iw b ix iy jb jc jf ly jj lz jn ma jr mm mc md me bi translated">对于组织机密，首先你没有他们在自由层，所以你必须升级到团队层。第二，秘密不能用列表来组织。在我的例子中，我有一个“staging variables”列表，和一个镜像的“production variables”列表(具有相同的名称，但是不同的值)，所以这将允许我的脚本有一个单独的流。这在GitHub中是不可能的，所以当你有很多秘密的时候(甚至对于N个环境来说)，管理它们是非常困难的。</li><li id="4a7b" class="lw lx hx iw b ix mf jb mg jf mh jj mi jn mj jr mm mc md me bi translated">令人费解的是，要运行手动工作流，必须(手动)设置触发器<code class="du ka kb kc kd b">workflow_dispatch</code>。这对于任何工作流都应该是开放的。很多时候，您确实需要按需运行它。</li></ul><p id="792d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy">总结</strong></p><p id="d07b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是我最失望的地方。我认为GHA是一个更加强大和成熟的产品。</p><p id="0dd9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">优点:yaml语法短，执行速度非常快</p><p id="5329" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">缺点:没有秘密列表，默认情况下没有手动工作流，工作流文件位置，没有变量链接，尤其是没有对环境的批准检查。</p><h1 id="c7f3" class="kj kk hx bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">更新:Azure Repos vs GitHub</h1><p id="967b" class="pw-post-body-paragraph iu iv hx iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr hb bi translated">在这一部分，GitHub应该统治Azure Repos。但并没有我想象的那么势不可挡。在这几天里，我在GH中看到了一些更好的功能，但其他功能在AR中更好。</p><ul class=""><li id="91b2" class="lw lx hx iw b ix iy jb jc jf ly jj lz jn ma jr mm mc md me bi translated">在GH中，克隆、推送、导航、编辑网页的速度更快。</li><li id="6eaa" class="lw lx hx iw b ix mf jb mg jf mh jj mi jn mj jr mm mc md me bi translated">在AR中，代码审查体验要好得多。你得到的文件夹将文件分组，这样可以更快地导航。</li><li id="8c8b" class="lw lx hx iw b ix mf jb mg jf mh jj mi jn mj jr mm mc md me bi translated">AR比较算法看起来也更好，更精细。GH的粒度更粗。</li><li id="b3bb" class="lw lx hx iw b ix mf jb mg jf mh jj mi jn mj jr mm mc md me bi translated">在AR中，我可以按组织(或项目)设置分支保护，但在GH中，只能在回购级别设置。当你有5个回复的时候，就可以了。但当你有90个回购时，那就太多了，再加上新的回购也需要手动配置。</li></ul><h1 id="65f1" class="kj kk hx bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">结论</h1><p id="f7d2" class="pw-post-body-paragraph iu iv hx iw b ix lh iz ja jb li jd je jf lj jh ji jj lk jl jm jn ll jp jq jr hb bi translated">作为GitHub，也许是世界上最大的代码库，它的GitHub Actions产品看起来还很不成熟，这很令人失望。在MS收购GitHub的某个时候，我开玩笑说，那时AzureDevops可能会消失，让GH成为唯一的产品，但现在我甚至认为相反(至少在Actions方面)。</p><p id="ad2b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我还注意到的一件事是，GitHub在设计时考虑了单个存储库，或者每个用户/组织可能有一堆存储库。许多东西在存储库级别运行(GITHUB_TOKEN、GitHub Packages Docker、Branch Policies等),很少有repo是可以的，但是当您有90个repo时，在所有repo中应用策略，或者以标准化的方式配置它们是非常麻烦的。</p><p id="f8cf" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有许多事情让我怀疑GitHub对公司工作流的能力(许多存储库，暂停的管道)。随着我对这篇文章的使用越来越多，我会尽量更新它。</p></div></div>    
</body>
</html>