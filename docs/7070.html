<html>
<head>
<title>GRPC Basics &amp; Integration Step by Step</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GRPC 基础&amp;逐步整合</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/grpc-basics-integration-step-by-step-a63a4aab5ba0?source=collection_archive---------3-----------------------#2022-07-15">https://medium.com/nerd-for-tech/grpc-basics-integration-step-by-step-a63a4aab5ba0?source=collection_archive---------3-----------------------#2022-07-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="cf18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，您将了解 GRPC 的基础知识，并概述如何使用它来设置客户端/服务器微服务。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/89a1c3e3c8dcb93668023fb754b2110a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/0*OhqRsVej30htIkDL.png"/></div></figure><h2 id="029d" class="jl jm hi bd jn jo jp jq jr js jt ju jv iq jw jx jy iu jz ka kb iy kc kd ke kf bi translated">什么是 GRPC？</h2><p id="fa34" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">当使用微服务时，有许多事情需要担心，例如数据的类型和大小、端点结构、响应的延迟…这可能会使开发 API 变得更加困难，但在它的核心，我们想要做的是发送请求并获得响应。因此，我们有远程过程调用(RPC)。使用 RPC，您基本上是从服务器调用一个方法来获得结果，而不必处理端点、数据类型和大小等。服务器处理所有这些&amp;给你你所需要的。</p><p id="110c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以这样想:你正在给你的母亲发一封电子邮件，让她给你烤些饼干，然后寄回给你。这是 RPC 的核心。由于你母亲不会为除家人以外的任何人烤饼干，我们必须配置身份验证，以便能够向服务器发送请求。</p><p id="d9b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">gRPC 是 Google 远程过程调用的简称，是 Google 的一个开源 RPC 框架。</p><h2 id="8fe0" class="jl jm hi bd jn jo jp jq jr js jt ju jv iq jw jx jy iu jz ka kb iy kc kd ke kf bi translated">入门指南</h2><p id="6bea" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">谷歌有一套叫做<strong class="ih hj">协议缓冲区</strong>的工具。他们所做的基本上是获取数据，将其序列化为二进制，然后将其转换为任何需要的格式。如果你不熟悉协议缓冲区，我建议你先阅读<a class="ae kl" rel="noopener" href="/@gamzeyilan1/protocol-buffers-in-two-minutes-6b8f908efe5">这篇两分钟的简化文章</a>。</p><p id="456d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了使用 gRPC，我们需要用一个. proto 文件来定义使用上述协议缓冲区的消息和服务。剩下的代码将自动生成，从那时起我们要做的就是实现它。</p><p id="9a22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用 gRPC 的好处可以总结为:</p><ul class=""><li id="b5b0" class="km kn hi ih b ii ij im in iq ko iu kp iy kq jc kr ks kt ku bi translated">与 Apache Kafka 和 Redis 等其他消息代理不同，gRPC 提供了类型安全。也就是说，如果你以 JavaScript 对象的形式请求响应，那么它会返回一个 JavaScript 对象给你，谢谢你的协议缓冲区，如果你向你妈妈要巧克力饼干，她会给你烤巧克力饼干，而不是香草饼干。</li><li id="8814" class="km kn hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated">由于 gRPC 将数据转换为二进制并以这种方式传输，因此它提供了更快的传输速度。</li><li id="f34d" class="km kn hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated">客户端代码是自动生成的，可用于大多数语言。</li><li id="d81b" class="km kn hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated">使大量微服务之间的通信变得更加容易，并通过智能感知获得功能。</li></ul><h2 id="c3af" class="jl jm hi bd jn jo jp jq jr js jt ju jv iq jw jx jy iu jz ka kb iy kc kd ke kf bi translated">使用 gRPC</h2><p id="6a8c" class="pw-post-body-paragraph if ig hi ih b ii kg ik il im kh io ip iq ki is it iu kj iw ix iy kk ja jb jc hb bi translated">我们现在可以开始实际使用 gRPC 了，出于本教程的目的，我将向您展示如何在两个 NestJs 微服务上实现 gRPC。</p><p id="7d6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于将作为服务器工作的每个微服务，您可以重复以下步骤:</p><ul class=""><li id="321f" class="km kn hi ih b ii ij im in iq ko iu kp iy kq jc kr ks kt ku bi translated">在我们开始之前，将@grpc/proto-loader 安装到您的项目中。对于 node 你可以使用<a class="ae kl" href="https://www.npmjs.com/package/@grpc/proto-loader" rel="noopener ugc nofollow" target="_blank">这个链接</a>来看看如何安装。</li><li id="518f" class="km kn hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated">转到您的 main.ts 文件(或基于您的语言，以该文件为基础)并从<strong class="ih hj">“路径”</strong>导入<strong class="ih hj">join</strong>；</li></ul><pre class="je jf jg jh fd la lb lc ld aw le bi"><span id="02e7" class="jl jm hi lb b fi lf lg l lh li">import { join } from 'path';</span></pre><ul class=""><li id="5b06" class="km kn hi ih b ii ij im in iq ko iu kp iy kq jc kr ks kt ku bi translated">转到 createMicroservice 函数的等效函数，并将 transport 设置为 gRPC as</li></ul><pre class="je jf jg jh fd la lb lc ld aw le bi"><span id="4d81" class="jl jm hi lb b fi lf lg l lh li">transport: Transport.<em class="lj">GRPC</em>,</span></pre><ul class=""><li id="6e68" class="km kn hi ih b ii ij im in iq ko iu kp iy kq jc kr ks kt ku bi translated">此时，我们将利用前面提到的协议缓冲区。如果还没有，请创建。原型文件。原型文件基本上是一个简单的类型定义文件，你可以通过点击<a class="ae kl" rel="noopener" href="/nerd-for-tech/protocol-buffers-in-two-minutes-6b8f908efe5">这里</a>学习如何在两分钟内创建一个。</li><li id="40a7" class="km kn hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated">添加您的。原始文件作为原始路径；</li></ul><pre class="je jf jg jh fd la lb lc ld aw le bi"><span id="ec78" class="jl jm hi lb b fi lf lg l lh li">protoPath: join(__dirname, '../src/protoFileName.proto');</span></pre><ul class=""><li id="f94b" class="km kn hi ih b ii ij im in iq ko iu kp iy kq jc kr ks kt ku bi translated">下一步是修改我们的控制器。基本上，转到主控制器(NestJs 中的 app.controller ),在构造函数中创建下面的方法，将 proto 文件映射到控制器:</li></ul><pre class="je jf jg jh fd la lb lc ld aw le bi"><span id="c324" class="jl jm hi lb b fi lf lg l lh li">@GrpcMethod();</span></pre><ul class=""><li id="6619" class="km kn hi ih b ii ij im in iq ko iu kp iy kq jc kr ks kt ku bi translated">从这一点开始，确保您的微服务中的所有对象模型都以正确的格式存储在 proto 文件中，并在每个控制器中使用，以便 gRPC 可以实际确认它进行转换和传输。</li></ul><p id="e907" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，为了创建将作为订阅者工作的微服务，我们必须做一些更改:</p><ul class=""><li id="62f6" class="km kn hi ih b ii ij im in iq ko iu kp iy kq jc kr ks kt ku bi translated">如果您已经有了一些基于消息的协议，现在您可以从您的项目中删除它们，因为您不再需要它们了。</li><li id="b333" class="km kn hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated">执行我们为服务微服务执行的步骤，包括为订阅微服务安装原型加载器。proto 文件和 transport &amp; protoPath 也应该与服务文件完全相同。</li><li id="207d" class="km kn hi ih b ii kv im kw iq kx iu ky iy kz jc kr ks kt ku bi translated">在项目文件夹下，创建一个 gRPC 接口文件(对于 NestJs，应该是 grpc.interface.ts)。在中，为包含方法的 gRPC 服务创建一个接口，为来自原型文件的对象创建接口，如下所示:</li></ul><blockquote class="lk ll lm"><p id="ca45" class="if ig lj ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">导出接口 IGrpcService{</p><p id="e150" class="if ig lj ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">function name(object name:object name):可观察的<any>；} //objectName 应该是该方法采用的任何对象</any></p><p id="504e" class="if ig lj ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">接口对象名称{</p><p id="b6b2" class="if ig lj ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi">… };</p></blockquote><ul class=""><li id="c37d" class="km kn hi ih b ii ij im in iq ko iu kp iy kq jc kr ks kt ku bi translated">转到您的主控制器，不像我们在服务微服务中那样实现 Grpc 方法，而是添加 ClientGrpc 和 IGrpcService，如下所示:</li></ul><blockquote class="lk ll lm"><p id="ee4f" class="if ig lj ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">从“”导入{IGrpcService}。/grpc . interface '；</p><p id="985a" class="if ig lj ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">从“@nestjs/microservices”导入{Client，ClientGrpc }；</p><p id="01b6" class="if ig lj ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">@客户端(微服务选项)；</p><p id="9429" class="if ig lj ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">私人客户 ClientGrpc。</p><p id="c1cc" class="if ig lj ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">private grpcService:IGrpcService；</p></blockquote><ul class=""><li id="6c75" class="km kn hi ih b ii ij im in iq ko iu kp iy kq jc kr ks kt ku bi translated">在同一个控制器中，在构造函数(或 ngOninit、OnModuleInit，无论您喜欢什么)内部，将 grpc 服务初始化为:</li></ul><blockquote class="lk ll lm"><p id="c722" class="if ig lj ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">构造函数(){</p><p id="67b5" class="if ig lj ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">this . grpcservice = this . client . getservice<igrpcservice>(' service name ')；}</igrpcservice></p></blockquote><p id="ef23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们完事了。现在，您可以像这样使用 grpc 服务中的函数和数据对象:</p><blockquote class="lk ll lm"><p id="90ad" class="if ig lj ih b ii ij ik il im in io ip ln ir is it lo iv iw ix lp iz ja jb jc hb bi translated">this . grpcservice . function name()；</p></blockquote></div></div>    
</body>
</html>