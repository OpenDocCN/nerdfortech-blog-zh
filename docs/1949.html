<html>
<head>
<title>MVVM+Coordinators IOS Architecture Tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MVVM+协调员IOS架构教程</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/mvvm-coordinators-ios-architecture-tutorial-fb27eaa36470?source=collection_archive---------0-----------------------#2021-04-14">https://medium.com/nerd-for-tech/mvvm-coordinators-ios-architecture-tutorial-fb27eaa36470?source=collection_archive---------0-----------------------#2021-04-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="aa08" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">为初学者创建一个简单的MVVM-C iOS架构</h2></div><h1 id="1de9" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">介绍</h1><p id="fe64" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">在这篇文章中，我想分享我在项目和工作中使用的架构。这篇文章也将作为我自己的文档，这样我就知道我对这个架构了解了多少。</p><p id="d5d7" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">我将首先解释什么是MVVM和协调器，以及如何实现它的一些片段。</p><p id="5e2b" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">很抱歉我糟糕的英语语法，因为这是我的第一篇文章😅😅。如果有我可以改进的地方，或者有任何更正，请随时纠正我！作为一名开发人员是一个漫长的学习过程，对吗？😁</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es kq"><img src="../Images/b81c4573a0dc9af7da3f6f7a608607d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tEiWbOjwfz4KBls6"/></div></div><figcaption class="lc ld et er es le lf bd b be z dx translated">波格丹一世·卡伦科在<a class="ae lg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="29df" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">MVVM</h1><p id="0663" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">模型-视图-视图模型或MVVM架构在IOS开发中非常流行。它已经在工业中使用了一段时间。随着Swift UI (Declarative UI)的出现，这种架构将成为该行业IOS开发者的必备。</p><p id="8c2d" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">MVVM在划分业务和UI逻辑方面做得很好。它解决了巨大的视图控制器问题。如果你有使用MVC的经验。但是，您可以通过将<strong class="jr hj">导航</strong>代码分离到其他文件来进一步缩小视图控制器。我所指的导航代码是:</p><pre class="kr ks kt ku fd lh li lj lk aw ll bi"><span id="5c5b" class="lm iy hi li b fi ln lo l lp lq">navigationController?.pushViewController(vc, animated: true)<br/>navigationController?.presentViewController(vc, animated: true)</span></pre><p id="4326" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">但是为什么呢？它只包含1-2行代码，当然没关系，对吗？</p><p id="c479" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">它可能不会有助于划分视图控制器。但是这违背了<strong class="jr hj">固原则</strong>尤其是<strong class="jr hj">单责任。如果你想了解固体，这里有一篇带插图的好文章<a class="ae lg" rel="noopener" href="/backticks-tildes/the-s-o-l-i-d-principles-in-pictures-b34ce2f1e898"/>。如果你知道这些原则，这真的是一个优势，它会在你编码的时候拯救你的许多战友😆😆。</strong></p><div class="lr ls ez fb lt lu"><a rel="noopener follow" target="_blank" href="/backticks-tildes/the-s-o-l-i-d-principles-in-pictures-b34ce2f1e898"><div class="lv ab dw"><div class="lw ab lx cl cj ly"><h2 class="bd hj fi z dy lz ea eb ma ed ef hh bi translated">照片中的神盾局原则</h2><div class="mb l"><h3 class="bd b fi z dy lz ea eb ma ed ef dx translated">如果你熟悉面向对象编程，那么你可能听说过坚实的原则。</h3></div><div class="mc l"><p class="bd b fp z dy lz ea eb ma ed ef dx translated">medium.com</p></div></div><div class="md l"><div class="me l mf mg mh md mi la lu"/></div></div></a></div><p id="2e42" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">那么，我们把导航相关的代码放在哪里呢？是的，<strong class="jr hj">协调人</strong>。</p></div><div class="ab cl mj mk gp ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hb hc hd he hf"><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es mq"><img src="../Images/c528597407e3f707fec571d20e69dede.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K_C0FEhzW5_dLrWa"/></div></div><figcaption class="lc ld et er es le lf bd b be z dx translated">照片由<a class="ae lg" href="https://unsplash.com/@bdchu614?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布伦丹·丘奇</a>在<a class="ae lg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="f255" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">协调者</h1><p id="1536" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">就我使用协调员而言，我会将协调员视为旅行向导。他们知道去哪里，知道T2需要什么。如果你想洗澡，他们知道你必须去一个叫<strong class="jr hj">浴室</strong>的地方，他们会为你提供<strong class="jr hj">毛巾、肥皂或洗发水</strong>。</p><p id="6008" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">在我的情况下，协调员的工作是创建所有需要的依赖关系。例如，它创建了<strong class="jr hj">视图控制器</strong>和<strong class="jr hj">视图模型</strong>。协调器<strong class="jr hj">将视图模型传递</strong>到视图控制器。协调者还负责实例化一个API服务，或任何其他服务，并根据需要将它注入视图模型或视图控制器。</p><p id="e9f4" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated"><strong class="jr hj">短插画</strong>:你(ViewController)要去上学，你妈妈(Coordinator)叫醒你(init ViewController)，准备你的午餐(dependencies/services)把你的作业(dependencies/services)放在你的背包里(viewModel)。她把背包(viewModel)放在你的背上。送你去上学。</p><p id="f452" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">在Swift中，像这样:</p><pre class="kr ks kt ku fd lh li lj lk aw ll bi"><span id="db39" class="lm iy hi li b fi ln lo l lp lq"><strong class="li hj">func</strong> goToLogin() {<br/>    <strong class="li hj">let</strong> vc = LoginViewController.instantiate(from: authStoryboard)<br/>    <strong class="li hj">let</strong> vm = LoginViewModel()<br/>    vm.apiClient = authApi<br/>    vm.authCoordinator = <strong class="li hj">self<br/>    </strong>vc.viewModel = vm<br/>    navigationController.setViewControllers([vc], animated: <strong class="li hj">true</strong>)<br/>}</span></pre><p id="13f8" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">我已经解释了使用协调器的概念。但是如何创建一个并实现到项目中呢？</p></div><div class="ab cl mj mk gp ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hb hc hd he hf"><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es mr"><img src="../Images/b44c4cb3df6a3198c9ede8e451b1a2b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kyqsfHIoMwEICsxSkVPm1w.png"/></div></div><figcaption class="lc ld et er es le lf bd b be z dx translated">MVVM + C架构，作者:<a class="ae lg" rel="noopener" href="/@danlozanov?source=post_page-----815204248518--------------------------------">丹尼尔·洛萨诺·巴尔德斯</a>。看看他的博客。他对这个架构有很深很全面的教程，我按照他的指导学过一次！很有帮助！</figcaption></figure><div class="lr ls ez fb lt lu"><a rel="noopener follow" target="_blank" href="/sudo-by-icalia-labs/ios-architecture-mvvm-c-introduction-1-6-815204248518"><div class="lv ab dw"><div class="lw ab lx cl cj ly"><h2 class="bd hj fi z dy lz ea eb ma ed ef hh bi translated">iOS架构:MVVM-C，简介(1/6)</h2><div class="mb l"><h3 class="bd b fi z dy lz ea eb ma ed ef dx translated">介绍</h3></div><div class="mc l"><p class="bd b fp z dy lz ea eb ma ed ef dx translated">(1/6)Introductionmedium.com</p></div></div><div class="md l"><div class="ms l mf mg mh md mi la lu"/></div></div></a></div><h1 id="8b7a" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">履行</h1><h2 id="2afa" class="lm iy hi bd iz mt mu mv jd mw mx my jh jy mz na jj kc nb nc jl kg nd ne jn nf bi translated">步骤1:建立协调者基础</h2><p id="2106" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">创建一个ios应用xcode项目后，让我们创建一个<strong class="jr hj">应用协调器</strong>。这将是以后你的应用程序的重要组成部分。</p><pre class="kr ks kt ku fd lh li lj lk aw ll bi"><span id="eacd" class="lm iy hi li b fi ln lo l lp lq"><strong class="li hj">protocol</strong> Coordinator {</span><span id="6e58" class="lm iy hi li b fi ng lo l lp lq">    <strong class="li hj">var</strong> parentCoordinator: Coordinator? { <strong class="li hj">get</strong> <strong class="li hj">set</strong> }<br/>    <strong class="li hj">var</strong> children: [Coordinator] { <strong class="li hj">get</strong> <strong class="li hj">set</strong> }<br/>    <strong class="li hj">var</strong> navigationController : UINavigationController { <strong class="li hj">get</strong> <strong class="li hj">set</strong> }<br/>    <br/>    <strong class="li hj">func</strong> start()<br/>}</span></pre><p id="46a3" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">您可以随意使用<strong class="jr hj">类</strong>或<strong class="jr hj">协议</strong>。它将作为应用程序中每个协调者的基础模板。</p><p id="224a" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">然后让我们创建<strong class="jr hj"> AppCoordinator </strong>。</p><pre class="kr ks kt ku fd lh li lj lk aw ll bi"><span id="82a0" class="lm iy hi li b fi ln lo l lp lq"><strong class="li hj">class</strong> AppCoordinator: Coordinator {<br/>    <strong class="li hj">var</strong> parentCoordinator: Coordinator?<br/>    <strong class="li hj">var</strong> children: [Coordinator] = []<br/>    <strong class="li hj">var</strong> navigationController: UINavigationController</span><span id="9a64" class="lm iy hi li b fi ng lo l lp lq"><strong class="li hj">    init</strong>(navCon : UINavigationController) {<br/>        <strong class="li hj">self</strong>.navigationController = navCon<br/>    }</span><span id="f222" class="lm iy hi li b fi ng lo l lp lq"><strong class="li hj">    func</strong> start() {<br/>        print("App Coordinator Start")<br/>    }</span><span id="58ce" class="lm iy hi li b fi ng lo l lp lq">}</span></pre><p id="b74c" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated"><strong class="jr hj">开始</strong>()？开始将包含应用程序中的第一个操作或流程。我们稍后将回到它。</p><h2 id="4249" class="lm iy hi bd iz mt mu mv jd mw mx my jh jy mz na jj kc nb nc jl kg nd ne jn nf bi translated">步骤2:删除SceneDelegate并设置AppDelegate。</h2><p id="1803" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">转到<strong class="jr hj"> AppDelegate </strong>并创建自己的<strong class="jr hj">窗口。</strong>为什么？<strong class="jr hj"> AppCoordinator </strong>需要作为您的应用程序的全局协调器父级，因此我们需要与AppCoordinator <strong class="jr hj">一起启动应用程序</strong>。为此，我们必须通过持有自己的窗口来“定制”应用程序本身的初始化。至于IOS 13，有<strong class="jr hj">场景代表</strong>有我们的窗口变量。</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es nh"><img src="../Images/c8aab569aa9db718cf5b45ed275b1bbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bm4ZuI_E4SbmzzwYgBlGDw.png"/></div></div><figcaption class="lc ld et er es le lf bd b be z dx translated">SceneDelegate.swift，是苹果从IOS 13开始添加的，支持Swift UI。</figcaption></figure><p id="0e34" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">让<strong class="jr hj">删除SceneDelegate </strong>并<strong class="jr hj">创建我们自己的窗口变量。</strong>也别忘了去掉<code class="du ni nj nk li b">info.plist</code>中的<code class="du ni nj nk li b">ApplicationSceneManifest</code>。我还将我的IOS开发目标<strong class="jr hj">设定为12.0，这样它就可以支持更早的iOS。</strong></p><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es nl"><img src="../Images/ae4fe5bb4e453d33bd95746d3dd4a302.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uIlQqnrW4WQpwsbZ4kZdZw.png"/></div></div><figcaption class="lc ld et er es le lf bd b be z dx translated">AppDelegate.swift，如果你的目标是早于iOS 13的开发，我建议你删除所有与场景相关的功能，因为这将导致早期设备的问题。(如果可以的话，你可以使用。)</figcaption></figure><p id="1c2c" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">然后在<code class="du ni nj nk li b">didFinishLaunchingWithOptions</code>里面让我们创建我们的窗口和AppCoordinator！</p><pre class="kr ks kt ku fd lh li lj lk aw ll bi"><span id="5866" class="lm iy hi li b fi ln lo l lp lq"><strong class="li hj">class</strong> AppDelegate: UIResponder, UIApplicationDelegate {<br/>    <strong class="li hj">var</strong> window: UIWindow?<br/>    <strong class="li hj">var</strong> appCoordinator : AppCoordinator?</span><span id="e008" class="lm iy hi li b fi ng lo l lp lq"><strong class="li hj">     func</strong> application(<strong class="li hj">_</strong> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: <strong class="li hj">Any</strong>]?) -&gt; Bool {<br/>        // Override point for customization after application launch.<br/>         window = UIWindow(frame: UIScreen.main.bounds)</span><span id="0324" class="lm iy hi li b fi ng lo l lp lq"><strong class="li hj">         let</strong> navigationCon = UINavigationController.init()<br/>         appCoordinator = AppCoordinator(navigationController: navigationCon)<br/>         appCoordinator!.start()</span><span id="a2ba" class="lm iy hi li b fi ng lo l lp lq">         window!.rootViewController = navigationCon<br/>         window!.makeKeyAndVisible()<br/>         <strong class="li hj">return</strong> <strong class="li hj">true<br/>     </strong>}<br/>}</span></pre><p id="075d" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">当你运行它的时候，它会产生这个。</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div class="er es nm"><img src="../Images/640650467a27d81df39f172181b5e99d.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*Th4QDDfVF2FREde-GqnAHA.png"/></div></figure><p id="d579" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">一个空的<code class="du ni nj nk li b">UINavigationController</code>，你应该会看到<code class="du ni nj nk li b">Start The App!</code>印在控制台上。这意味着，您的应用程序现在开始与AppCoordinator！</p><h2 id="e765" class="lm iy hi bd iz mt mu mv jd mw mx my jh jy mz na jj kc nb nc jl kg nd ne jn nf bi translated">步骤3:协调员的工具</h2><p id="1b7d" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">如你所见。空的。您仍然拥有设置了initialViewControllers的<code class="du ni nj nk li b">Main.storyboard</code>。但是为什么不管用呢？因为我们给了<strong class="jr hj">窗口一个值</strong>。在这里阅读<a class="ae lg" href="https://stackoverflow.com/questions/16445709/in-an-appdelegate-how-is-the-main-uiwindow-instantiated" rel="noopener ugc nofollow" target="_blank">你想知道AppDelegate是如何工作的。</a></p></div><div class="ab cl mj mk gp ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hb hc hd he hf"><h2 id="97af" class="lm iy hi bd iz mt mu mv jd mw mx my jh jy mz na jj kc nb nc jl kg nd ne jn nf bi translated">关于故事板</h2><p id="2000" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">如果您使用协调器和故事板，那么就不再使用片段和初始视图控制器，因为协调器是负责在VC之间导航和传输数据的人。在我看来，当我使用协调者时，我将<strong class="jr hj">故事板视为许多风投</strong>的容器。它只对<strong class="jr hj">分组视图控制器</strong>和自动布局有帮助。<strong class="jr hj">该架构中未使用连接或分段，因为该角色属于协调者</strong>。</p><p id="d5b3" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">我真的建议在大型项目中使用许多故事板。它帮助你的团队查看控制器，并使我们的项目结构更整洁！如果你想让我分享这一点，请随意评论！😁😁</p><p id="3fbd" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">现在，只要你在你的<code class="du ni nj nk li b">Main.storyboards</code>上设置了<code class="du ni nj nk li b">Main Interface</code>(通用- &gt;部署信息)，它仍然可以正常工作。</p></div><div class="ab cl mj mk gp ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hb hc hd he hf"><p id="939a" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">让我们给我们的<code class="du ni nj nk li b">AppCoordinator</code>增加一些功能。</p><pre class="kr ks kt ku fd lh li lj lk aw ll bi"><span id="16c8" class="lm iy hi li b fi ln lo l lp lq"><strong class="li hj">class</strong> AppCoordinator : Coordinator {</span><span id="d391" class="lm iy hi li b fi ng lo l lp lq">    <strong class="li hj">var</strong> parentCoordinator: Coordinator?<br/>    <strong class="li hj">var</strong> children: [Coordinator] = []<br/>    <strong class="li hj">var</strong> navigationController: UINavigationController</span><span id="074e" class="lm iy hi li b fi ng lo l lp lq">    <strong class="li hj">init</strong>(navigationController : UINavigationController) {<br/>        <strong class="li hj">self</strong>.navigationController = navigationController<br/>    }</span><span id="0d2d" class="lm iy hi li b fi ng lo l lp lq"><strong class="li hj">    func</strong> start() {<br/>         // The first time this coordinator started, is to launch login page.<br/>    goToLoginPage()<br/>    }<br/>    <br/>    <strong class="li hj">let</strong> storyboard = UIStoryboard.init(name: "Main", bundle: .main)</span><span id="43f5" class="lm iy hi li b fi ng lo l lp lq"><strong class="li hj">    func</strong> goToLoginPage(){</span><span id="cda2" class="lm iy hi li b fi ng lo l lp lq">         // Instantiate LoginViewController<br/>         <strong class="li hj">let</strong> loginViewController = storyboard.instantiateViewController(withIdentifier: "LoginViewController") <strong class="li hj">as</strong>! LoginViewController</span><span id="6f8b" class="lm iy hi li b fi ng lo l lp lq">         // Instantiate LoginViewModel<br/>         <strong class="li hj">let</strong> loginViewModel = LoginViewModel.init()</span><span id="822a" class="lm iy hi li b fi ng lo l lp lq">         // Set the Coordinator to the ViewModel<br/>         loginViewModel.appCoordinator = <strong class="li hj">self</strong></span><span id="9f4f" class="lm iy hi li b fi ng lo l lp lq">         // Set the ViewModel to ViewController        <br/>         loginViewController.viewModel = loginViewModel</span><span id="7941" class="lm iy hi li b fi ng lo l lp lq">         // Push it.<br/>        navigationController.pushViewController(loginViewController, animated: <strong class="li hj">true</strong>)</span><span id="627d" class="lm iy hi li b fi ng lo l lp lq">    }</span><span id="0a47" class="lm iy hi li b fi ng lo l lp lq"><strong class="li hj">    func</strong> goToRegisterPage(){<br/>        <strong class="li hj">let</strong> registerViewController = storyboard.instantiateViewController(withIdentifier: "RegisterViewController") <strong class="li hj">as</strong>! RegisterViewController<br/>        <strong class="li hj">let</strong> registerViewModel = RegisterViewModel.init()<br/>        registerViewModel.appCoordinator = <strong class="li hj">self<br/>        </strong>registerViewController.viewModel = registerViewModel<br/>         navigationController.pushViewController(registerViewController, animated: <strong class="li hj">true</strong>)<br/>    }</span><span id="4915" class="lm iy hi li b fi ng lo l lp lq">}</span></pre><p id="84e4" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">如您所见，这些函数的目的仅在于使用UINavigationController进行注入和导航。它包括ApiServices，甚至是作用于2个以上ViewControllers的ViewModels。要传递数据，你只需<strong class="jr hj">将参数</strong>添加到函数中，并将其注入下一个VC或VM。</p><h2 id="bd39" class="lm iy hi bd iz mt mu mv jd mw mx my jh jy mz na jj kc nb nc jl kg nd ne jn nf bi translated">步骤4:用视图模型显示UIViewControllers</h2><p id="4504" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">我已经创建了2个非常简单的ViewControllers，并将其作为IBOutlet连接到我们的故事板。</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es nn"><img src="../Images/af98c3ac678b7ae2ffe5791813cdd6c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pw6kYmTVcZXu7GwlVlTNLw.png"/></div></div><figcaption class="lc ld et er es le lf bd b be z dx translated">LoginViewController和RegisterViewController</figcaption></figure><p id="e3ac" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">让我们为每个视图控制器创建视图模型。这里的LoginViewModel只包含一个要求协调者转到注册页面的函数。它与RegisterViewModel相同。</p><pre class="kr ks kt ku fd lh li lj lk aw ll bi"><span id="1e41" class="lm iy hi li b fi ln lo l lp lq"><strong class="li hj">import</strong> Foundation<br/><strong class="li hj">class</strong> LoginViewModel {<br/>    <strong class="li hj">weak</strong> <strong class="li hj">var</strong> coordinator : AppCoordinator!<br/>    <br/>    <strong class="li hj">func</strong> goToRegister(){<br/>        coordinator.goToRegisterPage()<br/>    }<br/>}</span><span id="9466" class="lm iy hi li b fi ng lo l lp lq"><strong class="li hj">class</strong> RegisterViewModel {<br/>    <strong class="li hj">weak</strong> <strong class="li hj">var</strong> appCoordinator : AppCoordinator!<br/>    <strong class="li hj">func</strong> goToLogin(){<br/>        appCoordinator.goToLoginPage()<br/>    }<br/>}</span></pre><p id="eed9" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">这是两个视图控制器。</p><pre class="kr ks kt ku fd lh li lj lk aw ll bi"><span id="f427" class="lm iy hi li b fi ln lo l lp lq"><strong class="li hj">class</strong> LoginViewController : UIViewController {<br/>    <strong class="li hj">var</strong> viewModel : LoginViewModel!<br/>    <strong class="li hj">@IBOutlet</strong> <strong class="li hj">weak</strong> <strong class="li hj">var</strong> registerButton: UIButton!</span><span id="d6e9" class="lm iy hi li b fi ng lo l lp lq"><strong class="li hj">    override</strong> <strong class="li hj">func</strong> viewDidLoad() {<br/>        <strong class="li hj">super</strong>.viewDidLoad()<br/>    }</span><span id="0b1d" class="lm iy hi li b fi ng lo l lp lq"><strong class="li hj">    @IBAction</strong> <strong class="li hj">func</strong> registerButtonTapped(<strong class="li hj">_</strong> sender: <strong class="li hj">Any</strong>) {<br/>        viewModel.goToRegister()<br/>     }<br/>}</span><span id="4fe4" class="lm iy hi li b fi ng lo l lp lq"><strong class="li hj">class</strong> RegisterViewController: UIViewController {<br/>    <strong class="li hj">var</strong> viewModel : RegisterViewModel!<br/>    <strong class="li hj">@IBOutlet</strong> <strong class="li hj">weak</strong> <strong class="li hj">var</strong> backToLoginButton: UIButton!<br/>    <br/>    <strong class="li hj">override</strong> <strong class="li hj">func</strong> viewDidLoad() {<br/>        <strong class="li hj">super</strong>.viewDidLoad()<br/>    }</span><span id="df26" class="lm iy hi li b fi ng lo l lp lq"><strong class="li hj">    @IBAction</strong> <strong class="li hj">func</strong> backToLoginTapped(<strong class="li hj">_</strong> sender: <strong class="li hj">Any</strong>) {<br/>        viewModel.goToLogin()<br/>    }<br/>}</span></pre><p id="1d0f" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">如您所见，现在viewControllers可以专注于视图相关的操作。因为导航过程被转移到协调器。</p><h1 id="0747" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">结果呢</h1><figure class="kr ks kt ku fd kv er es paragraph-image"><div class="er es no"><img src="../Images/a5d211987f096416033d8a323da4a1ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*VEX2ixtA7jCfmubTTxAj0A.gif"/></div><figcaption class="lc ld et er es le lf bd b be z dx translated">简单的协调员应用程序</figcaption></figure><p id="e46e" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">现在，一款可扩展的应用就在您的掌握之中！</p><h1 id="b9f7" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">其他主题</h1><p id="f948" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">所以…如果所有的导航代码都转移到AppCoordinator，AppCoordinator会变成HugeAppCoordinator吗？这取决于你如何使用它。但是没有。</p><p id="24c3" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">协调员可以有许多<strong class="jr hj">子协调员。</strong></p><p id="ab9f" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">儿童协调员帮助分组导航代码。例如，如果您想要捆绑与身份验证相关的页面，您可以创建AuthCoordinator来处理登录、注册、PIN或OTP以及更改PIN。对于HomeCoordinator可能包含一个主页、个人资料页或历史记录页。这取决于你的项目要求和你的管理风格。</p><p id="b73a" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">我将在另一个主题中谈论儿童协调员。但是如果你等不及了，你可以看看我下面列出的参考资料！</p><p id="3508" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">后退按钮和内存管理也是有趣的话题。但这是一个在另一个时间谈论的故事。</p><h1 id="423e" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">推荐参考</h1><ul class=""><li id="0876" class="np nq hi jr b js jt jv jw jy nr kc ns kg nt kk nu nv nw nx bi translated"><strong class="jr hj">立体原理附插图:</strong><a class="ae lg" rel="noopener" href="/backticks-tildes/the-s-o-l-i-d-principles-in-pictures-b34ce2f1e898">https://medium . com/backticks-tildes/the-s-o-l-I-d-Principles-in-pictures-b 34 ce 2 f1 e 898</a></li><li id="687c" class="np nq hi jr b js ny jv nz jy oa kc ob kg oc kk nu nv nw nx bi translated"><strong class="jr hj"> MVVM + C教程:</strong><a class="ae lg" rel="noopener" href="/sudo-by-icalia-labs/ios-architecture-mvvm-c-introduction-1-6-815204248518">https://medium . com/sudo-by-ICA lia-labs/IOs-architecture-mvvm-C-introduction-1-6-815204248518</a></li></ul><p id="f76f" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">我希望这篇文章对你有所帮助，抱歉我的英语语法不好。如果有任何更正或不足之处，我会很高兴地调查它！</p><p id="323c" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">祝大家身体健康，吃好！🍫🍲</p><h1 id="46aa" class="ix iy hi bd iz ja jb jc jd je jf jg jh io ji ip jj ir jk is jl iu jm iv jn jo bi translated">改进和更新</h1><p id="ce35" class="pw-post-body-paragraph jp jq hi jr b js jt ij ju jv jw im jx jy jz ka kb kc kd ke kf kg kh ki kj kk hb bi translated">嘿，好久不见了…我有点忙，度过了艰难的几个月。但不管怎样，我还是设法把项目放到了Github上！下面是查看的链接！。已经有一些变化了，但是概念还是一样的！</p><div class="lr ls ez fb lt lu"><a href="https://github.com/Bobbyphtr/CoordinatorTutorial" rel="noopener  ugc nofollow" target="_blank"><div class="lv ab dw"><div class="lw ab lx cl cj ly"><h2 class="bd hj fi z dy lz ea eb ma ed ef hh bi translated">Bobbyphtr/CoordinatorTutorial</h2><div class="mb l"><h3 class="bd b fi z dy lz ea eb ma ed ef dx translated">在GitHub上创建一个帐户，为Bobbyphtr/CoordinatorTutorial开发做贡献。</h3></div><div class="mc l"><p class="bd b fp z dy lz ea eb ma ed ef dx translated">github.com</p></div></div><div class="md l"><div class="od l mf mg mh md mi la lu"/></div></div></a></div><p id="741c" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">所以我读了Russ Warwick 的一个非常有用的回应，他把所有的哑函数放在一个协议(接口)中，并把它实现给协调器，而不是在视图模型中传递协调器实例。</p><p id="2e19" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">所以我添加了<code class="du ni nj nk li b">LoginNavigation</code>协议。这样，ViewModel对协调器一无所知。这是一种更简洁的编码方式，因此可以很容易地修改协调器。</p><figure class="kr ks kt ku fd kv"><div class="bz dy l di"><div class="og oh l"/></div></figure><figure class="kr ks kt ku fd kv"><div class="bz dy l di"><div class="og oh l"/></div></figure><p id="fc5f" class="pw-post-body-paragraph jp jq hi jr b js kl ij ju jv km im jx jy kn ka kb kc ko ke kf kg kp ki kj kk hb bi translated">请随时纠正我的代码，每一个输入都可以为未来带来更好的代码！</p></div></div>    
</body>
</html>