<html>
<head>
<title>Let’s Sort This Out</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们来解决这个问题</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/lets-sort-this-out-4b15ab49b4f2?source=collection_archive---------7-----------------------#2021-01-29">https://medium.com/nerd-for-tech/lets-sort-this-out-4b15ab49b4f2?source=collection_archive---------7-----------------------#2021-01-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b150" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我关于模拟 JavaScript 面试中向我提出的问题的系列文章的下一部分。</p><p id="6a40" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当被要求对一个数字数组中的元素进行排序时，我首先犯了一个简单使用<em class="jd"> sort() </em>方法的错误。虽然这对于字符串元素来说很好，但是对于数字来说会产生一些奇怪的结果。让我们看看会发生什么。</p><p id="8f9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，一个字符串数组。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="e528" class="jn jo hi jj b fi jp jq l jr js">const anArray = [“today”, “is”, “a”, “whole”, “new”, “beginning”]</span><span id="b61a" class="jn jo hi jj b fi jt jq l jr js">console.log(anArray.sort())</span><span id="cca3" class="jn jo hi jj b fi jt jq l jr js">[“a”, “beginning”, “is”, “new”, “today”, “whole”]</span></pre><p id="9cb7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">数组</em>中的元素根据它们的首字母按字母顺序排序。很简单。如果两个或更多的元素以同一个字母开始，那么排序方法将转到第二个字母，依此类推。例如:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="b3a3" class="jn jo hi jj b fi jp jq l jr js">const newArray = [“cat”, “car”, “bat”, “box”, “doll”, “dill”]</span><span id="75ca" class="jn jo hi jj b fi jt jq l jr js">console.log(newArray.sort())</span><span id="4524" class="jn jo hi jj b fi jt jq l jr js">[“bat”, “box”, “car”, “cat”, “dill”, “doll”]</span></pre><p id="33be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们对一组数字使用<em class="jd"> sort() </em>会怎么样呢？</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="5cb4" class="jn jo hi jj b fi jp jq l jr js">const numArray = [12, 5, 13, 9, 2, 0]</span><span id="313d" class="jn jo hi jj b fi jt jq l jr js">console.log(numArray.sort())</span><span id="8f95" class="jn jo hi jj b fi jt jq l jr js">[0, 12, 13, 2, 5, 9]</span></pre><p id="147e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">坚持住。12 和 13 怎么会先于 2、5 和 9 出现？？？</p><p id="9a92" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">发生这种情况是因为使用<em class="jd"> sort() </em>将数组的元素转换成字符串，然后按 Unicode 顺序排列。</p><p id="2a0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我的面试官给了我一些提示，让我使用一个函数来比较这些数字元素。凭着我的记忆，我在<em class="jd"> sort() </em>的括号内使用了以下内容:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="5053" class="jn jo hi jj b fi jp jq l jr js">function(a, b){return a — b}</span></pre><p id="ad6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们试着用这个排序 numArray。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="9bf3" class="jn jo hi jj b fi jp jq l jr js">console.log(numArray.sort(function(a, b){return a — b}))</span><span id="33cb" class="jn jo hi jj b fi jt jq l jr js">[0, 2, 5, 9, 12, 13]</span></pre><p id="5994" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这还差不多。现在我们将数组的元素按升序排序(即从最小到最大)。如果我们想按降序(从大到小)对它们进行排序呢？我们不是在 return 语句中从<em class="jd"> a </em>中减去<em class="jd"> b </em>，而是从<em class="jd"> b </em>中减去<em class="jd"> a </em>。</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="909d" class="jn jo hi jj b fi jp jq l jr js">console.log(numArray.sort(function(a, b){return b — a}))</span><span id="f487" class="jn jo hi jj b fi jt jq l jr js">[13, 12, 9, 5, 2, 0]</span></pre><p id="1c7e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这一切是如何运作的？compare 函数接受两个值(由参数<em class="jd"> a </em>和<em class="jd"> b </em>表示)，从一个值中减去另一个值，并将一个值返回给 sort 方法。如果<em class="jd">a-b</em>返回负值，那么排序方法将把<em class="jd"> a </em>设置为比<em class="jd"> b </em>更低的数组索引。以我们的<em class="jd"> numArray </em>为例，假设<em class="jd"> a </em>为 2，<em class="jd"> b </em>为 5。compare 函数将获取这两个值并执行一些简单的运算(2–5 =-3 ),然后将结果返回给 sort 方法。sort 方法接收到一个负值，将给予 2 一个低于 5 的索引，因此当数组中的元素按升序排序时，2 将列在 5 之前。</p><p id="4104" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，如果<em class="jd"> a — b </em>返回一个正值呢？在这种情况下，<em class="jd"> a </em>将被分配较高的索引。在我们的<em class="jd"> numArray </em>示例中，当 compare 函数比较 9 和 5(9–5 = 4)时，它将向 sort 方法返回一个正值，这将为 9 分配一个更高的索引。因此，当列出排序后的数组元素时，9 在 5 之后。</p><p id="0366" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当数组元素按降序排序时，这种情况会发生变化。也就是说，如果<em class="jd"> b — a </em>返回负值，<em class="jd"> b </em>被分配较高的索引，如果<em class="jd"> b — a </em>返回正值，<em class="jd"> b </em>被分配较低的索引。例如，如果<em class="jd"> b </em>是 2，而<em class="jd"> a </em>是 5，比较函数将运行其计算(2–5 =-3)，这将提示排序方法给 2 一个比 5 更高的索引。因此，当列出排序后的数字时，5 将出现在 2 之前。</p><p id="e600" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是如果比较函数<em class="jd"> </em>返回 0 呢？让我们用另一组数字来试试:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="8cfe" class="jn jo hi jj b fi jp jq l jr js">const myNumbers = [7, 5, 91, 52, 7, 8]</span><span id="58c6" class="jn jo hi jj b fi jt jq l jr js">console.log(myNumbers.sort(function(a, b){return a — b}))</span><span id="783b" class="jn jo hi jj b fi jt jq l jr js">[5, 7, 7, 8, 52, 91]</span></pre><p id="e7c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该数组包含两个 7，当然，当 compare 函数开始比较它们时，它将返回 0(7–7 = 0)。正如<a class="ae ju" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" rel="noopener ugc nofollow" target="_blank">Mozilla Developer Network</a>所说，这将“使 a 和 b 相对于彼此保持不变，但是相对于所有不同的元素进行排序。”</p><p id="61e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简而言之，我强烈建议将这两个比较函数提交到内存中。</p><ul class=""><li id="57ee" class="jv jw hi ih b ii ij im in iq jx iu jy iy jz jc ka kb kc kd bi translated">按升序排序:function(a，b){ return a-b })</li><li id="6ad3" class="jv jw hi ih b ii ke im kf iq kg iu kh iy ki jc ka kb kc kd bi translated">按降序排序:function(a，b){return b — a})</li></ul><p id="065d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">顺便说一下，这些可以很容易地重写为箭头函数:</p><ul class=""><li id="f163" class="jv jw hi ih b ii ij im in iq jx iu jy iy jz jc ka kb kc kd bi translated">(a，b) =&gt; a — b</li><li id="6218" class="jv jw hi ih b ii ke im kf iq kg iu kh iy ki jc ka kb kc kd bi translated">(a，b) =&gt; b — a</li></ul></div></div>    
</body>
</html>