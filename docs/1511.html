<html>
<head>
<title>Implementing Quicksort in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中实现快速排序</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/implementing-quicksort-in-javascript-1df1d044c744?source=collection_archive---------2-----------------------#2021-03-23">https://medium.com/nerd-for-tech/implementing-quicksort-in-javascript-1df1d044c744?source=collection_archive---------2-----------------------#2021-03-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f08a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇博客中，我们用JavaScript实现了一个<a class="ae jd" href="https://en.wikipedia.org/wiki/Quicksort" rel="noopener ugc nofollow" target="_blank">快速排序</a>。快速排序是一种算法，用于使用分治技术对数组进行排序。首先，我们选择数组的一个枢纽元素，在本例中是中间的元素。接下来，我们交换大于或小于轴心的元素，并生成2个子数组。成功时，右边的子数组只包含大于主元的元素，左边的子数组只包含小于主元的元素。在这一步之后，我们知道pivot元素已经在排序后的数组中找到了它的最终位置。我们递归地重复这个划分过程，直到达到基本情况，其中产生的子数组只包含1个元素，产生一个排序的数组。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/a32f0bf90bae497bcc44dfca62484261.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*FN4OxxaozdCMUmYtgvWRVg.gif"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">可视化快速排序</figcaption></figure><p id="7b71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们进入一些代码，首先我们需要写一个分区函数。这个函数将接受数组以及一个左右元素。在这种情况下，Left和right告诉函数关注数组的哪一部分进行排序。函数如下:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jq"><img src="../Images/92862a444927d711f7adc206ebea2d40.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*D_4Aw50oMLa6eGJJdrdFoQ.png"/></div></figure><p id="08b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们一起浏览这段代码。首先，我们选择枢轴元素作为左右的中点。然后我们指定I和j代表左和右。接下来我们设置一个条件，当下一个代码运行时，I小于或等于j。这确保了当我们增加I时，它总是指示枢轴元素左侧的位置。接下来，我们向上增加I，直到它指向数组中小于轴心的一个元素。之后，我们递减j，直到它找到一个大于主元的元素。然后，我们检查以确保I仍然大于或等于j。如果为真，我们交换由I和j指向的元素，并继续在循环中移动，直到满足第5行指定的条件。我们现在已经成功地排列了元素，使得pivot左边的所有元素都小于pivot，而右边的所有元素都大于pivot。</p><p id="6372" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们为什么返回I？I的最终值表示递归快速排序技术所必需的下一次排序的起点。让我们来看看:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jr"><img src="../Images/bfd013db7a70e508cbb7e12d6f9dec61.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*wrnE6KnNt0KtzXchVeA1vQ.png"/></div></figure><p id="c67c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们有了一个工作的分区函数，我们可以递归地调用它，直到我们完成数组排序。这种情况的基本情况是一个长度为1个元素的数组，如第24行所述。第一步是通过调用partition方法获取第一个I，方法是将参数传递给quickSort函数，如第25行所示。然后，我们调用在I的帮助下产生的子数组。因此，在第26行的if语句中，我们对原始pivot右侧的子数组运行quickSort。在第29行的下一个if语句中，我们对原始pivot右侧的子数组运行quickSort。这样，在每次迭代中，我们将每个子数组分成两半，最终得到一个完全排序的数组。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="er es js"><img src="../Images/a56a0b63ec93e22846e3adba4af655a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lG-ZQZc8wnMxxC30he04Og.jpeg"/></div></div></figure><p id="8164" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这有助于我们将代码运行时发生的流程形象化。这里我们从一个包含10个元素的数组开始，展示了quickSort中的代码如何将数组分割成越来越小的部分，直到数组长度为1。另外，请注意，我们实际上并没有拆分数组本身，我们只是在数组的每个对应部分上运行partition方法。</p><p id="9d19" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当第一次看到不同的算法时，尝试自己编码解决方案会有所帮助。一旦你这样做了，它有助于巩固你头脑中的逻辑，以备将来使用。甚至当你完成了这些，写一篇博客，用你自己的话来解释它，进一步把这个概念带回家！</p></div></div>    
</body>
</html>