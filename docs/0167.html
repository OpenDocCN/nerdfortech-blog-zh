<html>
<head>
<title>Lexical Environment: A must read before Closures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">词法环境:闭包之前的必读内容</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/lexical-environment-6b4363f38db?source=collection_archive---------0-----------------------#2020-06-09">https://medium.com/nerd-for-tech/lexical-environment-6b4363f38db?source=collection_archive---------0-----------------------#2020-06-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6c8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在JavaScript中，你一定多次听说过术语<strong class="ih hj">词法环境</strong>。</p><blockquote class="jd je jf"><p id="0e0d" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated"><strong class="ih hj">那么这个词法环境是什么呢？</strong></p></blockquote><p id="d973" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">"<strong class="ih hj">词法环境"</strong>基本上是一个规范对象，它存储了标识符与其函数和变量的关联。</p><p id="7145" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个变量、函数和代码块都有自己的<em class="jg">词汇环境</em>。</p><p id="96cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">把词法环境考虑成两部分:<br/> 1。<strong class="ih hj"> <em class="jg">环境</em> </strong>:存储<a class="ae jk" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/this" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"/></a>的所有局部变量和值。<br/> 2。<strong class="ih hj"> <em class="jg">引用</em> </strong>:对其被创造的外部环境的引用。</p><p id="0f62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们更详细地研究变量和函数。</p><h1 id="36e0" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">案例A:变量</h1><p id="8bea" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">在下图中，注释解释了<em class="jg">词汇环境。</em></p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es ko"><img src="../Images/17d3e8a6c1efe7dbf177167b88345381.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/0*ZRLWPFmo32DZfuCg"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated"><em class="la">变量</em>的词法环境示例</figcaption></figure><ul class=""><li id="3424" class="lb lc hi ih b ii ij im in iq ld iu le iy lf jc lg lh li lj bi translated">当脚本开始运行时，全局<em class="jg">词法环境</em>被预先填充了内部声明的变量，但是所有变量都没有初始化，所有变量对外部环境的引用为空。</li><li id="ed5a" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">当它到达第<code class="du lp lq lr ls b">let newVariable ;</code>行时，我们可以用这个变量初始化它，因为它现在是<code class="du lp lq lr ls b">undefined</code>。</li><li id="701f" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">现在我们给<code class="du lp lq lr ls b">newVariable = "Hello";</code>赋值，并且<em class="jg">词汇环境</em>也得到更新。</li><li id="883c" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">然后，我们再次将值更改为<code class="du lp lq lr ls b">newVariable = "Hello";</code>，从而更新<em class="jg">词汇环境</em>。</li></ul><h1 id="a112" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">案例B:功能</h1><blockquote class="jd je jf"><p id="9a2f" class="if ig jg ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">函数甚至在声明之前就可以使用了，因为它们在脚本运行时会被立即初始化。</p></blockquote><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es lt"><img src="../Images/fe9c007809387a152775094031826bb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/0*isJ2VKC1SMguYwBH"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated"><em class="la">变量</em> <em class="la">和函数</em>的词法环境示例</figcaption></figure><p id="0acc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当一个函数运行时，一个<em class="jg">词法环境</em>被创建来存储它的局部变量和它们的值，并且<em class="jg">引用</em>到它被创建的外部环境。</p><p id="1599" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">函数首先在内部词法环境中搜索变量，如果没有找到，就移动到外部环境，以此类推，直到找到全局环境。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es lu"><img src="../Images/1dcb415dbf685165b52482977d11bcad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/0*o8Y7LloSD7b6bg58"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated"><em class="la">输出:</em>T4】</figcaption></figure><p id="279a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，函数<code class="du lp lq lr ls b">eat</code>在其<em class="jg">词法环境</em>中有变量<code class="du lp lq lr ls b">fruit</code>，但是在其<em class="jg">词法环境</em>中没有找到<code class="du lp lq lr ls b">count</code>，所以它利用<em class="jg">对外部<em class="jg">词法环境</em>的引用</em>来搜索<code class="du lp lq lr ls b">count</code>，并最终找到了它。因此，输出是<code class="du lp lq lr ls b">2 apple</code>。</p><p id="95ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jg">注意:使用函数表达式语法，函数不会被立即初始化，直到脚本为它们点击“</em> <code class="du lp lq lr ls b">let</code> <em class="jg">”关键字后才能使用。</em> <br/> <code class="du lp lq lr ls b">let eat = function(fruit){console.log(`Eat ${fruit}!`);}</code></p></div></div>    
</body>
</html>