<html>
<head>
<title>Making Sense of Containers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解容器</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/making-sense-of-containers-d69d81bdc8e9?source=collection_archive---------4-----------------------#2022-04-29">https://medium.com/nerd-for-tech/making-sense-of-containers-d69d81bdc8e9?source=collection_archive---------4-----------------------#2022-04-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="04d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请在此阅读Docker先决条件<a class="ae jd" href="https://www.pansofarjun.com/post/docker-pre-requisites" rel="noopener ugc nofollow" target="_blank"/></p><h1 id="8602" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">为什么是集装箱？</h1><p id="da2a" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我们在开发一个app的时候，选择JS、Python、Java等语言。这些语言需要被执行，因此我们需要一个像node JS这样的运行时环境。这个节点JS有不同的版本。当我们在开发时，我们可能会使用较新的版本，但是当我们进入生产时(即在服务器中)，我们可能会得到较旧的版本。</p><p id="710a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是生产和开发环境不匹配的情况。为了解决这个问题，我们可以将系统(服务器)分成许多机器。这不能像硬盘和CPU分割那样通过物理方式实现，但可以通过软件实现。这个概念叫做<strong class="ih hj">虚拟化</strong>，相应的拆分资源的软件叫做<strong class="ih hj">虚拟机监控程序</strong>。这种创建新机器的想法被称为<strong class="ih hj">虚拟机</strong>。</p><p id="073b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们创建的每个虚拟机都是相互独立的，我们构建的每个应用程序都必须有单独的操作系统、依赖关系等。对于每个虚拟机。这导致了另一个问题，假设我们有app1，app2和app3有相同的操作系统(Linux)；如果我们将它们放入虚拟机，我们需要在三个不同的虚拟机中安装三次相同的Linux操作系统。</p><p id="e17b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，除了主机操作系统之外，每个虚拟机都有单独的操作系统。这个操作系统被称为'<strong class="ih hj">客户操作系统</strong>'。<em class="kh">这实质上意味着操作系统不会在虚拟机之间共享</em>。</p><p id="cf36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请记住，操作系统消耗了大部分存储空间，因为即使你的应用程序只有10MB，它也至少需要400 MB。</p><p id="0909" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从商业角度来看，如果有任何方法可以跨应用程序共享操作系统，那么它可以节省数十亿美元的成本。这种跨应用程序共享操作系统的技术被称为“<strong class="ih hj">容器</strong>”。当然，除了操作系统共享，容器还有很多优点。</p><p id="04b8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">容器化利用了主机操作系统中的内核，而内核是分割CPU、内存等硬件的内核。为了一个特殊的任务。</p><h1 id="dc71" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">什么是容器？</h1><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es ki"><img src="../Images/ee5987ea18c4aa631e8d0223b4ba28e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ce-z4a2HF_oDKhcA.png"/></div></div></figure><blockquote class="ku kv kw"><p id="268e" class="if ig kh ih b ii ij ik il im in io ip kx ir is it ky iv iw ix kz iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">容器=独立运行的软件。</em> </strong></p></blockquote><p id="93e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">自足的</strong>——所有的东西本身都是可用的</p><p id="8a0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">软件</strong>——软件是我们创建的一个应用程序，基本上是一大块<em class="kh">代码</em></p><p id="f8dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">运行</strong>——软件需要运行的基本上是<em class="kh">依赖</em>和<em class="kh">环境</em></p><p id="2149" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这一点的实现基本上与<em class="kh">面向对象编程概念</em>(即<strong class="ih hj">类</strong>和<strong class="ih hj">对象</strong>)相同——将有<strong class="ih hj">一个类</strong>，我们可以像<strong class="ih hj">一样创建许多我们想要的</strong> <strong class="ih hj">实例</strong>(<strong class="ih hj">对象</strong>)。模板是类，执行是由对象完成的。</p><p id="0aa0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该技术中的类等价物是'<strong class="ih hj">图像</strong>，对象等价物是'<strong class="ih hj">容器</strong>。这些图像是容器技术的可共享部分。</p><p id="a6aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如前所述，图像是创建容器的模板。因此我们可以得到<em class="kh">标准图像</em>(从<em class="kh"> Docker hub </em>)或<em class="kh">定制图像</em>(我们自己)。标准图像可在docker hub网站上获得；它们包含应用程序的基本设置。</p><figure class="kj kk kl km fd kn er es paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="er es la"><img src="../Images/85e71d1960b3e903230e959655bb6657.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*l8X_zrHlsTVEh4f7.png"/></div></div></figure><p id="8f2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在<strong class="ih hj"> <em class="kh"> docker文件</em> </strong>里面创建一个图像。由此，我们将创建许多容器(即<em class="kh">实例</em>)。</p><p id="8163" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码和环境会在映像中，容器在运行一个app — <strong class="ih hj"> <em class="kh">存储、内存等的时候会用到代码和环境。，将由容器</em> </strong> <em class="kh">决定。</em>容器中运行的东西与本地机器隔离。</p><p id="1411" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们总是可以从零开始建立一个图像，但这很麻烦。因此，我们将始终建立一个现有的图像像官方图像像一个节点从docker枢纽的图像。<em class="kh">该基本映像将包含所需的操作系统和设置。</em></p><p id="1b9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在本地机器上有源代码和依赖/环境。然后，我们将源代码依赖环境复制到该时间点的映像中。然后，我们将基于图像运行容器。</p><p id="11e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是这里要注意的一点是，当我们在图像创建后更改源时，它不会自动反映在<strong class="ih hj">图像</strong>以及相应的<strong class="ih hj">容器</strong>中。</p><blockquote class="ku kv kw"><p id="1254" class="if ig kh ih b ii ij ik il im in io ip kx ir is it ky iv iw ix kz iz ja jb jc hb bi translated"><strong class="ih hj">这向我们证明了图像是时间的快照。</strong></p></blockquote><p id="ffae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kh">容器在图片上添加另一层</em>。容器执行在创建的映像上运行代码所需的命令。这证明了我们的容器分配资源、内存等等。它不会从映像中再次复制代码，因此Docker是高效的。</p><p id="cd93" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">重述</strong>:</p><p id="30ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">图片:创建容器的蓝图</strong></p><p id="1f34" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">容器:我们使用蓝图(图像)创建的实例</strong></p><p id="4a61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">所以一个图像却有许多容器</strong></p></div><div class="ab cl lb lc gp ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="hb hc hd he hf"><p id="1f3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kh">原载于2022年4月29日</em><a class="ae jd" href="https://www.pansofarjun.com/post/containers" rel="noopener ugc nofollow" target="_blank"><em class="kh">【https://www.pansofarjun.com】</em></a><em class="kh">。</em></p></div></div>    
</body>
</html>