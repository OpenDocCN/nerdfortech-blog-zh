<html>
<head>
<title>Matt’s Tidbits #96 — Cleaner Components with React Fragments</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Matt的花絮#96 —含React碎片的清洁剂成分</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/matts-tidbits-96-cleaner-components-with-react-fragments-aef93ffdf18c?source=collection_archive---------29-----------------------#2021-05-25">https://medium.com/nerd-for-tech/matts-tidbits-96-cleaner-components-with-react-fragments-aef93ffdf18c?source=collection_archive---------29-----------------------#2021-05-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/38aac84142469fb3e19295382d341213.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*emarK1xFUj42xdKh6D2nAA.jpeg"/></div></div></figure><p id="a0ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上一次，我写了关于在TypeScript中定义常量。这周我想分享一下我对React片段的了解！</p><p id="1b40" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于我的许多Android开发人员读者来说，从构建Android UI的角度来看，你已经了解了所有关于片段的知识。然而，在React/React本地世界中，片段服务于完全不同的目的。</p><p id="b3c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，一个例子—假设您想要定义一个返回某些元素的方法(或组件)，例如:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="eaa2" class="jy jz hi ju b fi ka kb l kc kd">const Stack = createStackNavigator()</span><span id="e059" class="jy jz hi ju b fi ke kb l kc kd">const SomeComponent = () =&gt; {<br/>  return (<br/>    &lt;Stack.Navigator&gt;<br/>      getScreens()<br/>    &lt;/Stack.Navigator&gt;<br/>  );<br/>};</span></pre><p id="a9ae" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kf kg kh ju b">getScreens()</code>最有可能的第一个实现是返回一个数组(至少，我一开始是这样做的):</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="55bb" class="jy jz hi ju b fi ka kb l kc kd">const getScreens = () =&gt; {<br/>  return [<br/>    &lt;Stack.Screen name="Screen1" component={Screen1Component} /&gt;,<br/>    &lt;Stack.Screen name="Screen2" component={Screen2Component} /&gt;,<br/>    ...<br/>  ];<br/>};</span></pre><p id="d865" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不幸的是，这种方法会产生一个编译器警告:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="20ca" class="jy jz hi ju b fi ka kb l kc kd">Warning: Each child in a list should have a unique "key" prop</span></pre><p id="94c5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae jo" href="https://reactjs.org/docs/lists-and-keys.html" rel="noopener ugc nofollow" target="_blank">这样做的原因是React规定列表中的每个元素都必须有一个唯一可识别的“key”属性</a>——主要是为了帮助比较同一个列表的两个版本——是添加了新元素，还是删除了一些元素，或者现有元素在列表中的位置发生了变化？这是一个很好的特性，但是对于我们的屏幕列表来说，为每个项目定义一个“key”属性有点多余。我们已经有了一个惟一的“键”(<code class="du kf kg kh ju b">name</code>字段)，此外，我们不期望这个列表会随着时间而改变。</p><p id="3fc6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">谢天谢地，React为这个问题提供了一个更干净的解决方案——<a class="ae jo" href="https://reactjs.org/docs/fragments.html" rel="noopener ugc nofollow" target="_blank">片段</a>！</p><p id="8cbb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们使用一个片段，下面是<code class="du kf kg kh ju b">getScreens()</code>的样子:</p><pre class="jp jq jr js fd jt ju jv jw aw jx bi"><span id="fc10" class="jy jz hi ju b fi ka kb l kc kd">const getScreens = () =&gt; {<br/>  return (<br/>    &lt;React.Fragment&gt;<br/>      &lt;Stack.Screen name="Screen1" component={Screen1Component} /&gt;<br/>      &lt;Stack.Screen name="Screen2" component={Screen2Component} /&gt;<br/>    &lt;/React.Fragment&gt;<br/>  );<br/>};</span></pre><p id="1fba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">瞧啊。这同样有效，我们不需要在每一行的末尾添加逗号，最重要的是，我们不需要在每一项上定义一个“key”属性。</p><p id="d0e3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以使用一种更简洁的简写方式，那就是用短语法<code class="du kf kg kh ju b">&lt;&gt;</code>替换<code class="du kf kg kh ju b">&lt;React.Fragment&gt;</code>，以进一步清理这种情况，并清楚地表明该片段实际上只是一个包装器。</p><p id="b588" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一种方法是将元素包装在React <code class="du kf kg kh ju b">&lt;div&gt;</code>或React Native <code class="du kf kg kh ju b">&lt;View&gt;</code>元素中，但是这有一些缺点:</p><ul class=""><li id="3555" class="ki kj hi is b it iu ix iy jb kk jf kl jj km jn kn ko kp kq bi translated">您实际上是向视图层次结构添加了一个额外的项目——片段在呈现过程中会消失。</li><li id="bcfe" class="ki kj hi is b it kr ix ks jb kt jf ku jj kv jn kn ko kp kq bi translated">有些场景，比如上面的React导航示例，不允许将除了<code class="du kf kg kh ju b">&lt;Stack.Screen&gt;</code>之外的任何元素直接嵌入到<code class="du kf kg kh ju b">&lt;Stack.Navigator&gt;</code>中——将片段作为唯一可行的选项。</li></ul><p id="86f8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望您学到了一些关于片段的有用知识，这将有助于改进您的React代码！你用其他/独特的方式使用片段吗？我很想在评论中听到它！</p><p id="9ebe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有兴趣和我一起在埃森哲出色的数字产品团队工作吗？我们在招人！</p></div></div>    
</body>
</html>