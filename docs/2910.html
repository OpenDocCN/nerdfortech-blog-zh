<html>
<head>
<title>As Easy As Closure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">很容易就结束了</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/as-easy-as-closure-abb71f70f283?source=collection_archive---------20-----------------------#2021-05-23">https://medium.com/nerd-for-tech/as-easy-as-closure-abb71f70f283?source=collection_archive---------20-----------------------#2021-05-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/296be5dacca36883867b6a281d5adac3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MBZlCpr1mn5EMyQoMFm1Gg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">鸣谢:昂斯佩什的弗兰克·麦肯纳</figcaption></figure><p id="6d04" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">自从闭包在JavaScript中出现以来，它就一直困扰着人类😉😁然而，如果你仔细观察它，了解它是如何工作的，它被证明是一个令人难以置信的优雅和简单的构造。在这篇博客中，除了理论，我将带你通过几个例子来建立一个心智的、概念的模型，这个模型(希望)会一直留在你的脑海中，你永远不会再<em class="js">想知道</em>什么是闭包。</p><p id="8fff" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这些是我们将在这篇博客中熟悉的概念:</p><ul class=""><li id="af1f" class="jt ju hi iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">执行线程</li><li id="1ebf" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">执行上下文</li><li id="c20a" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">调用栈</li><li id="f788" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">高阶函数</li><li id="9eb8" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">词法范围以及JS是怎样一种词法范围的语言</li><li id="e292" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">关闭</li></ul><h2 id="b150" class="kh ki hi bd kj kk kl km kn ko kp kq kr jf ks kt ku jj kv kw kx jn ky kz la lb bi translated">开始理解终结的旅程</h2><p id="f06f" class="pw-post-body-paragraph iu iv hi iw b ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr hb bi translated">让我们先从一个基本的例子开始，来理解JavaScript的执行线程是如何工作的:</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><ul class=""><li id="d8b5" class="jt ju hi iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">当这个程序执行时，首先从第1行到第6行的<code class="du ln lo lp lq b">createFunction</code>的函数定义存储在全局存储器中，标识符为<code class="du ln lo lp lq b">createFunction</code>。</li><li id="d230" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">然后在第8行，标识符<code class="du ln lo lp lq b">generatedFunction</code>被创建，并且<em class="js">未初始化</em>，直到<code class="du ln lo lp lq b">createFunction</code>运行并返回。我们知道<code class="du ln lo lp lq b">createFunction</code>将要运行，而不仅仅是<em class="js">引用了</em>，因为在第8行有paranthesis。</li><li id="2d81" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">当<code class="du ln lo lp lq b">createFunction</code>将要运行时，将在内存中为它创建一个新的执行上下文，并且<code class="du ln lo lp lq b">createFunction()</code>将被添加到调用堆栈中。此时调用堆栈看起来是这样的:</li></ul><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es lr"><img src="../Images/03b37406f9d855aeef1b2333a8a91a4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*KiRB60rvoe2Sjfoj-A73qw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">调用堆栈的当前状态</figcaption></figure><ul class=""><li id="2ad6" class="jt ju hi iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">请注意，全局()始终位于调用堆栈的底部。</li><li id="885c" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">然后将在(全局)存储器中查找<code class="du ln lo lp lq b">createFunction</code>的定义，并开始执行。注意，执行线程不会从第8行转到第1行。这条线一直向前延伸。为了执行<code class="du ln lo lp lq b">createFunction</code>，从存储器中取出其定义。</li><li id="c58b" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">在<code class="du ln lo lp lq b">createFunction</code>内部，首先<code class="du ln lo lp lq b">multiplyBy2</code>的定义被存储在<code class="du ln lo lp lq b">createFunction</code>的本地内存中(你可以看一下第2到4行来对此做一个心理模型，但是执行的线程，正如我之前所说的，并没有<em class="js">实际上</em>转到第2–4行)。</li><li id="d31c" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">然后<code class="du ln lo lp lq b">multiplyBy2</code>的定义被提取并返回到调用环境，存储在<code class="du ln lo lp lq b">generatedFunction</code>变量中。实际上，这意味着<code class="du ln lo lp lq b">multiplyBy2</code>的定义获得了一个新标签:<code class="du ln lo lp lq b">generatedFunction</code></li><li id="8b4b" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">一旦在第5行点击了<code class="du ln lo lp lq b">return</code>关键字(这再次意味着您可以<em class="js">在第5行查看</em>以读取返回的内容，但是执行线程并不<em class="js">实际上</em>转到第5行——它只是在遇到来自内存的<code class="du ln lo lp lq b">createFunction</code>的函数定义中的<code class="du ln lo lp lq b">return</code>关键字时返回<code class="du ln lo lp lq b">multiplyBy2</code>函数)，就会删除<code class="du ln lo lp lq b">createFunction</code>的执行上下文，以及它在调用堆栈中的条目。</li></ul><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es ls"><img src="../Images/764ef84b2bb05e2f7ea73cee2a819d8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*4O6AVCqO1BRadYTXQ7SZgA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">调用堆栈的当前状态</figcaption></figure><ul class=""><li id="6cc8" class="jt ju hi iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">接下来在第10行，标识符<code class="du ln lo lp lq b">result</code>被创建并被统一，直到<code class="du ln lo lp lq b">generatedFunction</code>运行并返回。</li><li id="26fd" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">这里值得注意的一点是，创建<code class="du ln lo lp lq b">generatedFunction</code>定义的原始环境已经不存在了。它甚至是不需要的，因为<code class="du ln lo lp lq b">multiplyBy2</code>的定义现在存在于标签<code class="du ln lo lp lq b">generatedFunction</code>下的全局内存中。</li><li id="0881" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated"><code class="du ln lo lp lq b">generatedFunction</code>被运行，它自己的执行上下文被创建，它的条目被添加到调用堆栈中。</li></ul><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es lt"><img src="../Images/80dd9e00f6d525934638b4717c5dac4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*DUkl7WZslWuhXI0NUERAxg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">调用堆栈的当前状态</figcaption></figure><ul class=""><li id="fd9f" class="jt ju hi iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">在<code class="du ln lo lp lq b">generatedFunction</code>的执行过程中，首先将参数5存储在其本地内存中，标签为<code class="du ln lo lp lq b">number</code>。</li><li id="b781" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">然后完成<code class="du ln lo lp lq b">number * 2</code>的计算，其评估为10。然后将值10返回到调用环境中，并存储在变量<code class="du ln lo lp lq b">result</code>中。</li><li id="4685" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">同时，删除<code class="du ln lo lp lq b">generatedFunction</code>的执行上下文和调用堆栈条目。</li></ul><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es ls"><img src="../Images/764ef84b2bb05e2f7ea73cee2a819d8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*4O6AVCqO1BRadYTXQ7SZgA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">调用堆栈的当前状态</figcaption></figure><ul class=""><li id="446a" class="jt ju hi iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">在第11行，记录了<code class="du ln lo lp lq b">result</code>的值。</li></ul><p id="620d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这次讨论中值得注意的一点是:</p><p id="6445" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在第5行，返回了<code class="du ln lo lp lq b">multiplyBy2</code>的<strong class="iw hj">定义</strong>和<strong class="iw hj">而不是</strong>的<strong class="iw hj">引用</strong>。如果引用被返回，那么如何在第10行调用它(带有新标签<code class="du ln lo lp lq b">generatedFunction</code>)?记住，函数一返回，<code class="du ln lo lp lq b">createFunction</code>的执行上下文和本地内存就被删除了！！</p><p id="2e4b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所以现在我们知道了<strong class="iw hj">执行上下文</strong>、<strong class="iw hj">调用栈</strong>是什么，以及<strong class="iw hj">函数</strong>是如何从其他函数<strong class="iw hj">返回</strong>的。</p><p id="4687" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">顺便说一下，接受和/或返回其他函数的函数被称为<strong class="iw hj">高阶函数</strong>。</p><p id="1d45" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们再举一个例子:</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="b99e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个例子建立在<code class="du ln lo lp lq b">basicExample.js</code>之上。为了完整起见，让我们再看一遍执行线程的机制，这次要快一点，因为上次我们已经非常详细地理解了它。</p><ul class=""><li id="3d9e" class="jt ju hi iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">第1–10行:存储在存储器中的<code class="du ln lo lp lq b">createFunction</code>的定义。</li><li id="603b" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">第12行:标识符<code class="du ln lo lp lq b">result</code>被创建，直到<code class="du ln lo lp lq b">createFunction</code>运行并返回，它仍未初始化。<code class="du ln lo lp lq b">createFunction</code>开始运行，同时创建它自己的执行上下文和它在调用堆栈中的条目。</li></ul><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es lu"><img src="../Images/adc23a53932241d1504fb14f8ab442f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*Yf6rkc-gQOiRyhVdxpIsEA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">调用堆栈的当前状态</figcaption></figure><ul class=""><li id="97bc" class="jt ju hi iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">在<code class="du ln lo lp lq b">createFunction</code>的执行过程中，标识符<code class="du ln lo lp lq b">value</code>被创建为值5。<code class="du ln lo lp lq b">multiplyBy2</code>的定义与标识符<code class="du ln lo lp lq b">multiplyBy2</code>一起存储。所有这些都存储在分配给<code class="du ln lo lp lq b">createFunction</code>的<strong class="iw hj">本地存储器</strong>中。</li></ul><p id="fdfd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">再次注意</strong>:当函数<code class="du ln lo lp lq b">createFunction</code>运行时，执行线程不会从第12行返回到第1行。当它必须执行这个<code class="du ln lo lp lq b">createFunction</code>时，它从存储在存储器中的<code class="du ln lo lp lq b">createFunction</code>的定义执行它。我一直在引用第12行的第1行，因为这是我们看到正在发生的事情的方式。</p><ul class=""><li id="b21a" class="jt ju hi iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">此外，当调用<code class="du ln lo lp lq b">multiplyBy2</code>时，为其创建一个新的执行上下文，并且将其条目推入调用堆栈。</li></ul><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es lv"><img src="../Images/345345d6a9dd72d9471b29c215abeceb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*4ERsMSNLxycBT_27oF_e4g.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">调用堆栈的当前状态</figcaption></figure><ul class=""><li id="bec2" class="jt ju hi iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">在<code class="du ln lo lp lq b">multiplyBy2</code>的执行上下文中，<code class="du ln lo lp lq b">value</code>的值必须更新为双精度值。但是<code class="du ln lo lp lq b">value</code>在<code class="du ln lo lp lq b">multiplyBy2</code>的本地内存/执行上下文中不存在。</li></ul><p id="bfe1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">JS引擎在这种情况下做什么？</p><p id="5560" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">它会在调用栈中向下移动来寻找<code class="du ln lo lp lq b">value</code>的定义吗？</p><p id="8566" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">你可能会想，是的，的确如此！</p><p id="8943" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">好吧，为了让你开心，我会假设它会。因此，假设<code class="du ln lo lp lq b">value</code>的定义在父上下文(即<code class="du ln lo lp lq b">createFunction</code>的本地内存)中找到，并更新为自身的两倍。</p><ul class=""><li id="8f90" class="jt ju hi iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">接下来，点击<code class="du ln lo lp lq b">multiplyBy2</code>的右括号，函数结束，其执行上下文被删除，并弹出调用堆栈。</li></ul><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es lw"><img src="../Images/46b1dbc3bb741c049158b2bbe41b304b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*dgw2NRJu8InaWcnNeBcwug.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">调用堆栈的当前状态</figcaption></figure><ul class=""><li id="f0ab" class="jt ju hi iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">进一步在<code class="du ln lo lp lq b">createFunction</code>的执行中，<code class="du ln lo lp lq b">value</code>的值被返回到调用环境。</li><li id="35c8" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">第12行:现在来自<code class="du ln lo lp lq b">createFunction()</code>的返回值用标识符<code class="du ln lo lp lq b">result</code>存储在全局上下文中。与此同时，<code class="du ln lo lp lq b">createFunction</code>的执行上下文也被删除，它也被弹出调用堆栈。</li></ul><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es lx"><img src="../Images/f2d61f4bfb197e9a568b8a0a92a312d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/1*y6XVkUywc_z0Al3SsHPB0w.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">调用堆栈的当前状态</figcaption></figure><ul class=""><li id="6b26" class="jt ju hi iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">第13行:<code class="du ln lo lp lq b">result</code>的值被打印到控制台。</li></ul><p id="e22a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在回到我们做了一个<em class="js">大的</em>假设的地方:当一个函数不能在它自己的本地内存中找到一个变量的定义时，它会在调用栈中一步一步的往下走，在找到那个变量定义的第一个位置停下来。</p><p id="e941" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们这样假设对吗？</p><p id="8b22" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">与其制造更多的悬念，我将简单地探究另一个可以澄清事实的例子。</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="39f8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我想把关于执行线程如何进行以及如何处理执行上下文和调用堆栈的讨论留给您作为练习。你可以参考上面的讨论来做😊</p><p id="0b0f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里需要重点关注的是:</p><p id="de7b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在第11行中，<code class="du ln lo lp lq b">createFunction</code>函数返回<code class="du ln lo lp lq b">multiplyBy2</code>函数的定义，并用新标签<code class="du ln lo lp lq b">doubleItUp</code>存储它。这个返回的函数有<em class="js">引用</em>到一个变量(<code class="du ln lo lp lq b">value</code>)，这个变量不是在它自己的本地内存中<em class="js">定义的</em>(<em class="js">见</em>第4行到第7行，但是执行的线程实际上不去那里)，而是在<code class="du ln lo lp lq b">multiplyBy2</code>被<em class="js">定义</em>的上下文的本地内存中定义的(即在<code class="du ln lo lp lq b">createFunction</code> <em class="js"> </em>的上下文中，即它的父上下文)<em class="js">。</em></p><p id="8af6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">此外，当这个返回的函数实际被<em class="js">调用时，</em><code class="du ln lo lp lq b">createFunction</code>的上下文甚至不再存在！！！</p><p id="5de4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">那么我们如何期望这个<em class="js">返回的函数</em>成功运行并处理变量<code class="du ln lo lp lq b">value</code>呢？</p><p id="cf02" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">那么第13-14行发生了什么？如果我们之前的假设是正确的，那么当调用<code class="du ln lo lp lq b">doubleItUp</code>时，它试图将<code class="du ln lo lp lq b">value</code>的值加倍并返回它。但是首先，它在自己的执行上下文中找不到变量，所以它(根据我们的假设)试图在调用堆栈中向下一级查找变量。但是在调用堆栈的下一层，在这个阶段是…鼓点…T2上下文！！因为<code class="du ln lo lp lq b">createFunction</code>的调用栈条目在<code class="du ln lo lp lq b">createFunction</code>返回的时候早就被删除了！！</p><p id="93aa" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">暂时消化一下这一点。如果需要的话，在这个例子中再运行一次执行上下文…</p><p id="863f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">准备好下一件事了吗？好了，现在我们确定了<code class="du ln lo lp lq b">value</code>变量不能来自<code class="du ln lo lp lq b">multiplyBy2</code>的<em class="js">父</em>作用域，并且这个例子运行成功，问题来了:<code class="du ln lo lp lq b">value</code>的定义从何而来？？</p><p id="5c59" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">答案，你可能已经猜到了…来自<code class="du ln lo lp lq b">multiplyBy2.</code>啊哈的<em class="js">关闭</em>！我们终于到了！！</p><p id="4892" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">但是等一下。我们首先不知道什么是终结。</p><p id="f97f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所以让我们更正式地谈论它。</p><p id="b5f7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当<code class="du ln lo lp lq b">multiplyBy2</code>或者任何一个函数被创建时，它会得到一个小的内存来保存函数定义中引用的变量。在JavaScript中，这个<strong class="iw hj">存储的内存</strong>以及整个<strong class="iw hj">概念</strong>被称为<strong class="iw hj">闭包</strong>。这就像周围的环境被放在一个盒子里，<em class="js">关闭</em>然后和功能一起运送，无论功能去哪里。</p><p id="05b5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">函数的<strong class="iw hj">闭包</strong>保存的值来自函数的<strong class="iw hj">词法范围</strong>。函数的<strong class="iw hj">词法范围</strong>是函数被<strong class="iw hj">创建</strong>的<strong class="iw hj">环境</strong>。</p><p id="0c35" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们把这个和我们的例子<code class="du ln lo lp lq b">closuresInFullForm.js</code>联系起来。</p><p id="a7ef" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当<code class="du ln lo lp lq b">createFunction</code>返回<code class="du ln lo lp lq b">multiplyBy2</code>时，它不仅返回了<code class="du ln lo lp lq b">multiplyBy2</code>的定义，还返回了它在定义中保存的少量引用。所以这个<em class="js">存储</em>包含了<code class="du ln lo lp lq b">value</code>字段，并且和<code class="du ln lo lp lq b">multiplyBy2</code>的定义一起被送回了全局上下文。</p><p id="91b8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">此后，正如预期的那样，<code class="du ln lo lp lq b">multiplyBy2</code>的定义有了一个新的标签:<code class="du ln lo lp lq b">doubleItUp</code>，但商店(又名<em class="js">关闭</em>)仍然完好无损。每当我们想运行以前叫做<code class="du ln lo lp lq b">multiplyBy2</code>的<code class="du ln lo lp lq b">doubleItUp</code>时，JS引擎就需要引用<code class="du ln lo lp lq b">value</code>，它首先在:</p><ul class=""><li id="57ab" class="jt ju hi iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated"><code class="du ln lo lp lq b">doubleItUp</code>的(新创建的)执行上下文，在那里没有找到。</li><li id="326c" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">然后在闭包里查找，在那里找到并处理它。因此，第14行的输出是10。</li></ul><p id="6f5b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">唷！！那是相当多的讨论。</p><p id="4d14" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了形象化闭包是如何创建的，您可以将闭包(比如说<code class="du ln lo lp lq b">processValues</code>函数)想象成一只章鱼，它的触角伸向创建<code class="du ln lo lp lq b">processValues</code>的环境中的引用。这个<strong class="iw hj">环境</strong>就是<code class="du ln lo lp lq b">processValues.</code>的<strong class="iw hj">词法范围</strong></p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ly"><img src="../Images/ca166d7e403e26cbaf5dfd479d2362ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5C8MD7r013_G8_n9lPI8Qw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">封闭类似于章鱼的触角</figcaption></figure><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es lz"><img src="../Images/dc90c883fe4964785ab7c26d2c27d73b.png" data-original-src="https://miro.medium.com/v2/resize:fit:250/format:webp/1*SjC9iKyg91F2dCCDiiZJtw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">输出</figcaption></figure><p id="ab25" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">最后一个例子需要注意的要点:</strong></p><ul class=""><li id="abcc" class="jt ju hi iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">没有被<code class="du ln lo lp lq b">processValues</code>引用的<code class="du ln lo lp lq b">processValues</code>函数的本地环境中的字段没有被添加到闭包中。这是JavaScript设计者采用的一种优化措施。所以一旦<code class="du ln lo lp lq b">createFunction</code>执行完毕<code class="du ln lo lp lq b">value4</code>就永远丢失了。</li><li id="d470" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">存储在闭包存储库中的数据是私有的，不能以任何方式直接访问。只有当<code class="du ln lo lp lq b">doCalculations</code>运行时，<code class="du ln lo lp lq b">value1</code>、<code class="du ln lo lp lq b">value2</code>和<code class="du ln lo lp lq b">value3</code>的值才会更新。参见上面的输出。</li><li id="b602" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">正是返回的<code class="du ln lo lp lq b">processValues</code>函数的隐藏的<code class="du ln lo lp lq b">[[scope]]</code>属性使得关闭机制成为可能。</li><li id="5504" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">JS引擎查找引用的顺序如下:</li></ul><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es ma"><img src="../Images/6b4dfc619f8edcdc79cd50cf803d62ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/format:webp/1*WVxOX9kiUn4DuOrSQghiSg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">JS引擎查找引用的顺序</figcaption></figure><h2 id="1371" class="kh ki hi bd kj kk kl km kn ko kp kq kr jf ks kt ku jj kv kw kx jn ky kz la lb bi translated">为什么我们说JavaScript是词汇作用域语言</h2><p id="65bd" class="pw-post-body-paragraph iu iv hi iw b ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr hb bi translated">这是因为在JS中创建的每个函数都有它的闭包，而这个闭包来自这个函数最初被定义的地方，也就是函数的词法范围。所以函数在某种程度上对它们的出生地有一些记忆。这个词法作用域与<em class="js">调用/调用</em>这个函数的环境/作用域无关。</p><p id="9a44" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里有一个例子:</p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><ul class=""><li id="c229" class="jt ju hi iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated">当第19行<code class="du ln lo lp lq b">createFunction</code>运行时，它返回<code class="du ln lo lp lq b">processValues</code>函数定义及其闭包。</li><li id="4c89" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated">当<code class="du ln lo lp lq b">doCalculations</code>在第21行运行时，它的闭包只记住最初<em class="js">定义</em>的词法范围。所以它的闭包包含来自<code class="du ln lo lp lq b">createFunction</code>的(现已删除)执行上下文的<code class="du ln lo lp lq b">value1</code>、<code class="du ln lo lp lq b">value2 </code>和<code class="du ln lo lp lq b">value3</code>。记住<code class="du ln lo lp lq b">createFunction</code>的执行上下文被删除，但是值<code class="du ln lo lp lq b">value1</code>、<code class="du ln lo lp lq b">value2 </code>和<code class="du ln lo lp lq b">value3</code>在闭包中保持不变。</li><li id="dc5f" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated"><code class="du ln lo lp lq b">doCalculations</code>在<code class="du ln lo lp lq b">global</code>的执行上下文中<em class="js">被调用/调用</em>。全局中的数据对<code class="du ln lo lp lq b">doCalculations</code>的运行没有影响。所以全局范围内的<code class="du ln lo lp lq b">value3</code>对<code class="du ln lo lp lq b">doCalculations</code>没有影响。</li></ul><p id="2b27" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">顺便提一下，如果JS是一种动态作用域语言，函数被<em class="js">调用的环境<strong class="iw hj">的作用域</strong></em>  <em class="js"> </em>会对函数的运行产生影响。</p><h1 id="998b" class="mb ki hi bd kj mc md me kn mf mg mh kr mi mj mk ku ml mm mn kx mo mp mq la mr bi translated">用更多的例子展示我们的理解能力</h1><p id="adf7" class="pw-post-body-paragraph iu iv hi iw b ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr hb bi translated"><strong class="iw hj">多次更新闭包变量</strong></p><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="03a1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">输出:</strong></p><p id="6ff1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">第13行打印1。</p><p id="c5f6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">第14行打印2。</p><p id="e912" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">需要快速解释吗？</p><p id="bd45" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">第11行运行<code class="du ln lo lp lq b">outer</code>，存储<code class="du ln lo lp lq b">inner</code>的函数定义和闭包，标签为<code class="du ln lo lp lq b">newFunction</code>。当<code class="du ln lo lp lq b">newFunction</code>在第13行运行时，它开始寻找<code class="du ln lo lp lq b">counter</code>的定义，并在闭包中找到，<code class="du ln lo lp lq b">counter</code>的当前值为0，将其更新为1并打印出来。当第14行再次运行<code class="du ln lo lp lq b">newFunction</code>时，它再次在闭包中找到<code class="du ln lo lp lq b">counter</code>的定义，这次<code class="du ln lo lp lq b">counter</code>的现有值是1，它将其更新为2并打印出来。</p><p id="ba0b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是一种便捷的方式来记忆来自之前运行的函数的数据，正式名称为记忆化。如果<code class="du ln lo lp lq b">newFunction</code>涉及复杂且耗时的计算，那么JS引擎很容易记住上一次运行的值，并在下一次调用中从该点继续。</p><h2 id="73bd" class="kh ki hi bd kj kk kl km kn ko kp kq kr jf ks kt ku jj kv kw kx jn ky kz la lb bi translated">多个函数可以共享同一个闭包</h2><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="c6e6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">输出:</strong></p><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es ms"><img src="../Images/48f214193b45a799f13155c56f099566.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*uKpCSpZqKGi6TtgP0ihT-Q.png"/></div></figure><p id="8ce0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">相当简单的东西，我把这个例子的解释作为练习留给你。</p><p id="d988" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">唯一需要特别注意的是，返回函数数组中的每个函数(<code class="du ln lo lp lq b">inner1, inner2 </code>和<code class="du ln lo lp lq b">inner3</code>)都可以访问完全相同的闭包。因此，从一个高阶函数一起返回的多个函数具有相同的闭包。</p><h2 id="f0c3" class="kh ki hi bd kj kk kl km kn ko kp kq kr jf ks kt ku jj kv kw kx jn ky kz la lb bi translated"><strong class="ak">多个闭包实例</strong></h2><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="1d08" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在事情越来越令人兴奋。在第11行，<code class="du ln lo lp lq b">inner</code>函数带着它的闭包被返回，并被赋予一个新标签<code class="du ln lo lp lq b">newFunction1</code>。第12行和第13行的<code class="du ln lo lp lq b">newFunction1</code>调用更新了它们闭包中的计数器变量，并将其打印为1(第12行)和2(第13行)。</p><p id="3b10" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">第15行包含一个新的调用<code class="du ln lo lp lq b">outer</code>，它返回一个新的副本<code class="du ln lo lp lq b">inner</code>和一个新的闭包实例，它得到一个新的标签<code class="du ln lo lp lq b">newFunction2</code>。所以第16行和第17行再次打印1和2。</p><p id="b78d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">与<code class="du ln lo lp lq b">newFunction1</code>和<code class="du ln lo lp lq b">newFunction2</code>相关的闭合装置相互隔离。</p><h2 id="6a0a" class="kh ki hi bd kj kk kl km kn ko kp kq kr jf ks kt ku jj kv kw kx jn ky kz la lb bi translated">多闭包实例的另一个例子</h2><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="bd20" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这次，第12、13、16和17行的输出都是:1。</p><p id="63ac" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">第11行:<code class="du ln lo lp lq b">outer</code>返回，用标签<code class="du ln lo lp lq b">newFunction1</code>存储<code class="du ln lo lp lq b">inner</code>函数的定义和闭包。每次在第12行和第13行调用<code class="du ln lo lp lq b">newFunction1</code>时，该函数都会运行，但是这次它不需要在闭包中寻找<code class="du ln lo lp lq b">counter</code>的定义。它的定义就在<code class="du ln lo lp lq b">newFunction1</code>自己的本地存储器中。每次调用<code class="du ln lo lp lq b">newFunction1</code>时，<code class="du ln lo lp lq b">counter</code>重新初始化为0，并递增至1。</p><p id="f2ce" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在第15行，<code class="du ln lo lp lq b">inner</code>的新副本被返回，带有标签<code class="du ln lo lp lq b">newFunction2</code>的闭包的新实例。同样的过程再次重复。同样，执行线程不必在<code class="du ln lo lp lq b">newFunction2</code>的本地存储器之外寻找<code class="du ln lo lp lq b">counter</code>的定义。第16行和第17行中对<code class="du ln lo lp lq b">newFunction2</code>的每次调用都将计数器重新初始化为0，并每次递增1。</p><p id="181c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在上述两种情况下，闭包的概念都是多余的。</p><h2 id="d8b1" class="kh ki hi bd kj kk kl km kn ko kp kq kr jf ks kt ku jj kv kw kx jn ky kz la lb bi translated">读取全局数据</h2><figure class="lh li lj lk fd ij"><div class="bz dy l di"><div class="ll lm l"/></div></figure><p id="74e6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">输出</strong>:</p><p id="097f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">第13行:1</p><p id="c268" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">第13行:2</p><p id="e264" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">第13行:3</p><p id="d86b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">第13行:4</p><p id="3fe4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是因为这次每次调用<em class="js">都会返回</em> <code class="du ln lo lp lq b">inner</code>函数，以<code class="du ln lo lp lq b">newFunction1</code>和<code class="du ln lo lp lq b">newFunction2</code>的形式更新并打印<em class="js">全局</em>变量<code class="du ln lo lp lq b">counter</code>。</p><p id="6ab6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为什么？因为当<code class="du ln lo lp lq b">newFunction1</code>或<code class="du ln lo lp lq b">newFunction2</code>被调用时，它们在本地内存或闭包中找不到<code class="du ln lo lp lq b">counter</code>的定义。因此，JS引擎在调用栈中寻找<code class="du ln lo lp lq b">counter</code>,在全局中找到它并更新它。</p><h2 id="ad38" class="kh ki hi bd kj kk kl km kn ko kp kq kr jf ks kt ku jj kv kw kx jn ky kz la lb bi translated">闭包的用例</h2><p id="e13d" class="pw-post-body-paragraph iu iv hi iw b ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn lg jp jq jr hb bi translated">闭包对于理解JavScript的几个特性很重要，如下所示。</p><ul class=""><li id="7640" class="jt ju hi iw b ix iy jb jc jf jv jj jw jn jx jr jy jz ka kb bi translated"><strong class="iw hj">记忆化:</strong>如上所述，为我们的函数提供对其先前输入和输出的持久记忆。</li><li id="cfd9" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated"><strong class="iw hj">迭代器和生成器:</strong>使用词法范围和闭包来实现JS中处理数据的最新模式。</li><li id="1426" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated"><strong class="iw hj">模块模式:</strong>在不污染全局名称空间的情况下，为应用程序的生命周期保留状态。</li><li id="703c" class="jt ju hi iw b ix kc jb kd jf ke jj kf jn kg jr jy jz ka kb bi translated"><strong class="iw hj">异步JavaScript: </strong>回调和承诺依赖闭包来在异步环境中保持状态。</li></ul><p id="8342" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这就是所有的人。我知道这是一篇相当长的阅读，但希望它能让您对JS的这个深奥特性有所了解。如果感觉很多，我建议你用纸和笔完成每个例子，看看执行的线程是如何移动的。</p></div></div>    
</body>
</html>