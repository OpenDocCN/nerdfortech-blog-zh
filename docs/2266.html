<html>
<head>
<title>NgRx — Local Component Store</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NgRx —本地组件存储</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/ngrx-local-component-store-a8635649e0c5?source=collection_archive---------0-----------------------#2021-04-29">https://medium.com/nerd-for-tech/ngrx-local-component-store-a8635649e0c5?source=collection_archive---------0-----------------------#2021-04-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="937b" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">将全局应用程序存储用作本地组件存储</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/b19dea87fb4c6a085adf571016daa59a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cvRLVwucbfJ1KHTV.png"/></div></div></figure><p id="6152" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我将尝试<em class="kf">解释如何使用 ngrx 全局存储作为本地组件存储。</em>我们将尝试寻找一些问题的答案，例如什么是本地商店，我们面临哪些问题，以及如何解决这些问题。<em class="kf">除了几篇文章或 stackoverflow 答案之外，这个主题要找到任何来源、文章或解决方案几乎是很麻烦的。</em>此外，如果你没有理解 ngrx 和 angular 概念，那么理解这些答案或文章是不可能的。本文的目的是创建一个简单的解决方案和资源。我们开始吧。</p><p id="b811" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">事实上，我们已经宣布了一个名为<a class="ae kg" href="https://ngrx.io/guide/component-store" rel="noopener ugc nofollow" target="_blank"> @ngrx/component-store </a>的解决方案，专注于 2020 年 8 月 10 日由 Firebase 控制台团队成员 Kevin Elko 和<a class="ae kg" href="https://twitter.com/AlexOkrushko" rel="noopener ugc nofollow" target="_blank"> Alex Okrushko </a>开发的 ngrx 第 10 版。这个想法的创造者是 Kevin，Alex 是将它集成到 ngrx 中的人。我可以告诉你确切的解决方案是使用这个模块，但是出于某些原因，你可能仍然希望使用全局存储作为本地存储。所以我们将重点讨论如何通过<a class="ae kg" href="https://ngrx.io/guide/store" rel="noopener ugc nofollow" target="_blank"> @ngrx/store </a>，而不是这个模块。</p><h2 id="6944" class="kh ki hi bd kj kk kl km kn ko kp kq kr js ks kt ku jw kv kw kx ka ky kz la lb bi translated">有什么问题？</h2><p id="b0a4" class="pw-post-body-paragraph jj jk hi jl b jm lc ij jo jp ld im jr js le ju jv jw lf jy jz ka lg kc kd ke hb bi translated">首先，我经常说一个问题，一个问题，一个问题。这个问题到底是什么？我们需要通过代码示例来定义这个问题。少说多做。</p><p id="5f1f" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">让我们制作一个简单的示例，创建一个名为 PersonList 的组件，并将其设计为 angular 模块。它保存了一个人员列表，可以添加或删除一个新的人。在根上提供这个模块，并考虑能够在许多页面上多次使用它。此外，该组件将使用 ngrx 全局存储。我将分享我们在 stackblitz 上创建的示例，供那些想尝试现场演示的人使用。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lh li l"/></div></figure><p id="cbb7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">当运行我们的示例并添加两个人时，状态如下所示。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lj"><img src="../Images/c0a9f05aa98690909178a1db3682f103.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/0*gly1_NKUduVqEB54.png"/></div></figure><p id="3381" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这是 stackblitz 上的一个活生生的例子。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lk li l"/></div></figure><p id="a1a5" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">文件夹结构:</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ll"><img src="../Images/c3c26cb4d6523de0c842be3983d175c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/0*5IvKvIwQlmotcWbf.png"/></div></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lm li l"/></div></figure><p id="2cca" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这个例子如我们预期的那样工作。对于添加一个新的人，我们调度 addPerson 动作。之后我们通过 ngrx 效果调用服务保存数据。然后副作用 addPersonSuccess 正在运行，我们从浏览器得到一个“保存成功”的提示。Reducer 为我们更新了状态。我们在选择器的帮助下异步读取数据，并在屏幕上呈现，并使用相同的方法删除一个人。现在，我们将更改代码以重现问题，并看看出现了什么样的问题。我们要一起一步一步考虑出路。</p></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><h2 id="e147" class="kh ki hi bd kj kk kl km kn ko kp kq kr js ks kt ku jw kv kw kx ka ky kz la lb bi translated">麻烦 1</h2><p id="c9a6" class="pw-post-body-paragraph jj jk hi jl b jm lc ij jo jp ld im jr js le ju jv jw lf jy jz ka lg kc kd ke hb bi translated">假设我们可以在多个页面中多次使用 PersonList 组件，并希望每次使用时它都是一个空的组件状态。如果我们刷新第 1 页(F5 ),则组件为空，这里没有问题。现在我们创建一个新页面(第 2 页),并同样使用我们的组件。之后，在第 1 页添加一个新人，然后转到第 2 页。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lu li l"/></div></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lk li l"/></div></figure><p id="3426" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果你照我说的去做，你会在第 2 页和第 1 页的列表中看到你在第 1 页上保存的人，同样在所有的页面上。这是有原因的，即使组件在它们使用的状态下是可重用的。现在让我们来处理这个问题。当转到第 2 页时，状态应该是干净的。我们可以使用 ngOnDestroy 钩子来解决这个问题。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lv"><img src="../Images/24bd2b1db793517df1c8b1de81d2436d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mG9UuwlgHFAHF6V2.png"/></div></div><figcaption class="lw lx et er es ly lz bd b be z dx translated">摧毁行动</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ma"><img src="../Images/1f017a9a3c4f13c28be68fc0b1549ede.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/0*IrAnGHJlVRv6p4_4.png"/></div><figcaption class="lw lx et er es ly lz bd b be z dx translated">破坏减速器</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mb"><img src="../Images/6ebe374b06f7e3cb567663fcef0f3205.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/0*6C5MURznZsdWqKg8.png"/></div><figcaption class="lw lx et er es ly lz bd b be z dx translated">部件损坏</figcaption></figure><p id="c8b2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">作为解决方案，我们采用了你们大多数人想到的第一种方法。我们创建了一个销毁操作，并在每次组件被销毁时调度这个操作。在 reducer 代码中，我们再次将状态设置回初始状态。总之，我们使我们的状态(联合的)随时可以重用。这就是我们如何解决将全球商店用作本地商店时遇到的第一个麻烦。</p></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><h2 id="fb70" class="kh ki hi bd kj kk kl km kn ko kp kq kr js ks kt ku jw kv kw kx ka ky kz la lb bi translated">麻烦 2</h2><p id="418a" class="pw-post-body-paragraph jj jk hi jl b jm lc ij jo jp ld im jr js le ju jv jw lf jy jz ka lg kc kd ke hb bi translated">现在让我们把事情变得复杂一点，在同一个页面上使用 PersonList 组件两次，并向我们的第二个问题问好。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mc li l"/></div></figure><p id="0c4c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">正如您所看到的，无论我们使用两个组件中的哪一个来添加人员，我们都会看到我们在两个组件中添加的人员。我们需要使用全局存储为每个组件创建一个本地存储。让我们试试想到的第一个解决方案。</p><p id="066a" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">首先，我们应该通过在动作元数据上使用一个标识符属性来分离动作。由于有了这个标识符，我们就可以区分到达缩减器的动作应该为哪个组件运行。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es md"><img src="../Images/7ed6ef181d5fd33d8221cf8dc4ec5419.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*uMDeGbX4Nd8XW6_-pc3djw.png"/></div></figure><p id="9e2b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">创建一个容器状态，将所有 PersonListState 保存到 reducer 中。每个组件状态都将作为片段站在这个容器下。</p><p id="d86c" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">创建一个名为 stateSlice 的辅助函数，通过这个函数我们可以从状态中得到我们想要的切片。这样，我们将隔离每个组件状态，但我们的缩减器代码将变得难看。我们稍后会更正减速器代码。</p><p id="7a94" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">作为一个例子，我把 addPerson 和 removePerson 动作的唯一最终版本。如果你想详细研究它，你可以查看 stackblitz 上的实时演示。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es me"><img src="../Images/22e3e2d90a187c7c765a875f3dc8c292.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/0*acSs6fXY2I7_ImvR.png"/></div></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mf"><img src="../Images/bce0c98b89c97e38d53d1925883b8322.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BZZfelfa2UOvdkoM1Otj-g.png"/></div></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mg"><img src="../Images/44935a350cb2818da9c8e2cd701efdc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AiHaLhPoKOlCeS7lfhQOSg.png"/></div></div></figure><p id="2bf7" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">此外，向我们的选择器添加一个标识符，以从存储中获取正确的数据，但是我们失去了可读性和可维护性，就像在 reducer 中一样。您可以尝试不同的方法来提高可读性并降低维护成本。也许 sliceState 函数可以是泛型之类的。但这不是我们的重点。让我们继续…</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mh"><img src="../Images/e69b043dac5d766fb8b5efc9336bad6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*0MvTe1zUNTEneyXJhLZ0kQ.png"/></div></figure><p id="92a4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为 PersonList 组件创建一个 id 输入，并将这个 id 传递给操作和选择器。</p><blockquote class="mi mj mk"><p id="cfdd" class="jj jk kf jl b jm jn ij jo jp jq im jr ml jt ju jv mm jx jy jz mn kb kc kd ke hb bi translated">如果你想了解更多关于参数化选择器的信息，你可以搜索 ngrx 参数化选择器’。</p></blockquote><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mo"><img src="../Images/bae9ff233454570792c7d11f4d50d039.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*tUjv2tkatmlgE52ROQ2t5g.png"/></div></figure><p id="5f08" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">将此标识符传递给触发器动作的映射效果。举个例子，我把 addPerson 效应。我把所有的特效都更新成这样。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mp"><img src="../Images/e414f8da10ea4abe99afe30c03801ccf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*77KW3a_gpJEwD0o_2M3z6g.png"/></div></figure><p id="996b" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">为页面上的组件设置 id。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mq"><img src="../Images/5fc39422b769ba410526368eda664b50.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/0*ncFD96gvJNWDAp5V.png"/></div></figure><p id="b0ea" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">最后，当组件准备好创建动作时初始化状态，并在所有事情之前在组件的 ngOnInit 钩子中分派它，这对于避免选择器抛出错误很重要。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mr"><img src="../Images/2ae9507cc267352ed8eb9380bdf99434.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/0*JALVtNY1RoP5xLol.png"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ms"><img src="../Images/b4b8463d33a2605b8d93c805ac73bd00.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/0*6PYCBQsEUC8KPap3.png"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mt"><img src="../Images/30f93a6f3667e04fbd20a34f99520749.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FkZQ3IQg31gv6Mhz.png"/></div></div></figure><p id="cee0" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">Ta-da…结果看起来像我们想要的:)我们完成了使用全局存储作为特定于组件的本地存储。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mu"><img src="../Images/97ff438f7ae20a26985c10bdc3e85192.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*X6BYkeRwJDPkxiLG.png"/></div></div></figure><p id="e4b8" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">即使您尝试转到第 2 页，也可以看到状态已被销毁操作删除。下面附上 stackblitz 现场演示。我建议你仔细检查一下，以便更好地理解它。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lk li l"/></div></figure></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><p id="2b96" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果你认为我们处理好了一切，那你就错了。接下来我们有更复杂的麻烦。我想向您展示我们使用最后一个现场演示的下一个问题。你可以像我一样试试。我尝试添加一个新的人，然后不等待结果就快速进入第 2 页。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mv li l"/></div></figure><p id="d638" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如你所知，当一个人成功保存它时，我们会从浏览器得到一个成功提示。即使组件状态被破坏，也会显示此警报。这种行为意味着即使状态被破坏，效果也不会取消订阅。因此，我们知道订阅在应用程序的整个生命周期中不会被破坏。对我们来说有一个非常严重的问题。我们不能确定我们的州真的干净。因此，我们必须为每种效果定义具体的组件。那么我们如何做到这一点呢？我们总是在每篇 ngrx 文章或例子中看到相同的方法，效果类被导入到一个特性或根的模块级。这意味着当模块加载一次(懒惰或急切)时，我们订阅效果，这些订阅直到应用程序生命结束时才被销毁。我们必须阻止这种行为。为此，ngrx 给了我们两个非常有用的接口。</p><ul class=""><li id="8488" class="mw mx hi jl b jm jn jp jq js my jw mz ka na ke nb nc nd ne bi translated">OnRunEffects</li><li id="0f49" class="mw mx hi jl b jm nf jp ng js nh jw ni ka nj ke nb nc nd ne bi translated">OnIdentifyEffects</li></ul></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><h2 id="de5c" class="kh ki hi bd kj kk kl km kn ko kp kq kr js ks kt ku jw kv kw kx ka ky kz la lb bi translated">OnRunEffects</h2><p id="30a1" class="pw-post-body-paragraph jj jk hi jl b jm lc ij jo jp ld im jr js le ju jv jw lf jy jz ka lg kc kd ke hb bi translated">这个接口给出了一个名为 ngrxOnRunEffects 的方法来实现它。因此，它返回一个可观察到的解析效果源，我们可以使用它通过管道进行拦截。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nk"><img src="../Images/543cba66dd36952ddc095c471c93f27c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7_0MRJ3umqndX9qy.png"/></div></div></figure><p id="e4a2" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">您应该还记得，我们在每次销毁组件时都会调度销毁操作。此时，这个销毁操作将有助于完成我们的订阅。让我们现在就开始将这个接口添加到我们的效果类中。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es nl"><img src="../Images/0438f7b31db0922b69dc0aa4e360c051.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*28RREKNcEL-4EZCU.png"/></div></div></figure><p id="f628" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们使用 rxjs takeUntil 操作符来完成我们的效果订阅，所以我们可以确保所有的效果都将工作，直到销毁操作被分派，但是之后所有的效果都将被完成。您可以使用下面的现场演示来验证这一点。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lk li l"/></div></figure><p id="bf45" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">如果您在转到第 2 页时再次尝试上一个示例，您将不会看到保存成功提示。因为我们的解析效果是在组件被破坏时完成的。但是这里有麻烦了。如果你再次回到第一页，试图创建一个新人，你会发现你的效果不再起作用了。我以前说过什么；</p><blockquote class="nm"><p id="7167" class="nn no hi bd np nq nr ns nt nu nv ke dx translated">我们总是在每篇 ngrx 文章或例子中看到相同的方法，效果类被导入到功能或根的模块级。这意味着当模块加载一次(懒惰或急切)时，我们订阅效果，这种订阅直到应用程序生命结束时才被销毁。</p></blockquote><p id="1fa9" class="pw-post-body-paragraph jj jk hi jl b jm nw ij jo jp nx im jr js ny ju jv jw nz jy jz ka oa kc kd ke hb bi translated">因为我们的介入，特效完成了。我们不能再次加载这些效果，因为模块已经加载过一次，没有办法做到这一点。(也许可以，但那不是我们的话题。)因此，我们需要订阅组件初始化时的效果，而不是已经加载的模块。此时，ngrx 给了我们一个名为 EffectSources 的服务。让我们继续使用这个。</p><p id="89da" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们正在删除从 PersonListModule 导入的 EffectModule。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ob"><img src="../Images/97874d3a43ec0c04c9bf6c1c1ec5bb7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EZM_YplgZ6p08kTl.png"/></div></div></figure><p id="a8dd" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">然后将 EffectSources 服务注入到我们的 PersonListComponent 中，从 PersonListEffect 类中获取一个实例，并通过 addEffects 方法将其添加到源代码中。因此 PersonListEffect 类不应该再被注入。随着这种方法的完成，所有效果<em class="kf">都被销毁，并在组件初始化后再次被订阅。</em></p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es oc"><img src="../Images/1b7ed26f49d7ccb44362b308855b044f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*G2ag-ipOKefek7L7.png"/></div></div></figure><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lk li l"/></div></figure></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><p id="1617" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">即使问题看起来几乎解决了，我们仍然有麻烦。PersonListComponent 在第 1 页初始化了两次，你可以在 redux dev tools 中看到类似的内容。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es od"><img src="../Images/e8f195861490c937afdc962e7298c827.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LZuKbf2iM3Gw6hVP.png"/></div></div></figure><p id="6526" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">你可以问一些问题，比如我们是否使用 addEffects 将两个不同的资源添加到 EffectSource 两次，或者这是否会导致每个效果运行两次。Ngrx 在后面处理。即使你多次注册同一个效果类别，它也只注册一次。所以在这个阶段对我们来说没有问题，但是我们可以为每个组件注册不同的效果实例。此时，OnIdentifyEffects 接口开始发挥作用。</p></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><h2 id="a84f" class="kh ki hi bd kj kk kl km kn ko kp kq kr js ks kt ku jw kv kw kx ka ky kz la lb bi translated">OnIdentifyEffects</h2><p id="5c22" class="pw-post-body-paragraph jj jk hi jl b jm lc ij jo jp ld im jr js le ju jv jw lf jy jz ka lg kc kd ke hb bi translated">这个接口给我们设置效果的标识符。很好用。我们可以只返回一个字符串标识符。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es oe"><img src="../Images/cdaad799f7bb174898c8d7e9e2334bf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/0*9MONWhuh_AmCah7q.png"/></div></figure><p id="bd75" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们已经在 PersonListComponent 上有了一个 id。我们可以将这个 id 用于此目的，这里没有障碍。让我们将这个 id 传递给 PersonListEffect 类构造函数，并在方法中返回它。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es of"><img src="../Images/ae92cbee0f1b06515f96b74a20c41f2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*ALktTexyQWrdgbk7.png"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es of"><img src="../Images/8c57644b4edec6c1c4b0787866ca505c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*UgrbEcywpP-E7aNk.png"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es og"><img src="../Images/2ef681fe254b25236da223998c1a9709.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7O41IdNFU81nmVa8.png"/></div></div></figure><p id="71b4" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">现在，我们需要过滤通过这个标识符发出的效果。为此，我们可以创建一个简单的名为 localOfType 的自定义 rxjs 操作符，然后用它代替 OfType。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es oh"><img src="../Images/28ba645122aa4cfb61ce9a51656aea5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MzmxSJ6-BEG07zrg.png"/></div></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es oi"><img src="../Images/3cc0e0cf242d5f324ef9cdc34fd2a8f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*N1O4AiPzNQrvGW6F.png"/></div></div></figure></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><h2 id="bb7b" class="kh ki hi bd kj kk kl km kn ko kp kq kr js ks kt ku jw kv kw kx ka ky kz la lb bi translated">减速器管理器</h2><p id="a614" class="pw-post-body-paragraph jj jk hi jl b jm lc ij jo jp ld im jr js le ju jv jw lf jy jz ka lg kc kd ke hb bi translated">正如您所记得的，我们创建了一个容器存储来保存状态切片。这意味着需要更多的编码工作量时间。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es oj"><img src="../Images/6cf305429c68eff71192c846f5bdbfee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/0*Kivs-sgr7zYeIqAn.png"/></div></figure><p id="0dbf" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">首先，我们要删除从 PersonListModule 导入的 StoreModule，以解决这个问题。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ok"><img src="../Images/b7f217f63ea535f42ac53cfa34a44ae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PloKlqbq9WKNcfJ2.png"/></div></div></figure><p id="fd56" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们需要重写 reducer 代码。从现在起，功能密钥不能是静态的。根据每个组件的标识符，它必须是特殊的。我们创建一个简单的助手方法并导出它，而不是导出特性键。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ol"><img src="../Images/48f0fcbb0564270b7092bfd6758d2066.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/0*59eRgfARotDw9QmI.png"/></div></figure><p id="e793" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">之后，我们更简单地重写缩减器。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es om"><img src="../Images/88f62d82f63d6b07dc11ef955eba3f32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YYY8cB9VTfEXSnNk.png"/></div></div></figure><p id="5271" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们创建了一个助手方法来根据标识符过滤动作。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es on"><img src="../Images/f497872db52b9c1db9b5ab31e7f7bec8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8sD-ed29zdon1RPm.png"/></div></div></figure><p id="410e" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们也应该对选择器做同样的事情。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es oo"><img src="../Images/7b1a478b22536e033af3b5cf5cbba2a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ku7kG2NYXHOgcKmd.png"/></div></div></figure><p id="fb6d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">最后，我们应该通过 ReducerManager 服务添加 reducers。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es op"><img src="../Images/fe2b5ec3f9582dcbd1bb0e6c593425a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KdrK_aursnLXAw2RT4RxJw.png"/></div></div></figure></div><div class="ab cl ln lo gp lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="hb hc hd he hf"><h1 id="4dd4" class="oq ki hi bd kj or os ot kn ou ov ow kr io ox ip ku ir oy is kx iu oz iv la pa bi translated">结论</h1><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="pb li l"/></div></figure><p id="68b9" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">我们学习了如何使用全局存储作为本地组件存储，但是我建议使用 ngrx 组件存储。</p><p id="d15d" class="pw-post-body-paragraph jj jk hi jl b jm jn ij jo jp jq im jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">快乐编码… <br/>不要害羞问我任何问题。<a class="ae kg" href="http://info@emrehizli.com" rel="noopener ugc nofollow" target="_blank">info@emrehizli.com</a></p></div></div>    
</body>
</html>