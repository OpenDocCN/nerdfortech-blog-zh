<html>
<head>
<title>LeetCode — Merge Two Sorted Lists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">LeetCode —合并两个排序列表</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/leetcode-merge-two-sorted-lists-99cc19e1b06e?source=collection_archive---------0-----------------------#2021-08-29">https://medium.com/nerd-for-tech/leetcode-merge-two-sorted-lists-99cc19e1b06e?source=collection_archive---------0-----------------------#2021-08-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/d48a5c01d407793ca3692ee300593e8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*KwONvlT60pE2ENJM9oMYBg.png"/></div></figure><h1 id="ac45" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">问题陈述</h1><p id="7711" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">合并两个排序的链表，并将其作为一个<strong class="jm hj">排序的</strong>列表返回。应该通过将前两个列表的节点拼接在一起来制作列表。</p><p id="91d2" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">问题陈述摘自:【https://leetcode.com/problems/merge-two-sorted-lists】T2</p><p id="9bfb" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">例一:</strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="395e" class="kx in hi kt b fi ky kz l la lb">Input: l1 = [1, 2, 4], l2 = [1, 3, 4]<br/>Output: [1, 1, 2, 3, 4, 4]</span></pre><p id="1a4c" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">例2: </strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="9102" class="kx in hi kt b fi ky kz l la lb">Input: l1 = [], l2 = []<br/>Output: []</span></pre><p id="311d" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">例3: </strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="4a2e" class="kx in hi kt b fi ky kz l la lb">Input: l1 = [], l2 = [0]<br/>Output: [0]</span></pre><p id="57eb" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj">约束:</strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="9678" class="kx in hi kt b fi ky kz l la lb">- The number of nodes in both lists is in the range [0, 50].<br/>- -100 &lt;= Node.val &lt;= 100<br/>- Both l1 and l2 are sorted in non-decreasing order.</span></pre><h1 id="7086" class="im in hi bd io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj bi translated">说明</h1><p id="eb13" class="pw-post-body-paragraph jk jl hi jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hb bi translated">由于列表已经排序，我们可以比较列表的节点，并将较小的节点添加到新列表中。</p><p id="8d4e" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">让我们检查一下这种方法的算法。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="6075" class="kx in hi kt b fi ky kz l la lb">- return list l2 if list l1 == null<br/><br/>- return list l1 if list l2 == null<br/><br/>- set ListNode *head = null<br/><br/>- if l1-&gt;val &lt; l2-&gt;val<br/>  - set head = l1<br/>  - move ahead l1 = l1-&gt;next<br/>- else<br/>  - set head = l2<br/>  - move ahead l2 = l2-&gt;next<br/><br/>- initialize ListNode *p and set p = head<br/><br/>- while(l1 &amp;&amp; l2) // l1 and l2 both are not null<br/>  - if l1-&gt;val &lt; l2-&gt;val<br/>    - set p-&gt;next = l1<br/>    - set l1 = l1-&gt;next<br/>  - else<br/>    - set p-&gt;next = l2<br/>    - set l2 = l2-&gt;next<br/><br/>  - set p = p-&gt;next<br/><br/>// append the pending elements of the remaining list<br/>- if l1 != null<br/>  - set p-&gt;next = l1<br/>- else<br/>  - set p-&gt;next = l2</span></pre><p id="398e" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj"> C++解决方案</strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="313c" class="kx in hi kt b fi ky kz l la lb">class Solution {<br/>public:<br/>    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {<br/>        if (l1 == NULL){<br/>            return l2;<br/>        }<br/><br/>        if(l2 == NULL) {<br/>            return l1;<br/>        }<br/><br/>        ListNode *head = NULL;<br/><br/>        if(l1-&gt;val &lt; l2-&gt;val){<br/>            head = l1;<br/>            l1 = l1-&gt;next;<br/>        } else {<br/>            head = l2;<br/>            l2 = l2-&gt;next;<br/>        }<br/><br/>        ListNode *p;<br/>        p = head;<br/><br/>        while(l1 &amp;&amp; l2){<br/>            if(l1-&gt;val &lt; l2-&gt;val){<br/>                p-&gt;next = l1;<br/>                l1 = l1-&gt;next;<br/>            } else {<br/>                p-&gt;next = l2;<br/>                l2 = l2-&gt;next;<br/>            }<br/><br/>            p = p-&gt;next;<br/>        }<br/><br/>        if(l1 != NULL){<br/>            p-&gt;next = l1;<br/>        } else {<br/>            p-&gt;next = l2;<br/>        }<br/><br/>        return head;<br/>    }<br/>};</span></pre><p id="4e0d" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj"> Golang解决方案</strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="bc69" class="kx in hi kt b fi ky kz l la lb">func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {<br/>    if l1 == nil {<br/>        return l2<br/>    }<br/><br/>    if l2 == nil {<br/>        return l1<br/>    }<br/><br/>    var head *ListNode<br/><br/>    if l1.Val &lt; l2.Val {<br/>        head = l1<br/>        l1 = l1.Next<br/>    } else {<br/>        head = l2<br/>        l2 = l2.Next<br/>    }<br/><br/>    var p *ListNode;<br/>    p = head;<br/><br/>    for l1 != nil &amp;&amp; l2 != nil {<br/>        if l1.Val &lt; l2.Val {<br/>            p.Next = l1<br/>            l1 = l1.Next<br/>        } else {<br/>            p.Next = l2<br/>            l2 = l2.Next<br/>        }<br/><br/>        p = p.Next<br/>    }<br/><br/>    if l1 != nil {<br/>        p.Next = l1<br/>    } else {<br/>        p.Next = l2<br/>    }<br/><br/>    return head<br/>}</span></pre><p id="a86e" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><strong class="jm hj"> Javascript解决方案</strong></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="50db" class="kx in hi kt b fi ky kz l la lb">var mergeTwoLists = function(l1, l2) {<br/>    if( !l1 ){<br/>        return l2;<br/>    }<br/><br/>    if( !l2 ){<br/>        return l1;<br/>    }<br/><br/>    let head = new ListNode(0, null);<br/><br/>    if( l1.val &lt; l2.val ){<br/>        head = l1;<br/>        l1 = l1.next;<br/>    } else {<br/>        head = l2;<br/>        l2 = l2.next;<br/>    }<br/><br/>    let p = head;<br/><br/>    while(l1 &amp;&amp; l2) {<br/>        if (l1.val &lt; l2.val) {<br/>            p.next = l1;<br/>            l1 = l1.next;<br/>        } else {<br/>            p.next = l2;<br/>            l2 = l2.next;<br/>        }<br/><br/>        p = p.next;<br/>    }<br/><br/>    if( l1 ){<br/>        p.next = l1;<br/>    } else {<br/>        p.next = l2;<br/>    }<br/><br/>    return head;<br/>};</span></pre><p id="d7ce" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated">让我们试运行一下我们的算法，看看解决方案是如何工作的。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="2e23" class="kx in hi kt b fi ky kz l la lb">Input: l1 = [1, 2, 4], l2 = [1, 3, 4]<br/><br/>Step 1: if l1 == NULL<br/>        false<br/><br/>Step 2: if l2 == NULL<br/>        false<br/><br/>Step 3: ListNode *head = NULL;<br/><br/>Step 4: if l1-&gt;val &lt; l2-&gt;val<br/>        1 &lt; 1<br/>        false<br/><br/>        head = l2<br/><br/>        head<br/>          |<br/>          1 -&gt; 3 -&gt; 4<br/><br/>        l2 = l2-&gt;next<br/><br/>               l2<br/>               |<br/>          1 -&gt; 3 &gt; 4<br/><br/>Step 5: ListNode *p<br/>        p = head<br/><br/><br/>        head, p<br/>          |<br/>          1 -&gt; 3 -&gt; 4<br/><br/>Step 6: loop while l1 &amp;&amp; l2<br/>        true &amp;&amp; true<br/>        true<br/><br/>        - if l1-&gt;val &lt; l2-&gt;val<br/>          1 &lt; 3<br/>          true<br/><br/>          p-&gt;next = l1<br/><br/>          head, p<br/>           |<br/>           1 -&gt; 1<br/><br/>          l1 = l1-&gt;next<br/><br/>               l1<br/>               |<br/>          1 -&gt; 2 -&gt; 4<br/><br/>          p = p-&gt;next<br/><br/>          head  p<br/>           |    |<br/>           1 -&gt; 1<br/><br/>Step 7: loop while l1 &amp;&amp; l2<br/>        true &amp;&amp; true<br/>        true<br/><br/>        - if l1-&gt;val &lt; l2-&gt;val<br/>          2 &lt; 3<br/>          true<br/><br/>          p-&gt;next = l1<br/><br/>          head  p<br/>           |    |<br/>           1 -&gt; 1 -&gt; 2<br/><br/>          l1 = l1-&gt;next<br/><br/>                   l1<br/>                    |<br/>          1 -&gt; 2 -&gt; 4<br/><br/>          p = p-&gt;next<br/><br/>          head       p<br/>           |         |<br/>           1 -&gt; 1 -&gt; 2<br/><br/>Step 8: loop while l1 &amp;&amp; l2<br/>        true &amp;&amp; true<br/>        true<br/><br/>        - if l1-&gt;val &lt; l2-&gt;val<br/>          4 &lt; 3<br/>          false<br/><br/>          p-&gt;next = l2<br/><br/>          head       p<br/>           |         |<br/>           1 -&gt; 1 -&gt; 2 -&gt; 3<br/><br/>          l2 = l2-&gt;next<br/><br/>                   l2<br/>                    |<br/>          1 -&gt; 3 -&gt; 4<br/><br/>          p = p-&gt;next<br/><br/>          head            p<br/>           |              |<br/>           1 -&gt; 1 -&gt; 2 -&gt; 3<br/><br/>Step 9: loop while l1 &amp;&amp; l2<br/>        true &amp;&amp; true<br/>        true<br/><br/>        - if l1-&gt;val &lt; l2-&gt;val<br/>          4 &lt; 4<br/>          false<br/><br/>          p-&gt;next = l2<br/><br/>          head            p<br/>           |              |<br/>           1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4<br/><br/>           l2 = l2-&gt;next<br/><br/>                         l2<br/>                          |<br/>          1 -&gt; 3 -&gt; 4 -&gt; null<br/><br/>          p = p-&gt;next<br/><br/>          head                 p<br/>           |                   |<br/>           1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4<br/><br/>Step 10: loop while l1 &amp;&amp; l2<br/>         true &amp;&amp; false<br/>         false<br/><br/>Step 11: if l1 != NULL<br/>         true<br/><br/>         p-&gt;next = l1<br/><br/>         head                 p<br/>          |                   |<br/>          1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4<br/><br/>Step 12: return head;<br/><br/>         head<br/>          |<br/>          1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4</span></pre></div><div class="ab cl lc ld gp le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="hb hc hd he hf"><p id="e6c5" class="pw-post-body-paragraph jk jl hi jm b jn ki jp jq jr kj jt ju jv kk jx jy jz kl kb kc kd km kf kg kh hb bi translated"><em class="lj">原载于</em><a class="ae kn" href="https://alkeshghorpade.me/post/leetcode-merge-two-sorted-lists" rel="noopener ugc nofollow" target="_blank"><em class="lj">https://alkeshghorpade . me</em></a><em class="lj">。</em></p></div></div>    
</body>
</html>