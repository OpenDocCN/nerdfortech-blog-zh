<html>
<head>
<title>JAVA VIRTUAL MACHINE! 🙄</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JAVA 虚拟机！🙄</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/java-virtual-machine-8f3e223e6ca6?source=collection_archive---------15-----------------------#2021-05-03">https://medium.com/nerd-for-tech/java-virtual-machine-8f3e223e6ca6?source=collection_archive---------15-----------------------#2021-05-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="abf5" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated"><strong class="il hj">让我们来理解一下虚拟的概念。</strong></p></blockquote><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jh"><img src="../Images/d1759b5172bc8e50e7885a3f2eb029da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Opmz9ZjczRdKTFkTTQ9nA.jpeg"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">图片说明:男子参与虚拟游戏</figcaption></figure><p id="e912" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">虚拟→现实中没有“虚拟”的意思。这意味着它并不实际存在。</p><blockquote class="if ig ih"><p id="1d19" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated"><strong class="il hj">那么什么是“虚拟机”？</strong>🙄</p></blockquote><p id="a67f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">机器是帮助我们完成任务的装置。</p><p id="66fb" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">所以，<strong class="il hj"> <em class="ik">【虚拟机】</em> </strong>就是说<em class="ik">有一个机器但那不是真实的。</em></p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es ka"><img src="../Images/65351bfffb4dbbe82680325cec0c2cc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3lZYxNj6eNOSYTniaoBPow.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">图片说明:两种类型的虚拟机</figcaption></figure><blockquote class="if ig ih"><p id="a05a" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated"><strong class="il hj">让我们转到“Java 虚拟机”</strong></p></blockquote><p id="2780" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">✦ Java 虚拟机(JVM)完全是一个规范。它规定了事情应该如何做。</p><p id="0940" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">✦下载 JRE 时，JVM 自带 JRE。</p><p id="5c68" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">✦安装 JRE 的时候，会部署所有可以创建 JVM 的代码。JRE 是紧密依赖于平台的。</p><p id="248f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">✦:当我们执行一个 java 程序时，它会创建一个 JVM 实例，然后 JVM 会把字节码转换成机器码。</p><p id="49c8" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">✦没有程序执行的时间，在那个特定的时间，没有 JVM 实例在计算机上运行。(只有 JDK 和 JRE 在那里)</p><p id="12fa" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">✦:当我们启动一个 java 程序时，它会在计算机中创建一个 JVM 实例。</p><p id="ae63" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">✦:如果在那个特定的时间段，我们没有在计算机中执行任何程序，那么计算机中就没有 JVM 实例，只有 JDK 和 JRE。</p><p id="e13c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">✦:当我们启动一个 java 程序时-&gt;它会在计算机上创建一个 JVM 实例。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es kb"><img src="../Images/cd4d09ea157963c47ea1762b20ed02d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ocoqfOZN4fxz8amZ8ujt8Q.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">图片说明:java 程序如何转换成机器码</figcaption></figure><h1 id="ef87" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak">线程(线程允许程序通过同时做多件事来更有效地运行)</strong></h1><p id="8d88" class="pw-post-body-paragraph ii ij hi il b im la io ip iq lb is it jx lc iw ix jy ld ja jb jz le je jf jg hb bi translated"><em class="ik">🔵守护线程:它是一个低优先级线程，执行垃圾收集之类的任务。这个守护线程用于支持任务。</em></p><p id="1e45" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated"><em class="ik">🔵非守护线程:它类似于主线程。当 JVM 启动时- &gt;它创建非守护线程。</em></p><h1 id="ecf3" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">这个 JVM 在什么时候终止:</h1><p id="9e33" class="pw-post-body-paragraph ii ij hi il b im la io ip iq lb is it jx lc iw ix jy ld ja jb jz le je jf jg hb bi translated"><em class="ik">不存在非守护线程时的🟢。</em></p><p id="7564" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated"><em class="ik"> 🟢一个应用程序可以自杀，所以它可以调用系统的退出方法。</em></p><h1 id="bf62" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">JVM 中的组件</h1><ol class=""><li id="3dd0" class="lf lg hi il b im la iq lb jx lh jy li jz lj jg lk ll lm ln bi translated"><em class="ik">)分类装载器—装载</em></li><li id="8182" class="lf lg hi il b im lo iq lp jx lq jy lr jz ls jg lk ll lm ln bi translated"><em class="ik">)存储区—存储</em></li><li id="88dc" class="lf lg hi il b im lo iq lp jx lq jy lr jz ls jg lk ll lm ln bi translated"><em class="ik">)执行引擎—执行</em></li></ol><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es lt"><img src="../Images/faaad11b6cce24b00011062b524c1d55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*uxpRDxwmRONEKUBSlr-6vA.png"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">图片说明:JDK、JRE 和 JVM 的架构</figcaption></figure><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es lu"><img src="../Images/8cbb9e08f69f94e6c7da403a88b5c098.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DVnqRmetNKFEZrcZA8JoQA.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">图片说明:JVM 架构(参考:<a class="ae lv" href="https://javatutorial.net/jvm-explained" rel="noopener ugc nofollow" target="_blank">https://javatutorial.net/jvm-explained</a>)</figcaption></figure><blockquote class="if ig ih"><p id="6980" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated"><strong class="il hj"> <em class="hi">存储区</em> </strong></p></blockquote><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es lw"><img src="../Images/2d04e57195d1307f09da1e40a182b961.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hwIWbiAHwhnz7PNkym3_Qw.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">图片说明:JVM 的结构</figcaption></figure><p id="f04c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">🟨方法区- <em class="ik">本将保留</em> <strong class="il hj"> <em class="ik">类信息</em> </strong></p><p id="7445" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">🟨堆区- <em class="ik">这个会保存</em> <strong class="il hj"> <em class="ik">对象信息</em> </strong></p><p id="86d8" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">🟨堆栈区- <em class="ik">这将保存</em> <strong class="il hj"> <em class="ik">局部变量和方法信息</em> </strong></p><p id="7b62" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">🟨 PC Registry- <em class="ik">这应该保存 java 方法的信息，而不是本地方法的信息。它保存了关于</em> <strong class="il hj"> <em class="ik">下一次执行</em> </strong> <em class="ik">的信息，如果它不是本地方法</em></p><p id="0e0a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">🟨本地方法区- <em class="ik">提供保存信息</em> <strong class="il hj"> <em class="ik">本地方法、方法信息和其他东西</em> </strong>的设施</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es lx"><img src="../Images/786bee4d895128d1ea3c12e6b9bb73af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W6f5TYBt93CULzT5mntJ_Q.jpeg"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">图片说明:堆栈、PC 寄存器和本机方法区域之间的连接</figcaption></figure><blockquote class="if ig ih"><p id="dd56" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated"><strong class="il hj"> <em class="hi">分类器</em> </strong></p></blockquote><p id="d326" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">有两种类型的类装入器。它们是引导类加载器和自定义类加载器。</p><p id="1f19" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">Classloader 有三个阶段，<strong class="il hj"> <em class="ik">加载，链接，</em> </strong>和<strong class="il hj"> <em class="ik">初始化。</em> </strong></p><p id="e7ec" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">🔹<em class="ik">加载</em>:加载类之前，</p><p id="e092" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">〰️It 读出了完全限定的类名。</p><p id="ea5b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">〰️It 读取直系父母信息。</p><p id="9d2f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">〰️It 读取这是一个类、一个接口还是一个枚举。(枚举代表一组常数)</p><p id="083d" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">〰️It 阅读可变信息。</p><p id="a476" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">然后，它将类文件加载到内存区域。当它被加载时，JVM 从类类型创建一个对象。</p><p id="61f9" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">🔹<em class="ik">链接</em>:这又分为 3。</p><ol class=""><li id="d4d0" class="lf lg hi il b im in iq ir jx ly jy lz jz ma jg lk ll lm ln bi translated"><strong class="il hj">验证</strong>:检查这个类文件执行起来是否安全。并且 JVM 中有一个字节码验证器，从它检查的字节码验证器；</li></ol><p id="eb5e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">✬ <em class="ik">这是否来自一个有效的编译器。</em></p><p id="1403" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">✬ <em class="ik">这是否有一个正确的格式。</em></p><p id="ee1f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">✬ <em class="ik">这个类文件是否有正确的结构。</em></p><p id="6164" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">如果所有这些都不满足，它将抛出一个“验证异常”。如果成功了，下一步就是准备。</p><p id="626b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated"><strong class="il hj"> 2。准备:</strong>在这个阶段，如果我们在类中使用任何实例级变量或静态变量，它将分配默认值。</p><p id="711b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">这意味着如果它是 int，它将赋值 0，如果它是 boolean，它将赋值 false，如果它是 object，它将赋值 null。</p><p id="ae53" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated"><strong class="il hj"> 3。解决方法:</strong>在这个阶段，将<strong class="il hj"> <em class="ik">用直接链接替换符号链接。</em>T51】</strong></p><p id="f61b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">例 1: 我们有“雇员”、“学生 1”、“动物”..像物体一样。但是机器不理解那些和，它会把所有那些对象都当成<strong class="il hj"> <em class="ik">业务对象</em> </strong>或<strong class="il hj"> <em class="ik">特定领域</em> </strong>对象。由于 JVM 不理解这个雇员、学生等是谁，所以这个 JVM 在到达机器级别之前用直接链接替换了那些符号链接。</p><p id="9768" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated"><strong class="il hj">例 2: </strong> <em class="ik">员工 a =新员工()；</em></p><p id="8bc3" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">所以在这里的解析部分，它用这个新创建的 Employee 对象保留的特定内存位置来替换我们使用<em class="ik"> Employee </em>的所有地方。</p><p id="b509" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">🔹<em class="ik">初始化</em>:在这里赋实值。如果有静态块，它就会执行。每个类在被使用之前都必须被初始化。</p><p id="29be" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">有些观点认为积极使用类。</p><p id="62ee" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">1️⃣新关键词</p><p id="1b86" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">2️⃣调用静态方法</p><p id="8f97" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">3️⃣为静态字段赋值</p><p id="40da" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">如果类是初始类，则为 4️⃣(有一个 main 方法)</p><p id="c482" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">5️⃣如果使用反射 API 来加载类(getInstance)</p><p id="e43b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">6️⃣实例子类</p><p id="6546" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">如果该类符合上述任何一项，则应该通过初始化过程；如果不符合，则不需要通过初始化过程。</p><p id="1820" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated"><strong class="il hj"> <em class="ik">初始化一个类的 4 种方式:</em> </strong></p><p id="c0b6" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">✸使用新关键字</p><p id="b32e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">✸使用 clone()方法(clone()→指创建一个类对象的精确副本)</p><p id="9f9d" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">✸使用反射 API(获取实例)</p><p id="b533" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">✸使用 Io.objectinputstream 类</p><blockquote class="mb"><p id="744d" class="mc md hi bd me mf mg mh mi mj mk jg dx translated"><strong class="ak"> <em class="ml">当初始化子类时，父类得到初始化！为什么</em> ❓❓❓❓ </strong></p></blockquote><p id="45ae" class="pw-post-body-paragraph ii ij hi il b im mm io ip iq mn is it jx mo iw ix jy mp ja jb jz mq je jf jg hb bi mr translated">编译 JVM 时，为我们类的每个构造函数创建 init()方法。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es na"><img src="../Images/de7332fa18d2087304f516b7dd6b81a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*GfW5PXnxFVxB0rFLMFxhOQ.png"/></div></figure><p id="e0f3" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated"><strong class="il hj">所以“init()”有— &gt;代码来调用默认构造函数的 init 方法，有代码来初始化实例变量，最后有字节码用于特定的实现。</strong></p><p id="2330" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated"><strong class="il hj">如果构造函数中没有 this()，这时“init()”有→代码来调用父类默认构造函数的 init 方法，有代码来初始化实例变量，最后，它有字节码用于特定的实现。</strong></p><p id="acbd" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">所以在 init 方法中可以有 3 种代码，它们是</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es nb"><img src="../Images/7102a88c48d57a1ca1b0aa0a4afc35ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*sDkuZziNIlbC0_kckgOK2A.png"/></div></figure><blockquote class="if ig ih"><p id="11ee" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated"><strong class="il hj"> <em class="hi">执行引擎</em> </strong></p></blockquote><p id="4561" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">字节码的执行发生在这里。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div class="er es nb"><img src="../Images/973cb67a6ff74e812e730ad04ee2d475.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*1HsLVkYWNj-i8RZrwaQ3cA.png"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">图片说明:执行引擎的组件</figcaption></figure><p id="986c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">🔹<em class="ik">解释器</em> -读取并解释(转换)字节码为机器代码。并且一个接一个地顺序执行。</p><p id="be61" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">🔹<em class="ik"> JIT 编译器</em>——这是为了克服解释器的缺点而引入的，也就是“执行缓慢”。JIT 通过在运行时将字节码编译成本机代码来提升 java 程序的性能。</p><p id="e67e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">🔹<em class="ik">垃圾收集器</em> -它自动确定 java 程序没有使用的内存区域，并回收这些内存区域用于其他用途。</p><h1 id="d64f" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">JVM 中的数据类型</h1><p id="ea6e" class="pw-post-body-paragraph ii ij hi il b im la io ip iq lb is it jx lc iw ix jy ld ja jb jz le je jf jg hb bi translated">JVM 中有两种数据类型，分别是<strong class="il hj"> <em class="ik">原始类型</em> </strong>和<strong class="il hj"> <em class="ik">引用类型。</em> </strong></p><blockquote class="if ig ih"><p id="ca7c" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated"><strong class="il hj"> <em class="hi">图元类型</em> </strong></p></blockquote><p id="bbe3" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">它保存数据的值。有三种类型作为<strong class="il hj">数字、布尔、</strong>和<strong class="il hj">返回地址。</strong></p><p id="38d7" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">🔹<strong class="il hj"> <em class="ik">数字</em> </strong>:又分为 2 种，分别为<strong class="il hj">浮点型</strong>和<strong class="il hj">整数型。</strong></p><p id="426f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">浮动分为<strong class="il hj">浮动</strong>和<strong class="il hj">双浮动。</strong></p><p id="bb7c" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">整数分为 5 个作为<strong class="il hj">字节，Short，Int，Long，</strong>和<strong class="il hj"> Char。</strong></p><p id="09d1" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">🔹<strong class="il hj"> <em class="ik">布尔</em> </strong>:这由<strong class="il hj"> int </strong>或<strong class="il hj"> byte </strong>表示。布尔<strong class="il hj">假</strong>表示为<strong class="il hj">零</strong>而<strong class="il hj">真</strong>表示为<strong class="il hj">非零</strong>。如果它是一个<strong class="il hj">可操作的布尔型</strong>，它由<strong class="il hj"> int 值</strong>表示。如果它是布尔型的<strong class="il hj">数组，那么它被表示为字节的<strong class="il hj">数组。</strong></strong></p><p id="f4f3" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">🔹<strong class="il hj"> <em class="ik">返回地址</em> </strong>:这是<strong class="il hj">开发者无法访问的</strong>。而这是一款<strong class="il hj">具体型号来实现最终的。</strong></p><blockquote class="if ig ih"><p id="307a" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated"><strong class="il hj"> <em class="hi">引用类型</em> </strong></p></blockquote><p id="b42f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">它保存对对象的引用。有<strong class="il hj">类类型引用、</strong>对象类型引用、<strong class="il hj">数组类型引用三种类型。</strong></p><p id="e80b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">🔹<strong class="il hj"> <em class="ik">类类型引用</em> </strong>:引用类的一个实例。</p><p id="dc88" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">🔹<strong class="il hj"> <em class="ik">对象类型引用</em> </strong>:对类实现的引用。</p><p id="015d" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jx iv iw ix jy iz ja jb jz jd je jf jg hb bi translated">🔹<strong class="il hj"> <em class="ik">数组类型引用</em> </strong>:引用数组。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es nc"><img src="../Images/2e6b21793ffba2878bb86bca804c4086.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Grd39zzC3smOpH9eTRqDuw.jpeg"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">图片说明:JVM 数据类型</figcaption></figure><h1 id="6b59" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><span class="l ms mt mu bm mv mw mx my mz di">W</span><strong class="ak"><em class="ml">ord Size</em></strong></h1><p id="63e4" class="pw-post-body-paragraph ii ij hi il b im la io ip iq lb is it jx lc iw ix jy ld ja jb jz le je jf jg hb bi translated">字长只是一个基数/单位。用于表示处理器可以寻址多少内存。(至少应该有 32 位大小)。字长由特定的实现方式决定。</p><blockquote class="if ig ih"><p id="c2c8" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated"><strong class="il hj"> 2 规则决定字号</strong></p></blockquote><ol class=""><li id="f622" class="lf lg hi il b im in iq ir jx ly jy lz jz ma jg lk ll lm ln bi translated">应该能够保存任何原始数据类型。</li><li id="2523" class="lf lg hi il b im lo iq lp jx lq jy lr jz ls jg lk ll lm ln bi translated">两个单词应该能够携带长值或双精度值。</li></ol></div></div>    
</body>
</html>