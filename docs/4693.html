<html>
<head>
<title>Game Programming Pattern: Singleton</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">游戏编程模式:Singleton</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/game-programming-pattern-singleton-249cc9f11401?source=collection_archive---------14-----------------------#2021-08-02">https://medium.com/nerd-for-tech/game-programming-pattern-singleton-249cc9f11401?source=collection_archive---------14-----------------------#2021-08-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ih ii ij ik er es paragraph-image"><div class="er es ig"><img src="../Images/d1e9a4e251339b5aea88664a7e5d7863.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*mq8F0H3KwyXqnFAy.jpg"/></div></figure><p id="3214" class="pw-post-body-paragraph in io hi ip b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk hb bi translated">在我们开始为游戏的最后几个过场动画创建激活之前，让我们开始创建我们的游戏管理器，以便我们可以使用它来跟踪游戏中的某些目标，并添加更多的声音。一旦我们为游戏管理器创建了脚本，我们就可以将它附加到我们层次结构中的一个新的空对象上，并打开我们的脚本:</p><figure class="jm jn jo jp fd ik er es paragraph-image"><div class="er es jl"><img src="../Images/8afa600382678a9e048ad3b82b7b2cd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*N2nyR9JATWooLDAjeJJsaA.png"/></div></figure><p id="7196" class="pw-post-body-paragraph in io hi ip b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk hb bi translated">当我们进入脚本时，我们将开始创建我们的单例模式。如果我们使用这种类型的模式，我们需要创建一个静态变量来处理这个类:</p><figure class="jm jn jo jp fd ik er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es jq"><img src="../Images/52a0c41ea1aaf0fb5d31d9e9ad1b90fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8p2MlVwocIEgXMtP-wFpbA.png"/></div></div></figure><p id="4b65" class="pw-post-body-paragraph in io hi ip b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk hb bi translated">使用这个静态关键字，它允许每个类都可以访问这个变量。除非你有一个要实例化一次的类，否则永远不要让你的变量成为静态的。我们作为管理器类创建的任何东西，你最好把它们作为单例创建，并使用 static 关键字。现在，为了访问这个变量，我们需要创建一个属性来访问它。为此，我们可以创建一个公共静态，并赋予这个新属性新的特性:</p><figure class="jm jn jo jp fd ik er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es jq"><img src="../Images/ec639da0689315b95ffc5bd63df4df39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5bBWNSNqJAAUqtSgGr86Uw.png"/></div></div></figure><p id="eb94" class="pw-post-body-paragraph in io hi ip b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk hb bi translated">当我们创建一个属性时，我们可以对它应用 get 和 set。在这个例子中，我们不希望任何人访问它的集合，所以我们只有一个 get。为了确保在任何给定的时间场景中只有 1，我们必须对它进行空值检查，以确保游戏没有被破坏。为了分配我们的实例，我们将在游戏加载时创建它。至于第一部分，我们将使用 HasCard 属性，这样我们可以用 Unity 验证玩家收集了安全警卫卡，以实现获胜场景。当它被抓取时，我们可以进入我们的 GrabKey 脚本，并向游戏管理器表示我们已经收集了该卡。<br/>如果没有这种单例模式方法，要正常调用 bool，我们必须:</p><figure class="jm jn jo jp fd ik er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es jq"><img src="../Images/c928b4fda316662b3944357be4b729d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sJl4tPnb431DqLYjI1UeaQ.png"/></div></div></figure><p id="bd61" class="pw-post-body-paragraph in io hi ip b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk hb bi translated">然而，因为我们使用的游戏管理器有一个静态实例和正在使用的 singleton 属性，我们可以跳过所有这些多余的代码编写并简化它:</p><figure class="jm jn jo jp fd ik er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es jq"><img src="../Images/e0d033937439eed813d60c9bc6eb9ad3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B-Iz4PNnqO0qjLlWDG_LVA.png"/></div></div></figure><p id="b6ec" class="pw-post-body-paragraph in io hi ip b iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk hb bi translated">这种方法允许我们进行完全相同的调用，只是简单得多，所以以后更容易阅读代码中任何可能的错误。<br/>现在我们已经创建了我们的游戏管理器，我们可以看看如何使用它对这个场景进行最后的润色。</p></div></div>    
</body>
</html>