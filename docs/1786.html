<html>
<head>
<title>Algorithm Problem Review #3: Anagram</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法问题复习#3:字谜</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/algorithm-problem-review-2-anagram-c7264bc895f2?source=collection_archive---------8-----------------------#2021-04-06">https://medium.com/nerd-for-tech/algorithm-problem-review-2-anagram-c7264bc895f2?source=collection_archive---------8-----------------------#2021-04-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/e4ae50363d17e4c728446e61d553cb67.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*VzUtY8cXgdntDYEV3Mcqfw.png"/></div></figure><p id="a996" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">本周，我在柯尔特·斯蒂尔大学的课程中研究另一个算法问题。这是另一个频率计数器类型的问题，但这一次我的工作是看看两个字符串是否是彼此的变位。</p><h1 id="1f42" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">频率计数器—有效图形</h1><blockquote class="kj kk kl"><p id="b97e" class="im in km io b ip iq ir is it iu iv iw kn iy iz ja ko jc jd je kp jg jh ji jj hb bi translated">给定两个字符串，编写一个函数来确定第二个字符串是否是第一个字符串的变位词。变位词是通过重新排列另一个词的字母而形成的单词、短语或名称，如“cinema”由“iceman”形成</p></blockquote><h2 id="34b1" class="kq jm hi bd jn kr ks kt jr ku kv kw jv ix kx ky jz jb kz la kd jf lb lc kh ld bi translated">例子</h2><p id="7ecf" class="pw-post-body-paragraph im in hi io b ip le ir is it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj hb bi translated"><strong class="io hj">输入:</strong> string1= " "，string 2 = " "<br/>T5】输出:真</p><p id="bffc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">输入:</strong> string1="aaz "，string2="zza" <br/> <strong class="io hj">输出</strong>:假</p><p id="7a6e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">输入:</strong> string1="anagram "，string2="nagaram" <br/> <strong class="io hj">输出</strong> : true</p><p id="b869" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">输入:</strong>string 1 = " awesom "，string2="awesom" <br/> <strong class="io hj">输出</strong>:假</p><h2 id="8ae1" class="kq jm hi bd jn kr ks kt jr ku kv kw jv ix kx ky jz jb kz la kd jf lb lc kh ld bi translated">限制</h2><ul class=""><li id="78f2" class="lj lk hi io b ip le it lf ix ll jb lm jf ln jj lo lp lq lr bi translated">所有输入都是单词</li><li id="2bf9" class="lj lk hi io b ip ls it lt ix lu jb lv jf lw jj lo lp lq lr bi translated">所有输入都是小写的</li><li id="84e4" class="lj lk hi io b ip ls it lt ix lu jb lv jf lw jj lo lp lq lr bi translated">所有输入都没有空格、标点符号或数字</li></ul><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="baf8" class="kq jm hi mc b fi mg mh l mi mj"><strong class="mc hj">function validAnagram(string1, string2){</strong></span><span id="77d5" class="kq jm hi mc b fi mk mh l mi mj"><strong class="mc hj">}</strong></span></pre></div><div class="ab cl ml mm gp mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hb hc hd he hf"><h1 id="90bf" class="jl jm hi bd jn jo ms jq jr js mt ju jv jw mu jy jz ka mv kc kd ke mw kg kh ki bi translated">我的过程</h1><h2 id="6c97" class="kq jm hi bd jn kr ks kt jr ku kv kw jv ix kx ky jz jb kz la kd jf lb lc kh ld bi translated">理解问题</h2><p id="ece3" class="pw-post-body-paragraph im in hi io b ip le ir is it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj hb bi translated">在开始编码之前，让我们重申一下这个问题。我需要创建一个函数来告诉我我的两个字符串输入<strong class="io hj"> string1 </strong>和<strong class="io hj"> string2 </strong>是否是彼此的变位组合。如果它们是字谜，我的函数必须返回<strong class="io hj"> true </strong>如果它们不是字谜，我的函数必须返回<strong class="io hj"> false </strong>。我的字符串将是没有空格，数字，标点符号和所有小写字母的单词。</p><h2 id="59c9" class="kq jm hi bd jn kr ks kt jr ku kv kw jv ix kx ky jz jb kz la kd jf lb lc kh ld bi translated">分解它</h2><p id="a961" class="pw-post-body-paragraph im in hi io b ip le ir is it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj hb bi translated">是时候评论一下我需要为这个问题做的事情了。</p><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="505c" class="kq jm hi mc b fi mg mh l mi mj"><strong class="mc hj">function validAnagram(string1, string2){<br/></strong>   <br/>   <em class="km">// Do something...</em></span><span id="06da" class="kq jm hi mc b fi mk mh l mi mj">   <em class="km">/* return true if string1 and string2 are anagrams, return false otherwise */</em></span><span id="ed3f" class="kq jm hi mc b fi mk mh l mi mj"><strong class="mc hj">}</strong></span></pre><p id="222c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我在“做点什么…”部分的第一个行动计划是检查两个字符串的长度是否相同，如果不同，我将自动返回 false。然后下一步是创建一个对象，该对象具有字母<strong class="io hj"> string1 </strong>的键，以及它们在该单词中出现的次数的值。然后让另一个对象做同样的事情，但是用的是<strong class="io hj"> string2 </strong>。</p><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="8146" class="kq jm hi mc b fi mg mh l mi mj"><strong class="mc hj">function validAnagram(string1, string2){<br/></strong>   <br/>   <strong class="mc hj">if (string1.length !== string2.length){<br/>      return false<br/>   }</strong></span><span id="687d" class="kq jm hi mc b fi mk mh l mi mj"><em class="km">   // 1. Create empty objects<br/>   </em><strong class="mc hj">let stringFreq1 = {}<br/>   let stringFreq2 = {}</strong></span><span id="e129" class="kq jm hi mc b fi mk mh l mi mj">   <em class="km">// 2. Loop through string1 and then string2 to add to the objects</em></span><span id="3094" class="kq jm hi mc b fi mk mh l mi mj"><em class="km">   /* return true if string1 and string2 are anagrams, return false otherwise */</em></span><span id="0601" class="kq jm hi mc b fi mk mh l mi mj"><strong class="mc hj">}</strong></span></pre><p id="f60c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我希望我的对象看起来像这样。</p><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="7fe0" class="kq jm hi mc b fi mg mh l mi mj">EXAMPLE<br/>inputs: validAnagram('anagram', 'nagaram')</span><span id="58c0" class="kq jm hi mc b fi mk mh l mi mj">stringFreq1 = {'a':3, 'n':1, 'g':1, 'r':1, 'm': 1}<br/>stringFreq2 = {'n':1, 'a':3, 'g':1, 'r':1, 'm': 1}</span></pre><p id="8cb0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">所以这次我将使用一个<strong class="io hj"> for…of </strong>循环来遍历我的两个字符串。如果字符串中的字母已经是对象中的一个键，我将在值上加 1。如果不是，我会把它设置为 0，然后加 1。然后我将比较两个对象的键和值。</p><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="cd2b" class="kq jm hi mc b fi mg mh l mi mj"><strong class="mc hj">function validAnagram(string1, string2){<br/></strong>   <br/>   <strong class="mc hj">if (string1.length !== string2.length){<br/>      return false<br/>   }</strong></span><span id="cd48" class="kq jm hi mc b fi mk mh l mi mj"><em class="km">   // 1. Create empty objects<br/>   </em><strong class="mc hj">let stringFreq1 = {}<br/>   let stringFreq2 = {}</strong></span><span id="36f6" class="kq jm hi mc b fi mk mh l mi mj"><em class="km">   // 2. Loop through string1 and then string2 to add to the objects<br/>   </em><strong class="mc hj">for (let <em class="km">letter</em> of <em class="km">string1</em>){<br/>      stringFreq1[letter] = (stringFreq1[letter] || 0) + 1<br/>   }</strong></span><span id="4f0f" class="kq jm hi mc b fi mk mh l mi mj"><strong class="mc hj">   for (let <em class="km">letter</em> of <em class="km">string2</em>){<br/>      stringFreq2[letter] = (stringFreq2[letter] || 0) + 1<br/>   }</strong></span><span id="c2f7" class="kq jm hi mc b fi mk mh l mi mj">   <em class="km">// 3. Compare the keys and values in both objects</em></span><span id="0e98" class="kq jm hi mc b fi mk mh l mi mj"><em class="km">   /* return true if string1 and string2 are anagrams, return false otherwise */</em></span><span id="e9da" class="kq jm hi mc b fi mk mh l mi mj"><strong class="mc hj">}</strong></span></pre><p id="7ba4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在我的对象已经创建好了，我将比较两个对象中的键值，看看它们是否有完全相同的键，如果有，它将立即返回 false。如果它们没有相同的键值，那么它将立即返回 false。如果这两个测试都没有返回 false，那么它将返回 true，两个字符串都是彼此的 true 变位。</p><p id="a81b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我将在中使用<strong class="io hj">来循环我的对象</strong></p><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="fe90" class="kq jm hi mc b fi mg mh l mi mj"><strong class="mc hj">function validAnagram(string1, string2){<br/></strong>   <br/>   <strong class="mc hj">if (string1.length !== string2.length){<br/>      return false<br/>   }</strong></span><span id="0e49" class="kq jm hi mc b fi mk mh l mi mj"><em class="km">   // 1. Create empty objects<br/>   </em><strong class="mc hj">let stringFreq1 = {}<br/>   let stringFreq2 = {}</strong></span><span id="526d" class="kq jm hi mc b fi mk mh l mi mj"><em class="km">   // 2. Loop through string1 and then string2 to add to the objects<br/>   </em><strong class="mc hj">for (let <em class="km">letter</em> of <em class="km">string1</em>){<br/>      stringFreq1[letter] = (stringFreq1[letter] || 0) + 1<br/>   }</strong></span><span id="4e85" class="kq jm hi mc b fi mk mh l mi mj"><strong class="mc hj">   for (let <em class="km">letter</em> of <em class="km">string2</em>){<br/>      stringFreq2[letter] = (stringFreq2[letter] || 0) + 1<br/>   }</strong></span><span id="ad31" class="kq jm hi mc b fi mk mh l mi mj"><em class="km">   // 3. Compare the keys and values in both objects<br/>   </em><strong class="mc hj">for (let <em class="km">key</em></strong><em class="km"> </em><strong class="mc hj">in <em class="km">stringFreq1</em>){</strong></span><span id="8da4" class="kq jm hi mc b fi mk mh l mi mj">     <em class="km"> // 3a. checking if the keys of stringFreq1 are missing from   stringFreq2</em><br/>      <strong class="mc hj">if(!(<em class="km">key</em> in <em class="km">stringFreq2</em>)){<br/>         return false<br/>      }</strong></span><span id="2672" class="kq jm hi mc b fi mk mh l mi mj"><strong class="mc hj">      </strong><em class="km">// 3b. checking if the key's value of stringFreq1 is different from the key's value in stringFreq2<br/>      </em><strong class="mc hj">if (stringFreq2[key] !== stringFreq1[key]){<br/>         return false<br/>      }<br/>   }</strong></span><span id="e136" class="kq jm hi mc b fi mk mh l mi mj"><em class="km">   /* return true if string1 and string2 are anagrams, return false otherwise */<br/>   </em><strong class="mc hj">return true</strong></span><span id="e869" class="kq jm hi mc b fi mk mh l mi mj"><strong class="mc hj">}</strong></span></pre><h2 id="5586" class="kq jm hi bd jn kr ks kt jr ku kv kw jv ix kx ky jz jb kz la kd jf lb lc kh ld bi translated">解决</h2><pre class="lx ly lz ma fd mb mc md me aw mf bi"><span id="4e53" class="kq jm hi mc b fi mg mh l mi mj"><strong class="mc hj">function validAnagram(string1, string2){<br/></strong>   <br/>   <strong class="mc hj">if (string1.length !== string2.length){<br/>      return false<br/>   }</strong></span><span id="44c4" class="kq jm hi mc b fi mk mh l mi mj"><em class="km">   </em><strong class="mc hj">let stringFreq1 = {}<br/>   let stringFreq2 = {}</strong></span><span id="9492" class="kq jm hi mc b fi mk mh l mi mj"><em class="km">   </em><strong class="mc hj">for (let <em class="km">letter</em> of <em class="km">string1</em>){<br/>      stringFreq1[letter] = (stringFreq1[letter] || 0) + 1<br/>   }</strong></span><span id="7f58" class="kq jm hi mc b fi mk mh l mi mj"><strong class="mc hj">   for (let <em class="km">letter</em> of <em class="km">string2</em>){<br/>      stringFreq2[letter] = (stringFreq2[letter] || 0) + 1<br/>   }</strong></span><span id="1f71" class="kq jm hi mc b fi mk mh l mi mj"><em class="km">   </em><strong class="mc hj">for (let <em class="km">key</em></strong><em class="km"> </em><strong class="mc hj">in <em class="km">stringFreq1</em>){</strong></span><span id="f19e" class="kq jm hi mc b fi mk mh l mi mj">      <strong class="mc hj">if(!(<em class="km">key</em> in <em class="km">stringFreq2</em>)){<br/>         return false<br/>      }</strong></span><span id="6bfd" class="kq jm hi mc b fi mk mh l mi mj"><em class="km">      </em><strong class="mc hj">if (stringFreq2[key] !== stringFreq1[key]){<br/>         return false<br/>      }</strong></span><span id="8805" class="kq jm hi mc b fi mk mh l mi mj"><strong class="mc hj">   }</strong></span><span id="9ecc" class="kq jm hi mc b fi mk mh l mi mj"><em class="km">   </em><strong class="mc hj">return true</strong></span><span id="45d4" class="kq jm hi mc b fi mk mh l mi mj"><strong class="mc hj">}</strong></span></pre></div><div class="ab cl ml mm gp mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hb hc hd he hf"><h1 id="ef3f" class="jl jm hi bd jn jo ms jq jr js mt ju jv jw mu jy jz ka mv kc kd ke mw kg kh ki bi translated">我的想法</h1><p id="7278" class="pw-post-body-paragraph im in hi io b ip le ir is it lf iv iw ix lg iz ja jb lh jd je jf li jh ji jj hb bi translated">这是一个相当简单的问题，它帮助我加强了对对象的处理，避免了与某件事情的频率有关的嵌套循环问题。这个函数有一个 O(n)的 O 符号，这是相当不错的。</p></div><div class="ab cl ml mm gp mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="hb hc hd he hf"><h1 id="fb30" class="jl jm hi bd jn jo ms jq jr js mt ju jv jw mu jy jz ka mv kc kd ke mw kg kh ki bi translated">编码快乐！</h1><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="er es mx"><img src="../Images/f2d1f6744400d36cba3b7fd1e5d3d784.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nGTi_guUq0hLh645"/></div></div><figcaption class="nc nd et er es ne nf bd b be z dx translated">照片由<a class="ae jk" href="https://unsplash.com/@dtbosse?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丹尼尔·托马斯</a>在<a class="ae jk" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure></div></div>    
</body>
</html>