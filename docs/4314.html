<html>
<head>
<title>Figuring out Steps on a Grid</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计算网格上的步骤</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/figuring-out-steps-on-a-grid-927c1c42bda6?source=collection_archive---------10-----------------------#2021-07-15">https://medium.com/nerd-for-tech/figuring-out-steps-on-a-grid-927c1c42bda6?source=collection_archive---------10-----------------------#2021-07-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/6cec31d2e5916ae3214eea5e2d418189.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/1*XQpw_JBBwMh-al3SGERBDg.gif"/></div></figure><p id="62b9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当和一个学生一起复习时，我们遇到了一个难题，这个难题把他们难住了。</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es jk"><img src="../Images/37f1a39123c976f43953007bb2baebad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6hfrfPZvSnfJo5lenxKQhQ.png"/></div></div></figure><p id="00ee" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们花了几分钟解开这个问题，但我很快就看出这是“出租车出租车”的问题(又名曼哈顿距离)。</p><p id="2083" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">出租车问题可以归结为“一辆出租车从 A 点到 B 点要经过多少个街区？”这是一个经典的距离问题。通常，在编码中，我们计算两点之间的直线距离，“直线距离”。但是这对于一辆不能在建筑物中行驶的出租车不起作用，因为它不得不像街道一样贴着格子行驶。那么“最短”路线就变成了几个相等的距离，加起来就是连接两点的直角三角形。正如你在上面的 GIF 中看到的，所有这些不同的路线都等于相同的行驶距离。</p><p id="79c1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">那么，我们如何将它分解成代码呢？</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es jt"><img src="../Images/56ca96e4d4d14e2076991368bb8e9238.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G_55fsRE2rt4Z7ZEYiSZuQ.png"/></div></div></figure><p id="c545" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">计算的核心是水平距离加上垂直距离等于曼哈顿距离。因为我们和不懂的计算机打交道，所以我们确保得到玩家 X 和目标 X 之差的绝对值，对于 Y 坐标也是如此。</p><p id="d5cb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">至于设置网格，这需要更多的工作。让我们研究一下更简单的非包装版本。</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es jt"><img src="../Images/53150c9cefc2f13a7ba441aace4b0cc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yjdzQlTm4nwyycvhRVWT2w.png"/></div></div></figure><p id="c3db" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">访问字符串的方式与访问数组类似，可以提取单个字符。因此，我们使用矩阵数组长度中的第一项来找出新的二维数组将有多少列。和矩阵的长度来计算我们需要多少行。我们在第 5 行使用它们将 2D 数组初始化为正确的大小。</p><p id="a3b7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后，在一个嵌套的 For 循环中，我们将对 X 行使用一个 Item，并用 Y 循环遍历它的字符以填充列。</p><p id="d8d9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因为我们已经循环通过每个字符，将它插入到我们的网格数组中，我们可以利用这个机会来计算网格中有多少敌人的 2。因为我们使用的是 Unity 库，我们可以初始化一个 Vector2s 的数组。如果你没有这个奢侈，你会想要创建一个结构或者类来控制敌人在网格中的位置。(我将在下面贴出我全部代码和修订版。)</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es ju"><img src="../Images/6188529c0dc90daa923e60da0df04bbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jYqCfeRvHVNoCUwm8HSqDg.png"/></div></div></figure><p id="36a3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">至于那些目标，现在是时候获取它们的位置并存储它们以供以后检查。我们以前不能这样做，因为我们需要敌人的总数来初始化阵列。优化的一个选择是使用列表。</p><p id="4186" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">需要注意的一点是，当使用多维数组(比如 2D 数组)时，您需要使用 GetLength(x)来查找特定轴的长度。</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es jv"><img src="../Images/a8b4cab97757d3da25135f2113b20bf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YRCIsH5D-a1LWGxem43jlw.png"/></div></div></figure><p id="f278" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们使用了一个类似的方法来追踪玩家的位置。</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es jw"><img src="../Images/54f15d566243a2b732c7421d65c2e82e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lpEPKT-uo6vkgPO0JEiXQQ.png"/></div></div></figure><p id="5877" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在来完整地实现一下计算曼哈顿距离的数学方法。</p><p id="6630" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先，我们需要设置一个大到不合理的数字作为我们的“最佳解决方案”。由于我们只有一个玩家，我们现在也可以为干净的代码分配他们的 X/Y。</p><p id="b4bc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后我们可以循环我们发现了哪些敌人，并计算他们离玩家的距离。接下来，我们将组合距离与当前最佳距离进行比较。如果更好，我们将其分配到最佳步骤。</p><p id="5677" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一旦我们完成了所有的敌人，我们检查最好的是否比之前的“太大”的数字更好。这让我们在没有敌人的情况下处理案件。</p><p id="5365" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我发现如何快速简单地检查换行，是创建一个超级网格，而不是默认网格。超级网格是由九个较小的网格拼接而成的网格。然后当我们找到玩家时，我们只搜索中心网格。正如所承诺的，不使用 Unity 库检查包装网格的完整代码。</p><figure class="jl jm jn jo fd ij er es paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="er es jx"><img src="../Images/3fa8137b6c4da451d6314fb8e41e133d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qjvj1RFFvI_uDD1tRz8PkQ.png"/></div></div></figure></div></div>    
</body>
</html>