<html>
<head>
<title>React Native App Performance- PART 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应原生应用性能-第 1 部分</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/react-native-app-performance-part-1-ea218dac23ee?source=collection_archive---------12-----------------------#2021-06-27">https://medium.com/nerd-for-tech/react-native-app-performance-part-1-ea218dac23ee?source=collection_archive---------12-----------------------#2021-06-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f2c852efc6875e09768e1318cc4aef4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MQGGCqSGDWnR1dRnUidiJg.png"/></div></div></figure><p id="1c34" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">React Native 是一项受工程师欢迎的技术，工程师希望在不牺牲本机性能的情况下高效地构建移动应用程序。</p><p id="3730" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我将分享我在 React Native 中应该注意的性能问题方面的经验。这些都是基于 Avalon  使用 React Native 在<a class="ae jo" href="https://www.scenes.social/" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">场景构建大型表演移动应用的经验。我将强调常见的陷阱，并对可能出错的地方以及如何解决问题给出一个大致的理解。</strong></a></p><h1 id="4f06" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">1.删除源代码中的控制台语句</h1><p id="3732" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">一般来说，使用<code class="du ks kt ku kv b">console.log</code>语句是 JavaScript 应用程序以及 React 本地应用程序中最常见的调试方法之一。然而，在为平台构建 React 本机应用程序时，将控制台语句留在源代码中可能会导致 JavaScript 线程中的一些大瓶颈。</p><p id="8356" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">跟踪控制台语句并删除它们的一种方法是使用名为<code class="du ks kt ku kv b">babel-plugin-transform-remove-console</code>的第三方包。要使用它，请在终端窗口中使用以下命令安装该软件包:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="4a54" class="le jq hi kv b fi lf lg l lh li">yarn add babel-plugin-transform-remove-console</span></pre><p id="1f9b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，修改<code class="du ks kt ku kv b">.babelrc</code>文件以删除所有控制台语句:</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="3ff5" class="le jq hi kv b fi lf lg l lh li">{<br/>  "env": {<br/>    "production": {<br/>      "plugins": ["transform-remove-console"]<br/>    }<br/>  }<br/>}</span></pre><h1 id="880b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">2.使用图像缓存解决方案</h1><p id="2fa3" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">React Native 提供了一个<a class="ae jo" href="https://reactnative.dev/docs/image" rel="noopener ugc nofollow" target="_blank"> Image </a>组件，作为其核心组件的一部分。该组件用于显示图像，但是，开箱即用时，它没有针对以下问题的解决方案:</p><ul class=""><li id="588c" class="lj lk hi is b it iu ix iy jb ll jf lm jj ln jn lo lp lq lr bi translated">在一个屏幕上呈现大量图像</li><li id="3e0b" class="lj lk hi is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr bi translated">总体表现不佳</li><li id="ae14" class="lj lk hi is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr bi translated">从缓存进行低性能加载</li><li id="5e0f" class="lj lk hi is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr bi translated">闪烁的</li></ul><p id="106d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">React Native 中的图像组件像 web 浏览器一样处理缓存图像，这有时是导致上述问题的原因。通过使用名为<a class="ae jo" href="https://github.com/DylanVann/react-native-fast-image" rel="noopener ugc nofollow" target="_blank">react-native-fast-image</a>的第三方库，可以轻松解决这些问题。它适用于 iOS 和 Android，在缓存图像方面效率很高。</p><h1 id="a33e" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">3.使用合适的图像尺寸</h1><p id="ce88" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">如果应用程序依赖于使用大量图像，优化图像对于 React 本机应用程序的性能非常重要。如果图像的大小没有适当优化，渲染大量图像可能会导致设备上的高内存使用率。这可能会导致应用程序崩溃。</p><p id="39f0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在 React 本机应用程序中优化图像可以做的一些事情包括:</p><ul class=""><li id="f445" class="lj lk hi is b it iu ix iy jb ll jf lm jj ln jn lo lp lq lr bi translated">使用图标字体而不是图像图标。您可以使用图标字体生成器，如<a class="ae jo" href="https://fontello.com/" rel="noopener ugc nofollow" target="_blank"> Fontello </a>进行转换。</li><li id="6c1e" class="lj lk hi is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr bi translated">使用较小尺寸的图像。</li><li id="5b08" class="lj lk hi is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr bi translated">对图像使用 WEBP 格式。可以帮助<a class="ae jo" rel="noopener" href="/@tgpski/react-native-webp-reducing-bundle-binary-sizes-increase-speed-with-webp-image-format-aa9b1aa11405">将 iOS 和 Android 上的二进制大小</a>减少 29%。</li></ul><h1 id="736c" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">4.避免不必要的渲染</h1><p id="151a" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">React Native 基于 React 库，以与 React.js 相似的方式处理渲染组件。因此，对 React 有效的优化技术也适用于 React Native 应用程序。一种优化技术是避免不必要的渲染，在功能组件中，这可以通过使用<code class="du ks kt ku kv b">React.memo()</code>来实现。</p><p id="c6e7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du ks kt ku kv b">React.memo()</code>用于处理记忆化。记忆化的概念描述如下:如果一个组件不止一次地接收同一组道具，它将使用先前缓存的道具，并且只呈现一次由功能组件返回的 JSX。</p><p id="6b5e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，考虑以下父组件和子组件。<code class="du ks kt ku kv b">Parent</code>组件有一个名为<code class="du ks kt ku kv b">count</code>的状态变量，当按钮被按下时该变量会更新。</p><p id="cd3e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">每当按下按钮时，<code class="du ks kt ku kv b">Child</code>组件也会被重新渲染，即使它的属性<code class="du ks kt ku kv b">text</code>在每次渲染时不会改变。它没有对它的父组件做任何特殊的事情，只是显示一些文本。这可以通过用<code class="du ks kt ku kv b">React.memo()</code>包装<code class="du ks kt ku kv b">Child</code>组件的内容来优化。</p><pre class="kw kx ky kz fd la kv lb lc aw ld bi"><span id="4c35" class="le jq hi kv b fi lf lg l lh li">// Parent.js</span><span id="ac9b" class="le jq hi kv b fi lx lg l lh li">const Parent = () =&gt; {<br/>  const [count, setCount] = useState(0);</span><span id="18ee" class="le jq hi kv b fi lx lg l lh li">  return (<br/>    &lt;View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}&gt;<br/>      &lt;Button title='Click' onPress={() =&gt; setCount(count + 1)} /&gt;<br/>      &lt;Child content='Dummy text' /&gt;<br/>    &lt;/View&gt;<br/>  );<br/>};</span><span id="4941" class="le jq hi kv b fi lx lg l lh li">// Child.js<br/>const Child = React.Memo(({ content }) =&gt; {<br/>  return &lt;Text&gt;{content}&lt;/Text&gt;;<br/>});</span></pre><p id="3781" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意:如无必要，不要使用<code class="du ks kt ku kv b">React.memo()</code>。查看何时使用备忘录。</p><h1 id="2dde" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">摘要</h1><p id="1ac3" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">构建一个高性能的 React 本地应用并不总是简单的。通常你应该从简单的方法开始，但是如果你开始注意到你的应用程序的性能问题，总是要考虑过桥的次数。</p></div></div>    
</body>
</html>