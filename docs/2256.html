<html>
<head>
<title>Search in threads — Forum GraphQL Powered API in Laravel — [Part 4]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在线程中搜索 Laravel 中的论坛 GraphQL 驱动的 API 第 4 部分]</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/search-in-threads-forum-graphql-powered-api-in-laravel-part-4-ead4ed28b70f?source=collection_archive---------14-----------------------#2021-04-28">https://medium.com/nerd-for-tech/search-in-threads-forum-graphql-powered-api-in-laravel-part-4-ead4ed28b70f?source=collection_archive---------14-----------------------#2021-04-28</a></blockquote><div><div class="dt gx gy gz ha hb"/><div class="hc hd he hf hg"><div class=""/><p id="b0c3" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">为此，我们将使用 Laravel scout，但我们不会使用 Algolia 搜索引擎，我们将使用 MySql 作为驱动程序。</p><p id="9182" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">那么什么是拉勒维尔童军:</p><blockquote class="je jf jg"><p id="0ea4" class="ig ih jh ii b ij ik il im in io ip iq ji is it iu jj iw ix iy jk ja jb jc jd hc bi translated">Laravel Scout 提供了一个简单的、基于驱动程序的解决方案，为您的<a class="ae jl" href="https://laravel.com/docs/8.x/eloquent" rel="noopener ugc nofollow" target="_blank">雄辩模型</a>添加全文搜索。使用模型观察员，Scout 将自动保持您的搜索索引与您的雄辩记录同步。目前，侦察兵飞船有一个<a class="ae jl" href="https://www.algolia.com/" rel="noopener ugc nofollow" target="_blank"> Algolia </a>驾驶员；然而，编写自定义驱动程序很简单，您可以自由地用自己的搜索实现来扩展 Scout。</p></blockquote></div><div class="ab cl jm jn gq jo" role="separator"><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr"/></div><div class="hc hd he hf hg"><h2 id="00cc" class="jt ju hj bd jv jw jx jy jz ka kb kc kd ir ke kf kg iv kh ki kj iz kk kl km kn bi translated">什么是 MySql <strong class="ak">全文搜索</strong></h2><p id="bf51" class="pw-post-body-paragraph ig ih hj ii b ij ko il im in kp ip iq ir kq it iu iv kr ix iy iz ks jb jc jd hc bi translated">全文搜索是一种搜索不完全符合搜索条件的文档的技术。文档是包含文本数据的数据库实体，例如产品描述、博客文章和文章。</p><p id="8bf2" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">例如，您可以搜索<code class="dv kt ku kv kw b">Water and Oil</code>，<strong class="ii hk">全文搜索</strong>可以返回单独包含所搜索单词的结果，只返回<code class="dv kt ku kv kw b">Water</code>或<code class="dv kt ku kv kw b">Oil</code>，或者返回包含顺序不同的单词的结果<code class="dv kt ku kv kw b">Water and Oil</code>或<code class="dv kt ku kv kw b">Water and Oil</code>。</p><h2 id="52cc" class="jt ju hj bd jv jw jx jy jz ka kb kc kd ir ke kf kg iv kh ki kj iz kk kl km kn bi translated">MySQL 全文搜索功能:</h2><ul class=""><li id="e335" class="kx ky hj ii b ij ko in kp ir kz iv la iz lb jd lc ld le lf bi translated">类似 SQL 的本机接口</li><li id="318f" class="kx ky hj ii b ij lg in lh ir li iv lj iz lk jd lc ld le lf bi translated">完全动态索引—每当文本列的数据发生变化时，MySQL 都会自动更新该列的索引。</li><li id="84d8" class="kx ky hj ii b ij lg in lh ir li iv lj iz lk jd lc ld le lf bi translated">适度的索引大小——<code class="dv kt ku kv kw b">FULLTEXT</code>索引的大小相对较小。</li></ul><p id="60c7" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">MySql 全文搜索是通过<strong class="ii hk"> MATCH( ) </strong>函数执行的:</p><pre class="ll lm ln lo fe lp kw lq lr aw ls bi"><span id="66af" class="jt ju hj kw b fj lt lu l lv lw">SELECT * FROM threads WHERE MATCH (title,body) AGAINST ('database');</span></pre><p id="0991" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated"><strong class="ii hk"> MATCH( ) </strong>函数针对文本集合(包含在<strong class="ii hk"> FULLTEXT </strong>索引中的一个或多个列的集合)执行字符串的自然语言搜索。搜索字符串作为参数提供给<strong class="ii hk">对抗()</strong>。搜索以不区分大小写的方式执行。对于表中的每一行，<strong class="ii hk"> MATCH( ) </strong>返回一个相关性值，即搜索字符串与在<strong class="ii hk"> MATCH( ) </strong>列表中命名的列中的该行中的文本之间的相似性度量。</p><p id="8f27" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">返回的行将自动排序，相关性最高的排在最前面。相关性值是非负浮点数。零相关性意味着没有相似性。</p><p id="dc2a" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">布尔全文搜索功能支持以下运算符:</p><ul class=""><li id="edfc" class="kx ky hj ii b ij ik in io ir lx iv ly iz lz jd lc ld le lf bi translated"><strong class="ii hk"> + </strong> —包含，该词必须存在。</li><li id="737a" class="kx ky hj ii b ij lg in lh ir li iv lj iz lk jd lc ld le lf bi translated"><strong class="ii hk">–</strong>—排除，这个词一定不能出现。</li><li id="b588" class="kx ky hj ii b ij lg in lh ir li iv lj iz lk jd lc ld le lf bi translated"><strong class="ii hk"> &gt; </strong> — <strong class="ii hk"> </strong>包含，并增加排名值。</li><li id="76fb" class="kx ky hj ii b ij lg in lh ir li iv lj iz lk jd lc ld le lf bi translated"><strong class="ii hk"> &lt; </strong> —包含，减少排名值。</li><li id="6462" class="kx ky hj ii b ij lg in lh ir li iv lj iz lk jd lc ld le lf bi translated">* <strong class="ii hk"> </strong>星号是截断符。与其他操作符不同，它应该被<strong class="ii hk">附加到单词的</strong>后面，而不是前置。</li></ul><h2 id="3a3d" class="jt ju hj bd jv jw jx jy jz ka kb kc kd ir ke kf kg iv kh ki kj iz kk kl km kn bi translated">全文限制</h2><ul class=""><li id="66c6" class="kx ky hj ii b ij ko in kp ir kz iv la iz lb jd lc ld le lf bi translated">除非在布尔模式下<strong class="ii hk"> MATCH( ) </strong>为<strong class="ii hk">，否则<strong class="ii hk"> MATCH( ) </strong>函数的所有参数必须是来自同一个表的列，该表是同一个<strong class="ii hk">全文本</strong>索引的一部分。</strong></li><li id="5a3d" class="kx ky hj ii b ij lg in lh ir li iv lj iz lk jd lc ld le lf bi translated"><strong class="ii hk"> MATCH( ) </strong>列列表必须与表的某个<strong class="ii hk">全文</strong>索引定义中的列列表完全匹配，除非这个<strong class="ii hk"> MATCH( ) </strong>在布尔模式下是<strong class="ii hk">。</strong></li><li id="3caa" class="kx ky hj ii b ij lg in lh ir li iv lj iz lk jd lc ld le lf bi translated"><strong class="ii hk">对()</strong>的参数必须是常量字符串。</li></ul><p id="8141" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">有了基本的方法，我们需要配置我们的应用程序。为此，我们将使用 laravel scout 库并为其安装 mysql 驱动程序。为此，我们需要运行以下命令:</p><pre class="ll lm ln lo fe lp kw lq lr aw ls bi"><span id="8f55" class="jt ju hj kw b fj lt lu l lv lw">composer require laravel/scout<br/>composer require yab/laravel-scout-mysql-driver</span><span id="c8ec" class="jt ju hj kw b fj ma lu l lv lw">php artisan vendor:publish -- select the option with scout.</span></pre><p id="5a02" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">在<code class="dv kt ku kv kw b">config/scout.php</code>中，我们需要添加如下所示的驱动程序:</p><pre class="ll lm ln lo fe lp kw lq lr aw ls bi"><span id="7f5d" class="jt ju hj kw b fj lt lu l lv lw">'mysql' =&gt; [<br/>    'mode' =&gt; 'NATURAL_LANGUAGE',<br/>    'model_directories' =&gt; [app_path()],<br/>    'min_search_length' =&gt; 0,<br/>    'min_fulltext_search_length' =&gt; 4,<br/>    'min_fulltext_search_fallback' =&gt; 'LIKE',<br/>    'query_expansion' =&gt; false<br/>]</span></pre><p id="617d" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">因此，在每个需要使用搜索功能的模型中，我们都需要使用<code class="dv kt ku kv kw b">Searchable</code>:</p><pre class="ll lm ln lo fe lp kw lq lr aw ls bi"><span id="95b0" class="jt ju hj kw b fj lt lu l lv lw">class Thread extends Model<br/>{<br/>    use HasFactory;<br/><br/>    use Searchable;</span><span id="4858" class="jt ju hj kw b fj ma lu l lv lw">    ...<br/>}</span></pre><p id="2d9d" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">在我们的模型中添加之后，我们需要创建索引，为此我们需要运行以下命令:</p><pre class="ll lm ln lo fe lp kw lq lr aw ls bi"><span id="9c70" class="jt ju hj kw b fj lt lu l lv lw">php artisan scout:mysql-index App\\Models\\Thread</span></pre><p id="5735" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">现在让我们定义我们的查询，并将其映射到我们的应用程序中:</p><p id="b4ce" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">询问</p><pre class="ll lm ln lo fe lp kw lq lr aw ls bi"><span id="b033" class="jt ju hj kw b fj lt lu l lv lw">searchThreads(query: String): [Thread!]!</span></pre><p id="fd86" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">应用代码</p><pre class="ll lm ln lo fe lp kw lq lr aw ls bi"><span id="95f4" class="jt ju hj kw b fj lt lu l lv lw">use GraphQL\Type\Definition\Type;<br/>use Rebing\GraphQL\Support\Query;<br/>use GraphQL;<br/><br/>class SearchThreads extends Query<br/>{<br/><br/>    public function type(): Type<br/>    {<br/>        return Type::<em class="jh">nonNull</em>(Type::<em class="jh">listOf</em>(Type::<em class="jh">nonNull</em>(GraphQL::<em class="jh">type</em>('Thread'))));<br/>    }<br/><br/>    public function args(): array<br/>    {<br/>        return [<br/>            'query' =&gt; [<br/>                'name' =&gt; 'query',<br/>                'type' =&gt; Type::<em class="jh">string</em>(),<br/>            ]<br/>        ];<br/>    }<br/>}</span></pre><p id="4aaf" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">为了保持代码的整洁，我们需要创建一个处理数据操作的类。为此，我们将使用一个存储库，它将是模型之上的层，它将处理不同的。对于我们的情况，它将处理搜索。</p><p id="2ee0" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">为了获得更精确的搜索，我们需要清理用户输入的查询，并添加一些我们之前说过的操作符。首先我们需要做的是清理查询中小于 3 个字符的单词。对于查询中的每个单词，我们将附加*和+这样的东西:<code class="dv kt ku kv kw b">*apple+</code></p><p id="6b00" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">为此，我们创建了以下函数:</p><pre class="ll lm ln lo fe lp kw lq lr aw ls bi"><span id="32ae" class="jt ju hj kw b fj lt lu l lv lw">protected function fullTextWildcards(string $term): string<br/>{<br/>    // removing symbols used by MySQL<br/>    $reservedSymbols = ['-', '+', '&lt;', '&gt;', '@', '(', ')', '~'];<br/>    $term = str_replace($reservedSymbols, '', $term);<br/><br/>    $words = explode(' ', $term);<br/><br/>    foreach($words as $key =&gt; $word) {<br/>        if(strlen($word) &gt;= 3) {<br/>            $words[$key] = '+' . $word . '*';<br/>        }<br/>    }<br/><br/>    $searchTerm = implode( ' ', $words);<br/><br/>    return $searchTerm;<br/>}</span></pre><p id="9dde" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">我们的 ThreadRepository 类将如下所示:</p><pre class="ll lm ln lo fe lp kw lq lr aw ls bi"><span id="e782" class="jt ju hj kw b fj lt lu l lv lw">class ThreadRepository implements ThreadRepositoryInterface<br/>{<br/>    protected Thread $model;<br/><br/>    public function __construct(Thread $model)<br/>    {<br/>        $this-&gt;model = $model;<br/>    }<br/><br/>    public function search(string $query): Collection<br/>    {<br/>        $query = $this-&gt;fullTextWildcards($query);<br/><br/>        return $this-&gt;model-&gt;search($query)-&gt;get();<br/>    }<br/><em class="jh"><br/>    </em>protected function fullTextWildcards(string $term): string<br/>    {<br/>        $reservedSymbols = ['-', '+', '&lt;', '&gt;', '@', '(', ')', '~'];<br/>        $term = str_replace($reservedSymbols, '', $term);<br/><br/>        $words = explode(' ', $term);<br/><br/>        foreach($words as $key =&gt; $word) {<br/>            <br/>            if(strlen($word) &gt;= 3) {<br/>                $words[$key] = '+' . $word . '*';<br/>            }<br/>        }<br/><br/>        $searchTerm = implode( ' ', $words);<br/><br/>        return $searchTerm;<br/>    }<br/>}</span></pre><p id="93ed" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">修改后的 MySql 查询如下所示:</p><pre class="ll lm ln lo fe lp kw lq lr aw ls bi"><span id="db46" class="jt ju hj kw b fj lt lu l lv lw"><strong class="kw hk">select *, MATCH(body,slug,title) AGAINST("+Doloremque* +voluptates*" IN NATURAL LANGUAGE MODE) AS relevance from `threads` where MATCH(body,slug,title) AGAINST("+Doloremque* +voluptates*" IN NATURAL LANGUAGE MODE)</strong></span></pre><p id="86c2" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">这样一来，我们需要我们的 graphql 查询类看起来如下所示:</p><pre class="ll lm ln lo fe lp kw lq lr aw ls bi"><span id="fdc4" class="jt ju hj kw b fj lt lu l lv lw">class SearchThreads extends Query<br/>{<br/>    protected ThreadRepositoryInterface $threadRepository;<br/><br/>    public function __construct(ThreadRepositoryInterface $threadRepository)<br/>    {<br/>        $this-&gt;threadRepository = $threadRepository;<br/>    }<br/><br/>    public function type(): Type<br/>    {<br/>        return Type::<em class="jh">nonNull</em>(Type::<em class="jh">listOf</em>(Type::<em class="jh">nonNull</em>(GraphQL::<em class="jh">type</em>('Thread'))));<br/>    }<br/><br/>    public function args(): array<br/>    {<br/>        return [<br/>            'query' =&gt; [<br/>                'name' =&gt; 'query',<br/>                'type' =&gt; Type::<em class="jh">string</em>(),<br/>            ]<br/>        ];<br/>    }<br/><br/>    public function resolve($root, $args, $context, ResolveInfo $resolveInfo, Closure $getSelectFields)<br/>    {<br/>        return $this-&gt;threadRepository-&gt;search($args['query']);<br/>    }<br/>}</span></pre><figure class="ll lm ln lo fe mc es et paragraph-image"><div role="button" tabindex="0" class="md me di mf bf mg"><div class="es et mb"><img src="../Images/1a4c47e0103f341001d9139031579b3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Axq3VGhUdLt075MbHaKcag.png"/></div></div></figure></div><div class="ab cl jm jn gq jo" role="separator"><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr js"/><span class="jp bw bk jq jr"/></div><div class="hc hd he hf hg"><p id="6d16" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">回购链接:<a class="ae jl" href="https://github.com/mihaisolomon/forum-app" rel="noopener ugc nofollow" target="_blank">https://github.com/mihaisolomon/forum-app</a></p><p id="ea84" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">第 1 部分:<a class="ae jl" href="https://solomons.work/build-a-forum-with-graphql-powered-api-in-laravel-part-1-de032d13d628" rel="noopener ugc nofollow" target="_blank">用 GraphQL 驱动的 API 构建一个论坛——构建我们的第一个查询和变异。</a></p><p id="ebf0" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">第 2 部分:<a class="ae jl" rel="noopener" href="/nerd-for-tech/build-a-forum-with-graphql-powered-api-in-laravel-part-2-auth-ede9b57a3cf0">用 GraphQL 驱动的 API 构建一个论坛——用 passport 进行用户认证</a></p><p id="bc4a" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">第 3 部分:<a class="ae jl" rel="noopener" href="/nerd-for-tech/build-a-forum-with-graphql-powered-api-in-laravel-part-3-channels-threads-and-replies-bd7423ee1c98">在 Laravel 中用 GraphQL Powered API 构建一个论坛—【第 3 部分】通道、线程和回复</a></p><p id="4833" class="pw-post-body-paragraph ig ih hj ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hc bi translated">第四部分:<a class="ae jl" href="https://solomons.work/search-in-threads-forum-graphql-powered-api-in-laravel-part-4-ead4ed28b70f" rel="noopener ugc nofollow" target="_blank">线程中的搜索—论坛 GraphQL 提供的 Laravel 中的 API【第四部分】</a></p></div></div>    
</body>
</html>