<html>
<head>
<title>Buy Me That Look ..!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">给我买那个表情..！</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/buy-me-that-look-f003e855c692?source=collection_archive---------10-----------------------#2021-04-13">https://medium.com/nerd-for-tech/buy-me-that-look-f003e855c692?source=collection_archive---------10-----------------------#2021-04-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7fa36774e0e5749f1f31eaf24e2eec7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pzXaRi5bSOoa26cYJeJm5Q.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">时尚</figcaption></figure><blockquote class="iu"><p id="c7af" class="iv iw hi bd ix iy iz ja jb jc jd je dx translated">"除非有人穿上衣服，否则衣服毫无意义。"</p></blockquote><blockquote class="jf jg jh"><p id="6a69" class="ji jj jk jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf je hb bi translated">这是端到端时尚推荐引擎的第二部分。在第一部分，我讨论了直到掩模RCNN模型。在这一部分，我将继续其余章节的讨论。我建议先看第一部分，再看这一部分。以下是第一部分的链接:<a class="ae kg" href="https://ranveersachin143.medium.com/buy-me-that-look-5473444b1f2d" rel="noopener"><em class="hi">https://ranveersachin 143 . medium . com/buy-me-that-look-5473444 B1 f2d</em></a></p></blockquote><h2 id="dee0" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">目录:</h2><ul class=""><li id="b16d" class="lf lg hi jl b jm lh jq li ks lj kw lk la ll je lm ln lo lp bi translated">引言。</li><li id="18bc" class="lf lg hi jl b jm lq jq lr ks ls kw lt la lu je lm ln lo lp bi translated">商业问题。</li><li id="7dc4" class="lf lg hi jl b jm lq jq lr ks ls kw lt la lu je lm ln lo lp bi translated">文献综述。</li><li id="9d87" class="lf lg hi jl b jm lq jq lr ks ls kw lt la lu je lm ln lo lp bi translated">数据概述和DL公式。</li><li id="5b22" class="lf lg hi jl b jm lq jq lr ks ls kw lt la lu je lm ln lo lp bi translated">损失函数。</li><li id="af29" class="lf lg hi jl b jm lq jq lr ks ls kw lt la lu je lm ln lo lp bi translated">掩模RCNN模型。</li><li id="c99c" class="lf lg hi jl b jm lq jq lr ks ls kw lt la lu je lm ln lo lp bi translated">三元网络模型。</li><li id="d65d" class="lf lg hi jl b jm lq jq lr ks ls kw lt la lu je lm ln lo lp bi translated">预测。</li><li id="752e" class="lf lg hi jl b jm lq jq lr ks ls kw lt la lu je lm ln lo lp bi translated">部署。</li><li id="86e5" class="lf lg hi jl b jm lq jq lr ks ls kw lt la lu je lm ln lo lp bi translated">未来的工作。</li><li id="8cf7" class="lf lg hi jl b jm lq jq lr ks ls kw lt la lu je lm ln lo lp bi translated">未来连接的配置文件。</li><li id="dda8" class="lf lg hi jl b jm lq jq lr ks ls kw lt la lu je lm ln lo lp bi translated">参考文献。</li></ul><h1 id="873a" class="lv ki hi bd kj lw lx ly kn lz ma mb kr mc md me kv mf mg mh kz mi mj mk ld ml bi translated">7.三元网络模型</h1><p id="e515" class="pw-post-body-paragraph ji jj hi jl b jm lh jo jp jq li js jt ks mm jw jx kw mn ka kb la mo ke kf je hb bi translated">三元网络是著名的暹罗网络的变体。暹罗网络使用共享权重来计算不同输入的结果。三元组网络由锚、阳性样本和阴性样本组成。在我们的例子中，对于任何给定的产品类别，锚定图像是产品所在街道图像的裁剪区域，而正片是同一产品的目录图像，负片是同一产品但具有不同设计、质地、颜色、品牌和尺寸的目录图像。如下图所示，三元组通过网络传播，其想法是有3个相同的网络，具有相同的神经网络架构。最后一层是平面层，这些层的输出是三元组的嵌入。</p><pre class="mp mq mr ms fd mt mu mv mw aw mx bi"><span id="6ae9" class="kh ki hi mu b fi my mz l na nb">Input : (anchor_image, pos_image, neg_image)<br/>Output : (achor_embedding, pos_embedding, neg_embedding)</span></pre><figure class="mp mq mr ms fd ij er es paragraph-image"><div class="er es nc"><img src="../Images/33f1924ba1a1fcd6bf2083edfa62b955.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*HgDrkDzpU3hE00OCiGIiwQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">三元网络</figcaption></figure><p id="1ea9" class="pw-post-body-paragraph ji jj hi jl b jm nd jo jp jq ne js jt ks nf jw jx kw ng ka kb la nh ke kf je hb bi translated">在这些嵌入中，我们定义了一个损失函数(如前所述)。网络应该使用反向传播算法来最小化损失函数。我们希望，当模型完成训练时，它将产生嵌入(大小为d ),这样，在某些方面(颜色、纹理、设计、大小)相似的产品应该放置得更近，而不相似的产品应该放置在“d”维欧几里得空间中。我们将使用这些嵌入来获得给定产品的推荐。</p><h2 id="79a6" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">7.1]数据描述</h2><p id="48db" class="pw-post-body-paragraph ji jj hi jl b jm lh jo jp jq li js jt ks mm jw jx kw mn ka kb la mo ke kf je hb bi translated">为了训练triplet network network，我使用了street2shop数据集，我按照这里提供的说明下载了数据集:<a class="ae kg" href="http://www.tamaraberg.com/street2shop" rel="noopener ugc nofollow" target="_blank">http://www.tamaraberg.com/street2shop</a>。基本上有三个文件夹，包含创建锚定图像、正图像和负图像数据集所需的所有信息。元数据中提供的文件夹是培训、测试和检索。在train/test文件夹中，我们有对应于每个类的单独的json文件，例如“train _ pair _ footwear.json”，在这些json文件中，我们给出了“照片id”，即街道照片的id，“边界框”信息，如宽度、高度、顶部、左侧。这有助于裁剪感兴趣的产品的精确区域，因为同一街道图像中可能有多个产品，我们一次将只关注一个产品，字段“产品id”表示街道图像的裁剪区域中存在的产品id。在train/test文件夹中，我们只给出了产品id和街道照片id，我们还需要知道相应的匹配商店照片id，因为我们要将一对图像发送到三元组网络，所以为了获得商店照片id，他们在retrieval.json文件中提供了映射[产品id，商店照片id]。</p><p id="e00e" class="pw-post-body-paragraph ji jj hi jl b jm nd jo jp jq ne js jt ks nf jw jx kw ng ka kb la nh ke kf je hb bi translated">他们还提供了photo.txt文件。该文件包含照片id(商店照片id或街道照片id)和相应的url以获取具有该id的图像。</p><p id="2a0b" class="pw-post-body-paragraph ji jj hi jl b jm nd jo jp jq ne js jt ks nf jw jx kw ng ka kb la nh ke kf je hb bi translated">使用训练、测试和检索文件夹中提供的信息，我们将创建meta_df pandas数据帧，其列为类型、类别、street_photo_id、shop_photo_id、宽度、顶部、高度、左侧。该数据帧将帮助我们创建最终数据集，并使用类别、product_id、shop_photo_id等字段检索df。该数据帧将帮助我们获得给定产品的商店图像。</p><figure class="mp mq mr ms fd ij"><div class="bz dy l di"><div class="ni nj l"/></div></figure><figure class="mp mq mr ms fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nk"><img src="../Images/26042525234984788ba37a2f8890e754.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4AN-hk6ng3pA2C-nQuMT5g.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">meta_df</figcaption></figure><figure class="mp mq mr ms fd ij er es paragraph-image"><div class="er es nl"><img src="../Images/9a56cfadb24fbace44d858462250c0fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*c--mdD7fUnlocsL5bPmjxg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">检索_df</figcaption></figure><h2 id="1f6d" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">7.2]数据分析和预处理</h2><h2 id="a612" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">7.2.1]类别分布</h2><p id="050c" class="pw-post-body-paragraph ji jj hi jl b jm lh jo jp jq li js jt ks mm jw jx kw mn ka kb la mo ke kf je hb bi translated">只有20357个街道图像和404483个商店图像以及11个不同的类别。还可以看到街道和商店图像中的类别分布。</p><figure class="mp mq mr ms fd ij er es paragraph-image"><div class="er es nm"><img src="../Images/c7e4b80daab21e79fe69256ddefaf081.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*fqFVX8kat5crAkJe1Ls6Xg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">商店分布</figcaption></figure><figure class="mp mq mr ms fd ij er es paragraph-image"><div class="er es nn"><img src="../Images/ee4ef314089c1010cdb150677a74db95.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*5CVke-nzVUAb62FzklIRmw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">街道分布</figcaption></figure><h2 id="bbfd" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">7.2.2]多个条目</h2><p id="4034" class="pw-post-body-paragraph ji jj hi jl b jm lh jo jp jq li js jt ks mm jw jx kw mn ka kb la mo ke kf je hb bi translated">我们需要记住三件事，第一，可以看到街头模特穿着许多产品，第二，同一产品可以由许多街头模特穿着，第三，对于街道图像中出现的产品，我们可以有多个匹配的商店图像。</p><blockquote class="jf jg jh"><p id="f0c3" class="ji jj jk jl b jm nd jo jp jq ne js jt ju nf jw jx jy ng ka kb kc nh ke kf je hb bi translated"><em class="hi">答:在下图中，我们可以看到模特穿了不同的衣服，比如夹克、包、鞋子、裙子等。</em></p></blockquote><figure class="mp mq mr ms fd ij er es paragraph-image"><div class="er es no"><img src="../Images/3ee127f2f10929efa7bf4b45471a8c04.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*iVdtnYLcgqfUQySZDM9URQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">案例一</figcaption></figure><blockquote class="jf jg jh"><p id="4501" class="ji jj jk jl b jm nd jo jp jq ne js jt ju nf jw jx jy ng ka kb kc nh ke kf je hb bi translated"><em class="hi"> B]在下图中，我们可以看到商店照片有重复条目，这是因为同一件商品(在本例中为裙子)被不同的模特穿过，因此出现了重复条目。</em></p></blockquote><figure class="mp mq mr ms fd ij er es paragraph-image"><div class="er es np"><img src="../Images/b58f50b3494fcf9ea0726692c933562d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*iYzv2myzsAiGW9GGDS7jxg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">案例二</figcaption></figure><blockquote class="jf jg jh"><p id="f1bd" class="ji jj jk jl b jm nd jo jp jq ne js jt ju nf jw jx jy ng ka kb kc nh ke kf je hb bi translated">为了验证第三种情况，我们将连接meta_df和retrieve_df，这样我们就可以在一行中包含street_photo_id和相应的shop_photo_id，我们将连接['category '，' product_id']上的两个数据帧。从数据帧中我们可以看到，给定的带有某个产品id的street_photo有多个匹配的商店图像，例如，有多个条目用于街道照片id 14537和产品id 286。</p></blockquote><figure class="mp mq mr ms fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nq"><img src="../Images/e67f4de31d2ab1e30401e2089e115e82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-JFARM51V626t6bFQJVIbg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">加入Df</figcaption></figure><figure class="mp mq mr ms fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nr"><img src="../Images/3406b6175438bf994ac77eefdd54c85d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sfDtgnFv1KG9GWoccJTkcg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">案例三</figcaption></figure><h2 id="58bb" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">7.2.3]商店-街道交叉口</h2><p id="17c3" class="pw-post-body-paragraph ji jj hi jl b jm lh jo jp jq li js jt ks mm jw jx kw mn ka kb la mo ke kf je hb bi translated">street_photo_id和shop_photo_id必须是两个不同的集合，因此，如果我们取这两个集合的交集，我们必须得到一个空集。让我们使用集合运算来验证这一点。</p><pre class="mp mq mr ms fd mt mu mv mw aw mx bi"><span id="6cc4" class="kh ki hi mu b fi my mz l na nb">print(‘Intesection set cardinality = ‘, len(set(meta_df_new[‘street_photo_id’]).intersection(set(meta_df_new[‘shop_photo_id’])))) </span><span id="dd90" class="kh ki hi mu b fi ns mz l na nb">## Output<br/>Intesection set cardinality =  0</span></pre><h2 id="42f0" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">7.2.4]照片Url数据框</h2><p id="8b23" class="pw-post-body-paragraph ji jj hi jl b jm lh jo jp jq li js jt ks mm jw jx kw mn ka kb la mo ke kf je hb bi translated">我们将创建photos.csv文件，其中包含照片id和照片url等字段。我们正在创建此文件，以便可以轻松创建最终数据集。这个csv文件稍后将用于获取街道和商店图像的URL。</p><figure class="mp mq mr ms fd ij er es paragraph-image"><div class="er es nt"><img src="../Images/649558580164c3917e796913c828c661.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*mTREgxzLGAvynN-3hE-eMQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片_网址_df</figcaption></figure><h2 id="ada1" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">7.2.5]图像选择</h2><p id="9332" class="pw-post-body-paragraph ji jj hi jl b jm lh jo jp jq li js jt ks mm jw jx kw mn ka kb la mo ke kf je hb bi translated">由于有太多的图像，我们将只处理30000张图像，以便获得30000张。我首先想到的是随机获取30000张图像，但在这个过程中，我们可能会遇到这样的情况:我们会有街道图像，但相应的配对商店图像不存在，因此为了避免这种情况，我创建了final_df数据帧。这个数据帧将有商店_照片_id，商店_照片_网址，街道_照片_id和街道_照片_网址和其他一些领域。为了下载图像，我们将遍历每一行，并行下载街道和商店图像。</p><blockquote class="jf jg jh"><p id="dde4" class="ji jj jk jl b jm nd jo jp jq ne js jt ju nf jw jx jy ng ka kb kc nh ke kf je hb bi translated"><em class="hi">为了获得所需的df，我们将首先在photo_id和street_photo_id上将meta_df_new与photo_df连接，它将给出street_photo_id的url，让我们将此列称为“street _ photo _ URL”</em></p><p id="0035" class="ji jj jk jl b jm nd jo jp jq ne js jt ju nf jw jx jy ng ka kb kc nh ke kf je hb bi translated"><em class="hi">为了获得‘商店_照片_网址’,我们将在照片_id和商店_照片_id上加入meta_df_new和照片_ df</em></p></blockquote><figure class="mp mq mr ms fd ij"><div class="bz dy l di"><div class="ni nj l"/></div></figure><figure class="mp mq mr ms fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nu"><img src="../Images/1aac4167ef21bd6217068e53599bdd38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h-vJRa2BwS6MxLAvZ0O6jA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">连接后的df(meta _ df _ new)</figcaption></figure><h2 id="ba6c" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">7.2.6]删除损坏的图像</h2><p id="0a2c" class="pw-post-body-paragraph ji jj hi jl b jm lh jo jp jq li js jt ks mm jw jx kw mn ka kb la mo ke kf je hb bi translated">使用数据集中提供的Url，我无法下载一些图像，问题可能出在“我的驱动器”或“Url”中。我们需要正确地处理损坏的图像，我们需要一对图像来使模型工作，如果任何一个图像(街道或商店)损坏，我们必须从数据集中删除整行条目。首先，我打乱了meta_df_new，这样我们就不会得到同一类的所有图像。我遵循的过程是循环直到50000次迭代，希望在50000次迭代中得到30000张图像。我使用多进程库来并行处理url请求，我第一次没有使用它，它花了9个小时来运行30000次迭代，但在使用池后，我设法在半小时内循环了50000次迭代。我做了并行32个进程，每个进程将采取一行数据帧，并检查是否商店照片url或街道照片url损坏或没有损坏，如果没有损坏，然后下载两个图像，并将is_selected字段设置为1，表示这一行被选中。如果任何一个图像损坏，将is_selected设置为0，并删除我们刚刚下载的图像，也就是说，如果错误出现在shop_url中，那么我们必须已经下载了street_url，我们必须删除它以节省空间，如果错误出现在street_url中，那么没有要删除的内容，因为还没有下载任何内容。下面我提供了讨论逻辑的代码。</p><figure class="mp mq mr ms fd ij"><div class="bz dy l di"><div class="ni nj l"/></div></figure><h2 id="bbed" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">7.2.7]消除矛盾</h2><p id="d377" class="pw-post-body-paragraph ji jj hi jl b jm lh jo jp jq li js jt ks mm jw jx kw mn ka kb la mo ke kf je hb bi translated">此时，我们有一个is_selected字段，告诉我们该行是否被选中。但是，即使经过仔细处理，我还是有一些行的is_selected为1，但是相应的街道图像不在triplet_image文件夹中。经过大量的调试，我设法找出了问题，问题是街道图像中可以有多种产品，所以在数据帧中存在具有相同街道url但具有不同商店图像的其他行。假设有一个processX，在时间“t”它正在处理rowX命中街道和商店的URL，并下载图像，它还将该行的is_selected设为1。假设有另一个进程“processY”在时间“t + 10”处理rowY，它具有与rowX的街道url相同的街道url，但是具有不同的商店url，不幸的是，它的shop_url关闭，并且“processY”未能下载相应的商店图像，根据我们的逻辑，当它失败时，代码将删除它的街道图像，但是被删除的街道图像也是rowX的街道图像。所以我们的代码最终删除了rowX的街道图像，这将在进一步处理图像时产生问题，我们必须处理这个问题。这个问题的解决方案很简单，我们将再次通过df循环每一行，我们将检查街道图像路径是否存在，如果不存在，我们将设置该行的is_selected为0。</p><figure class="mp mq mr ms fd ij"><div class="bz dy l di"><div class="ni nj l"/></div></figure><h2 id="20c5" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">7.2.8]类别的最终分布</h2><p id="fb3c" class="pw-post-body-paragraph ji jj hi jl b jm lh jo jp jq li js jt ks mm jw jx kw mn ka kb la mo ke kf je hb bi translated">在过滤掉损坏的图像并只保留30000到35000张图像后，让我们验证最终数据集中类别的分布。最终数据中各种类别的分布与我们之前的分布相同。</p><figure class="mp mq mr ms fd ij er es paragraph-image"><div class="er es nn"><img src="../Images/2ab0aa5ab9f230cae5e51bbd3fa15dc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*Uw51f_GP0yxpNKSiWb3ZqA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">最终类别分布</figcaption></figure><h2 id="3601" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">可视化</h2><p id="5fe6" class="pw-post-body-paragraph ji jj hi jl b jm lh jo jp jq li js jt ks mm jw jx kw mn ka kb la mo ke kf je hb bi translated">让我们将数据集中的一些街道和商店图像进行可视化。它还帮助我们检查所有的处理是否正确。</p><figure class="mp mq mr ms fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nv"><img src="../Images/a466f33929f6ca9fb40c304d45ea4e9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*XciSh6vd2Vb8fk1FSBMDcg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">街头商店对</figcaption></figure><h2 id="9079" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">7.3]三联体训练</h2><p id="3677" class="pw-post-body-paragraph ji jj hi jl b jm lh jo jp jq li js jt ks mm jw jx kw mn ka kb la mo ke kf je hb bi translated">在训练时，我第一次从驱动器中读取图像，这导致了“I/O错误”或有时“驱动器超时错误”,它太慢了。因此，我创建了images_triplet文件夹的zip文件google drive创建了7个2GB大小的zip文件，我将这些zip文件存储在google drive上，然后将它们解压缩到colab的磁盘中。现在，我不需要从驱动器上读取图像，节省了大量的培训时间。</p><p id="9a8d" class="pw-post-body-paragraph ji jj hi jl b jm nd jo jp jq ne js jt ks nf jw jx kw ng ka kb la nh ke kf je hb bi translated">我们在这里创建了三列anchor_path(锚图像的路径)、pos_path(正图像的路径)、neg_path(负图像的路径)，以获取某个rowX的neg_path。我首先创建temp_df。该df包含所有与rowX类别相同的行，然后从temp_df中获取任意行的pos path，并将其设置为rowX的neg_path。帽子、皮带、eywear等类别的图片很少，我选择删除它们。</p><p id="4d40" class="pw-post-body-paragraph ji jj hi jl b jm nd jo jp jq ne js jt ks nf jw jx kw ng ka kb la nh ke kf je hb bi translated">一个锚定图像一次可以有多个类别，我们需要专注于单个类别，这样他们就可以提供顶部、左侧、高度、宽度值。使用这些值，我创建了两个点(x1，y1)[左上]和(x2，y2)[下]。我们将使用这两个点裁剪图像，并将此裁剪后的图像及其正面和负面图像发送到三元组网络。</p><figure class="mp mq mr ms fd ij"><div class="bz dy l di"><div class="ni nj l"/></div></figure><p id="82df" class="pw-post-body-paragraph ji jj hi jl b jm nd jo jp jq ne js jt ks nf jw jx kw ng ka kb la nh ke kf je hb bi translated">在创建具有所有所需信息(例如neg_path、anchor_path和pos_path)的数据帧之后。我通过从“tf.keras.utils.Sequence”类创建子类来创建数据管道。我还对数据集进行了如下扩充，这样模型就不会过度拟合。</p><pre class="mp mq mr ms fd mt mu mv mw aw mx bi"><span id="d21c" class="kh ki hi mu b fi my mz l na nb">self.aug1 = ia.Dropout(p=0.01)<br/>self.aug2 = ia.GaussianBlur(sigma=(0.0, 3.0))<br/>self.aug3 = ia.flip.Fliplr(0.8)<br/>self.aug4 = ia.flip.Flipud(0.8)<br/>self.aug5 = ia.Alpha((0.0,1.0),ia.AllChannelsHistogramEqualization())</span></pre><p id="8219" class="pw-post-body-paragraph ji jj hi jl b jm nd jo jp jq ne js jt ks nf jw jx kw ng ka kb la nh ke kf je hb bi translated">让我们从数据生成器中获取一些数据样本，看看三元组模型将接收什么样的图像作为输入。</p><figure class="mp mq mr ms fd ij er es paragraph-image"><div class="er es nw"><img src="../Images/a5538ca9fb9dd609ed51ea405cb20eb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*0nnGEOn8v3oyXx_A3796IA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">三元组训练样本</figcaption></figure><blockquote class="jf jg jh"><p id="63af" class="ji jj jk jl b jm nd jo jp jq ne js jt ju nf jw jx jy ng ka kb kc nh ke kf je hb bi translated"><em class="hi">我分两个阶段训练模型:</em></p><p id="5b38" class="ji jj jk jl b jm nd jo jp jq ne js jt ju nf jw jx jy ng ka kb kc nh ke kf je hb bi translated"><em class="hi">在第一阶段，我保持学习率= 0.0001，保证金= 1，纪元= 10。</em></p><p id="467a" class="ji jj jk jl b jm nd jo jp jq ne js jt ju nf jw jx jy ng ka kb kc nh ke kf je hb bi translated"><em class="hi">对于第二阶段，我保持学习率= 0.00005，余量= 1，纪元= 20 </em></p></blockquote><pre class="mp mq mr ms fd mt mu mv mw aw mx bi"><span id="c64b" class="kh ki hi mu b fi my mz l na nb">Stage-I<br/>model.fit_generator(train_gen, epochs = 10, steps_per_epoch = 150,  validation_data = valid_gen, validation_steps = 70, callbacks = [model_checkpoint])</span><span id="0ee8" class="kh ki hi mu b fi ns mz l na nb">Stage-II<br/>model.fit_generator(train_gen, epochs = 20, steps_per_epoch = 150,  validation_data = valid_gen, validation_steps = 70, callbacks = [model_checkpoint])</span></pre><h2 id="d86a" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">7.4]性能指标:</h2><p id="3840" class="pw-post-body-paragraph ji jj hi jl b jm lh jo jp jq li js jt ks mm jw jx kw mn ka kb la mo ke kf je hb bi translated">完成训练阶段后，我使用“准确性”性能指标来衡量模型性能。我保留了一些数据进行验证。在valdiation数据中，我有一些产品的街道图像，我们称之为street_shoe_x，相应的商店图像，我们称之为shop_shoe_matched。我预计模型必须将这些图像的嵌入放得更近，因此当我对street_shoe_x的嵌入和商店中所有鞋的嵌入(这也包括shop_shoe_matched)取余弦相似度时，我应该得到shop_shoe_matched的最高余弦相似度，或者至少shop_shoe_matched必须出现在使用余弦相似度计算的与street_shoe_x最相似的鞋中。</p><p id="7d0a" class="pw-post-body-paragraph ji jj hi jl b jm nd jo jp jq ne js jt ks nf jw jx kw ng ka kb la nh ke kf je hb bi translated">利用这个概念，我将“准确性”定义为[命中/(命中+未命中)]。我首先将所有的商店图像输入到三元组网络模型中，并得到相应的嵌入，如下所示。任何一个shop _ embeddings都可以选择存储，因为它们都是同一个。</p><pre class="mp mq mr ms fd mt mu mv mw aw mx bi"><span id="85bf" class="kh ki hi mu b fi my mz l na nb">Input : (shop_image, shop_image, shop_image)<br/>Output : (shop_embedding, shop_embedding, shop_embedding)</span></pre><p id="4517" class="pw-post-body-paragraph ji jj hi jl b jm nd jo jp jq ne js jt ks nf jw jx kw ng ka kb la nh ke kf je hb bi translated">如果shop_shoe_matched是与street_shoe_x最相似的鞋，我们说我们有“命中”,否则我们说我们有“未命中”。我们将拍摄[BATCH_SIZE * 100]张图像并计算精确度。</p><figure class="mp mq mr ms fd ij"><div class="bz dy l di"><div class="ni nj l"/></div></figure><pre class="mp mq mr ms fd mt mu mv mw aw mx bi"><span id="a4ad" class="kh ki hi mu b fi my mz l na nb">Accuracy =  0.44916666666666666</span></pre><h2 id="c932" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">7.5]结果</h2><p id="e0b8" class="pw-post-body-paragraph ji jj hi jl b jm lh jo jp jq li js jt ks mm jw jx kw mn ka kb la mo ke kf je hb bi translated">为了获得给定产品的推荐，我们将产品图像传递到网络并获得其嵌入。根据产品的类别，如鞋、裙子、包、服装，我们只采用属于产品类别的商店图像的嵌入。然后计算产品嵌入和过滤嵌入之间的余弦相似度。最后按照余弦相似度降序排序，得到topK个最相似的商店产品。</p><figure class="mp mq mr ms fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nx"><img src="../Images/2f7400a4981dbf83bb121352063bee67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RQ4UVDmD6GdYlWY27dv_yQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">三重输出</figcaption></figure><h1 id="9412" class="lv ki hi bd kj lw lx ly kn lz ma mb kr mc md me kv mf mg mh kz mi mj mk ld ml bi translated">8.预言</h1><p id="fa87" class="pw-post-body-paragraph ji jj hi jl b jm lh jo jp jq li js jt ks mm jw jx kw mn ka kb la mo ke kf je hb bi translated">预测阶段有三个阶段，让我们一个接一个地看一下。下图是我们将要发送到掩膜RCNN模型进行预测的原始图像。</p><figure class="mp mq mr ms fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ny"><img src="../Images/83fa882b86ea7665475db56a2ded713d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1fBrNJ5uAM8Sv50b5O_Pmg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">原象</figcaption></figure><blockquote class="jf jg jh"><p id="fe7d" class="ji jj jk jl b jm nd jo jp jq ne js jt ju nf jw jx jy ng ka kb kc nh ke kf je hb bi translated"><em class="hi"> A】屏蔽Rcnn输出</em></p><p id="62c3" class="ji jj jk jl b jm nd jo jp jq ne js jt ju nf jw jx jy ng ka kb kc nh ke kf je hb bi translated"><em class="hi">当经过训练的掩模RCNN模型接收上述图像作为输入时，它将为它成功检测到的每个实例给出类别标签、掩模和边界框。屏蔽Rcnn输出如下图所示。我们可以看到，模型已经成功地检测到感兴趣的产品的所有实例，如包、鞋、衣服、打底裤等。</em></p></blockquote><figure class="mp mq mr ms fd ij er es paragraph-image"><div class="er es nz"><img src="../Images/17c861bbce89fa94bec85adbef7f9662.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*IV9d6610IHptlSeZZ4oLoA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">屏蔽输出</figcaption></figure><blockquote class="jf jg jh"><p id="2fd1" class="ji jj jk jl b jm nd jo jp jq ne js jt ju nf jw jx jy ng ka kb kc nh ke kf je hb bi translated"><em class="hi"> B】滤波输出</em></p><p id="15ad" class="ji jj jk jl b jm nd jo jp jq ne js jt ju nf jw jx jy ng ka kb kc nh ke kf je hb bi translated"><em class="hi">我们将对掩模rcnn模型的输出应用以下过滤器。第一个过滤器是移除置信度分数小于0.75的实例，也就是说，如果模型对某些实例不够有信心，则让该实例被移除。第二个过滤器是移除其要推荐的图像不存在于我们的数据集中的类别，因为用于训练掩模rcnn和三元组网络模型的数据集是不同的。在这种情况下，我选择移除不存在于三元组训练数据集中的类别。第三个过滤器是去除重复的实例，我们将保留具有最大置信度得分的实例。我们可以在过滤后的输出图像中看到，watch、top等实例在应用过滤器后被删除。</em></p></blockquote><figure class="mp mq mr ms fd ij er es paragraph-image"><div class="er es nz"><img src="../Images/36541975ea9e54239d61056eb57d49ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*nghD2jCygu_JorQ-VEJW-A.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">屏蔽输出滤波</figcaption></figure><blockquote class="jf jg jh"><p id="623c" class="ji jj jk jl b jm nd jo jp jq ne js jt ju nf jw jx jy ng ka kb kc nh ke kf je hb bi translated"><em class="hi"> C】最终输出</em></p><p id="afd1" class="ji jj jk jl b jm nd jo jp jq ne js jt ju nf jw jx jy ng ka kb kc nh ke kf je hb bi translated"><em class="hi">最后，产品类别的实例被馈送到三元组网络以获得嵌入。然后，这些嵌入被用于获得topK个最相似的产品，如前所述，我们将K保持为6。使用matplotlib库绘制这些最相似的产品及其原始产品。</em></p></blockquote><figure class="mp mq mr ms fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es oa"><img src="../Images/4a943bd42fc85941cccbdca899c39e45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2RTd0eesX6Y9avKFuzPkNg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">最终输出</figcaption></figure><h1 id="3008" class="lv ki hi bd kj lw lx ly kn lz ma mb kr mc md me kv mf mg mh kz mi mj mk ld ml bi translated">9.部署</h1><p id="f9bb" class="pw-post-body-paragraph ji jj hi jl b jm lh jo jp jq li js jt ks mm jw jx kw mn ka kb la mo ke kf je hb bi translated">我已经在Tensorflow 1.15.2和Python 3.7.10中的Google Colab上训练和测试了我所有的模型。我用streamlit创建了我的应用程序的前端。我用过st.markdown()、st.file_upload()、st.pyplot()等函数。我已经在本地部署了该模型，下面我提供了我的streamlit应用程序的视频演示。</p><figure class="mp mq mr ms fd ij"><div class="bz dy l di"><div class="ob nj l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">SteamLit应用演示</figcaption></figure><h1 id="ab24" class="lv ki hi bd kj lw lx ly kn lz ma mb kr mc md me kv mf mg mh kz mi mj mk ld ml bi translated">10.未来的工作</h1><h2 id="df8b" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">10.1]更新掩码RCNN</h2><p id="94c5" class="pw-post-body-paragraph ji jj hi jl b jm lh jo jp jq li js jt ks mm jw jx kw mn ka kb la mo ke kf je hb bi translated">当前的Mask-RCNN适用于tensorflow 1.15.2一旦Mask-RCNN的可靠tensorflow 2.x实现可用，我将更新我的代码。我在tensorflow 1中实现的三联体模型。x和2.x两个版本都可以在我的Git存储库中获得。</p><h2 id="6712" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">10.2]添加姿态检测模块</h2><p id="f36a" class="pw-post-body-paragraph ji jj hi jl b jm lh jo jp jq li js jt ks mm jw jx kw mn ka kb la mo ke kf je hb bi translated">由于缺乏数据，我跳过了论文中的姿态检测模块。一旦我获得了姿势检测的适当数据，我肯定会尝试将该模块添加到我的案例研究中。</p><h2 id="26dd" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">10.3]掩模固定器模块</h2><p id="2877" class="pw-post-body-paragraph ji jj hi jl b jm lh jo jp jq li js jt ks mm jw jx kw mn ka kb la mo ke kf je hb bi translated">目前，该模型使用边界框信息从图像中提取产品实例，而不是使用bbox，我尝试使用遮罩来提取产品实例，但它的性能稍差。我认为使用掩码进行提取时性能不佳的原因是，为给定产品实例生成的掩码没有与产品实例正确重叠它们或者没有与不属于产品实例的区域重叠，或者与不属于产品实例的区域重叠。</p><p id="dbed" class="pw-post-body-paragraph ji jj hi jl b jm nd jo jp jq ne js jt ks nf jw jx kw ng ka kb la nh ke kf je hb bi translated">为了解决这个问题，将来我会尝试在屏蔽RCNN和三重网络之间增加一个模块。让我们称这个模块为蒙版固定器模块，这样蒙版固定器模块就可以修复重叠不良的蒙版。我们训练这个模块的方式将与训练传统图像分割模型的方式相同。训练数据将具有丢失了对象的某一部分的图像，并且对于对象的该丢失部分，相应的掩模将具有1，而掩模中的其他像素将具有0。该损失将与图像分割损失相同。这个模块的目标是为一个对象的缺失部分生成蒙版，一旦我们有一个对象的缺失部分，我们可以通过使用同一对象的非缺失部分的像素值来填充它。现在，当我使用“固定遮罩”从图像中提取产品实例时，我可以期待更好的结果。</p><h2 id="503d" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">10.4]处理嵌入</h2><p id="3435" class="pw-post-body-paragraph ji jj hi jl b jm lh jo jp jq li js jt ks mm jw jx kw mn ka kb la mo ke kf je hb bi translated">为了得到topK，我们总是必须根据余弦相似性对嵌入进行排序。记住，排序发生在过滤嵌入上，也就是说，如果要计算推荐的产品属于鞋类，那么我们只取鞋类的嵌入，然后计算余弦相似度。在实时每个类别的商店图像可以在lakhs，所以我们必须存储的嵌入也将在lakhs，排序每个类别的嵌入lakhs将是一项耗时的任务。为了处理这个问题，我们可以使用基于树的方法来存储嵌入，例如KDE、球树或基于散列的方法，例如位置敏感散列。这些技术肯定会提高给定产品类别获得推荐的时间。</p><h2 id="e2bf" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">10.5]一般改进</h2><p id="d62d" class="pw-post-body-paragraph ji jj hi jl b jm lh jo jp jq li js jt ks mm jw jx kw mn ka kb la mo ke kf je hb bi translated">如果您有高计算能力的机器，您可以下载掩模RCNN的整个图像数据集以及三元组网络，并在整个数据集上训练模型。这将改善三元组的损失和掩模RCNN模型的Map得分。对于三元组网络，可以尝试不同的损失函数、不同的裕度值、在线、离线三元组挖掘，看看是否能改善损失。</p><blockquote class="jf jg jh"><p id="8a12" class="ji jj jk jl b jm nd jo jp jq ne js jt ju nf jw jx jy ng ka kb kc nh ke kf je hb bi translated"><em class="hi">感谢阅读整个博客。我希望这个博客清晰易懂，将来能帮助你为时尚产品创造最先进的推荐引擎。如果您有疑问或任何改进建议，您可以通过下面提供的链接联系我。</em></p></blockquote><p id="42d0" class="pw-post-body-paragraph ji jj hi jl b jm nd jo jp jq ne js jt ks nf jw jx kw ng ka kb la nh ke kf je hb bi translated">代码的Githhub链接:【https://github.com/ranveerkln/Fashion_Git T2】</p><h1 id="4d36" class="lv ki hi bd kj lw lx ly kn lz ma mb kr mc md me kv mf mg mh kz mi mj mk ld ml bi translated">11.轮廓</h1><div class="oc od ez fb oe of"><a href="https://www.linkedin.com/in/sachin-ranveer-b37360166/" rel="noopener  ugc nofollow" target="_blank"><div class="og ab dw"><div class="oh ab oi cl cj oj"><h2 class="bd hj fi z dy ok ea eb ol ed ef hh bi translated">Sachin Ranveer -数据工程师-Nykaa.com | LinkedIn</h2><div class="om l"><h3 class="bd b fi z dy ok ea eb ol ed ef dx translated">经验丰富的数据工程师，有在互联网行业工作的经历。熟练掌握亚马逊红移…</h3></div><div class="on l"><p class="bd b fp z dy ok ea eb ol ed ef dx translated">www.linkedin.com</p></div></div><div class="oo l"><div class="op l oq or os oo ot io of"/></div></div></a></div><div class="oc od ez fb oe of"><a href="https://github.com/ranveerkln" rel="noopener  ugc nofollow" target="_blank"><div class="og ab dw"><div class="oh ab oi cl cj oj"><h2 class="bd hj fi z dy ok ea eb ol ed ef hh bi translated">ranveerkln -概述</h2><div class="om l"><h3 class="bd b fi z dy ok ea eb ol ed ef dx translated">4月5月6月7月8月9月10月11月12月1月2月3月4月1日星期三Fri ranveerkln在此期间没有任何活动。已创建…</h3></div><div class="on l"><p class="bd b fp z dy ok ea eb ol ed ef dx translated">github.com</p></div></div><div class="oo l"><div class="ou l oq or os oo ot io of"/></div></div></a></div><h1 id="082d" class="lv ki hi bd kj lw lx ly kn lz ma mb kr mc md me kv mf mg mh kz mi mj mk ld ml bi translated">12.参考</h1><div class="oc od ez fb oe of"><a href="https://www.appliedaicourse.com/" rel="noopener  ugc nofollow" target="_blank"><div class="og ab dw"><div class="oh ab oi cl cj oj"><h2 class="bd hj fi z dy ok ea eb ol ed ef hh bi translated">应用课程</h2><div class="om l"><h3 class="bd b fi z dy ok ea eb ol ed ef dx translated">我们知道转行是多么具有挑战性。我们的应用人工智能/机器学习课程被设计为整体学习…</h3></div><div class="on l"><p class="bd b fp z dy ok ea eb ol ed ef dx translated">www.appliedaicourse.com</p></div></div><div class="oo l"><div class="ov l oq or os oo ot io of"/></div></div></a></div><figure class="mp mq mr ms fd ij"><div class="bz dy l di"><div class="ow nj l"/></div></figure><p id="2e45" class="pw-post-body-paragraph ji jj hi jl b jm nd jo jp jq ne js jt ks nf jw jx kw ng ka kb la nh ke kf je hb bi translated"><a class="ae kg" href="http://(124) Lecture - 31 Image Segmentation - III - YouTube" rel="noopener ugc nofollow" target="_blank"> (124)讲座— 31图像分割— III — YouTube </a></p><p id="d488" class="pw-post-body-paragraph ji jj hi jl b jm nd jo jp jq ne js jt ks nf jw jx kw ng ka kb la nh ke kf je hb bi translated">【towardsdatascience.com T2】中型</p><p id="2d40" class="pw-post-body-paragraph ji jj hi jl b jm nd jo jp jq ne js jt ks nf jw jx kw ng ka kb la nh ke kf je hb bi translated"><a class="ae kg" href="https://github.com/sanku-lib/image_triplet_loss" rel="noopener ugc nofollow" target="_blank">GitHub—sanku-lib/Image _ Triplet _ Loss:使用三重损失的图像相似度</a></p><p id="5d7c" class="pw-post-body-paragraph ji jj hi jl b jm nd jo jp jq ne js jt ks nf jw jx kw ng ka kb la nh ke kf je hb bi translated"><a class="ae kg" href="https://arxiv.org/pdf/1703.06870.pdf" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/pdf/1703.06870.pdf</a></p></div></div>    
</body>
</html>