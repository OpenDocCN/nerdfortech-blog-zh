<html>
<head>
<title>What not to do when using async background jobs(based on rails+sidekiq experience)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用异步后台作业时不要做什么(基于 rails+sidekiq 经验)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/what-not-to-do-when-using-async-background-jobs-based-on-rails-sidekiq-experience-b66316fc3874?source=collection_archive---------0-----------------------#2021-12-20">https://medium.com/nerd-for-tech/what-not-to-do-when-using-async-background-jobs-based-on-rails-sidekiq-experience-b66316fc3874?source=collection_archive---------0-----------------------#2021-12-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/6986a3ba545dd0052fe846ac88b38020.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2TQX4JJv779b-HHje7D6VA.jpeg"/></div></div></figure><blockquote class="iq ir is"><p id="efde" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="hi">Para ler a verso em português desse post，acesse</em><a class="ae js" rel="noopener" href="/@jplethier/o-que-não-fazer-ao-usar-background-jobs-baseado-em-experiência-com-rails-sidekiq-5e665f9d5335">https://medium . com/@ jpletheir/o-que-n % C3 % A3o-fazer-ao-usar-background-jobs-base ado-em-experi % C3 % aan CIA-com-rails-sidekiq-5e 665 f9d 5335</a></p></blockquote><p id="4a61" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">在 web 应用程序中有异步任务是很常见的。将复杂而缓慢的 web 服务器任务、具有外部依赖关系的任务和您无法依赖的依赖关系的任务以及在 http 请求期间不需要同步运行的任何其他类型的任务移出会很有用，这样可以缩短请求的持续时间。</p><p id="4d61" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">但是，如果您不习惯使用后台任务，并且知道应该避免什么，那么在使用后台任务时很容易出现一些意想不到的问题，并陷入一些令人担忧的混乱问题中。这就是我想在这篇文章中分享的，一些我根据自己使用<a class="ae js" href="https://github.com/mperham/sidekiq" rel="noopener ugc nofollow" target="_blank"> sidekiq </a>在 ruby on rails 应用程序中运行后台作业的经验尝试不做的实践。</p><h2 id="b613" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jt kh ki kj ju kk kl km jv kn ko kp kq bi translated">接收复杂对象</h2><p id="3e9d" class="pw-post-body-paragraph it iu hi iw b ix kr iz ja jb ks jd je jt kt jh ji ju ku jl jm jv kv jp jq jr hb bi translated">假设您有一个后台任务，需要接收一个时间戳作为参数。如果您只是将 DateTime 对象作为参数传递给 sidekiq 作业，sidekiq 会将其序列化为 json，然后再反序列化为 timestamp。这种情况通常会发生在不同的服务器、不同的机器上，不能确定它不会失去精度。也许它失去了毫秒级的精度，并且它不会对您的应用程序产生任何影响，但是它可能发生在任何其他复杂的参数上。</p><h2 id="d790" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jt kh ki kj ju kk kl km jv kn ko kp kq bi translated">接收整个数据库记录</h2><p id="e69f" class="pw-post-body-paragraph it iu hi iw b ix kr iz ja jb ks jd je jt kt jh ji ju ku jl jm jv kv jp jq jr hb bi translated">如果您将邮件程序配置为与 sidekiq 一起使用，那么这个错误是很常见的。主要是因为当邮件发送者同步发送时，您将整个记录的对象毫无问题地传递给他们，一切都很好。在某个时候，您配置您的项目使用 sidekiq 调用邮件程序，或者您开始在一个已经有那个配置的新项目中工作。这种方法有两个问题。</p><p id="75c4" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">第一个和之前的题目一样。数据库记录是复杂的对象，您有多种不同类型的属性，其中一些属性可能会丢失精度，您最终会在工作中得到不同的值</p><p id="a88f" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">第二点，也是我认为最重要的一点，就是当你调用一个作业时，你不能确定它什么时候运行。当作业开始运行时，传递给它的数据库记录可能会过期。例如，我们可以调用一个作业来发送一封电子邮件，传递一个包含电子邮件属性的数据库记录，在作业入队后，记录得到更新，我们最终使用过时的电子邮件信息将电子邮件发送到了错误的目的地。</p><p id="0e46" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">因此，如果在开始运行作业时总是从数据库中获取更新的数据很重要，那么最好是<a class="ae js" href="https://github.com/mperham/sidekiq/wiki/Best-Practices#1-make-your-job-parameters-small-and-simple" rel="noopener ugc nofollow" target="_blank">只传递足够的信息</a>，这样作业就可以自己在数据库中搜索其余的信息。这样做我们也避免了序列化和反序列化过程花费更多的时间，因为更简单的对象处理起来更快。</p><h2 id="be8f" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jt kh ki kj ju kk kl km jv kn ko kp kq bi translated">调用数据库事务(或任何可以回滚的事务)内部的作业</h2><p id="04ab" class="pw-post-body-paragraph it iu hi iw b ix kr iz ja jb ks jd je jt kt jh ji ju ku jl jm jv kv jp jq jr hb bi translated">这似乎是避免阅读上面一行的明显做法。但是特别是对于活动记录，当我们使用活动记录回调时，我看到这种情况经常发生。您只需使用错误的回调来调用作业，比方说，在活动记录事务完成并提交之前运行的任何回调。以 rails 应用程序为例，这里的最佳解决方案是当您想要调用作业时，总是使用在事务提交之后运行的<a class="ae js" href="https://guides.rubyonrails.org/active_record_callbacks.html#transaction-callbacks" rel="noopener ugc nofollow" target="_blank">回调，因为它只在数据库事务完成之后运行。</a></p><p id="8f35" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">我看到的另一个场景是当我们有一些用例(或服务)链接到其他用例(或服务)时。例如，假设我们有下面的类:</p><figure class="kw kx ky kz fd ij"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="20a2" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">查看 ProfileUpdate 类，一切似乎都是正确的，邮件程序在事务外部被调用。但是，如果我们查看 UserSafetyDataValidation 类，我们可以看到那里正在调用一个作业，该类的所有 on call 方法都运行在该类之外启动的数据库事务内部。即使<code class="du lc ld le lf b">user.update!</code>失败，这也会导致作业运行。</p><p id="37eb" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">在这种情况下，我们可以使用的一种方法是将内部类的消息链接回外部类，并调用用例及服务之外的作业和其他任务，可能使用监听器和广播架构。</p><p id="f62a" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">您可以使用<a class="ae js" href="https://github.com/palkan/isolator" rel="noopener ugc nofollow" target="_blank"> isolator gem </a>来帮助您避免这些问题，并且您可以在这篇<a class="ae js" href="https://evilmartians.com/chronicles/rails-after_commit-everywhere" rel="noopener ugc nofollow" target="_blank">rails after _ commit everywhere post</a>中了解针对最后一个场景的另一个好方法。</p><h2 id="7834" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jt kh ki kj ju kk kl km jv kn ko kp kq bi translated">更改生产作业签名</h2><p id="5e7a" class="pw-post-body-paragraph it iu hi iw b ix kr iz ja jb ks jd je jt kt jh ji ju ku jl jm jv kv jp jq jr hb bi translated">这不像上面列出的问题那样常见，但也不是极端情况。如果我们在开发代码时总是关心和考虑向后兼容性，这个问题是可以避免的。这里的问题是，当您更改作业参数或作业名称时，您可能会将作业排入考虑旧签名的队列，并且当从要执行的队列中选择作业时，它将失败。例如，如果向作业添加新的必需参数，旧的排队作业将会失败，因为没有新的参数与之一起排队。</p><p id="0a8b" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">在您确实需要更改作业签名的情况下，一种方法是在某些步骤中进行更改。例如，如果确实需要向作业添加新参数，您可以首先将此参数作为可选参数添加，并为其设置默认值，过一段时间后，当您可以确保所有排队的作业都已经为其设置了新参数时，您可以删除新参数的默认值并使其成为必需参数。如果需要更改作业名称，您可以使用新名称创建一个新作业，但首先要保留旧作业，只有当没有任何任务排队等待该作业并且可以安全删除它时，才删除它。</p><h2 id="d932" class="jw jx hi bd jy jz ka kb kc kd ke kf kg jt kh ki kj ju kk kl km jv kn ko kp kq bi translated">没有定义队列及其优先级</h2><p id="11ec" class="pw-post-body-paragraph it iu hi iw b ix kr iz ja jb ks jd je jt kt jh ji ju ku jl jm jv kv jp jq jr hb bi translated">这在项目的第一个月非常常见，因为大多数事情都需要快速完成，以便将应用程序的第一个版本发布到产品中。至少为两个不同的优先级定义队列是很重要的:需要在短时间内运行的任务，它们更具事务性；需要更长时间运行的任务，延迟并不重要。例如，假设您有一项工作，在用户更改电话号码后发送带有代码的确认短信，但当该短信排队时，您有许多促销电子邮件要发送，这可能会导致确认短信延迟一个小时。也许你的用户不会一直等着收到短信。</p></div><div class="ab cl lg lh gp li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hb hc hd he hf"><p id="9284" class="pw-post-body-paragraph it iu hi iw b ix iy iz ja jb jc jd je jt jg jh ji ju jk jl jm jv jo jp jq jr hb bi translated">这些是我在后台工作时学会避免的一些做法，但我认为大多数想法可以应用于广播和基于事件的应用程序。但是正如我在文章开头所说的，这些只是基于我的经验，主要是基于 ruby on rails 项目和 sidekiq。也许有一些更重要的实践来避免在其他框架和语言中使用背景。</p></div></div>    
</body>
</html>