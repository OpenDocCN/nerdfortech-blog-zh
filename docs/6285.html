<html>
<head>
<title>SOLID Principles in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 中的坚实原理</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/solid-principles-in-java-fe75382d8923?source=collection_archive---------0-----------------------#2022-01-29">https://medium.com/nerd-for-tech/solid-principles-in-java-fe75382d8923?source=collection_archive---------0-----------------------#2022-01-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c7b926c0c7b7c8749be1d4cd602b5416.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nsGbzPxQs4y3FJuU"/></div></div></figure><p id="374c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在软件工程中，<strong class="is hj"> SOLID </strong>是 5 个<a class="ae jo" href="https://principles.design/" rel="noopener ugc nofollow" target="_blank">设计原则</a>的首字母缩写，旨在使软件设计更容易理解、灵活、健壮和可维护。采用这些实践也有助于避免代码味道。</p><p id="406a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这 5 个坚实的原则是:</p><ul class=""><li id="d84c" class="jp jq hi is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx bi translated">单一责任原则</li><li id="10f9" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj"> O </strong> —开闭原理</li><li id="31db" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj"> L </strong> —利斯科夫替代原理</li><li id="89ac" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj"> I </strong> —界面偏析原理</li><li id="910b" class="jp jq hi is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx bi translated"><strong class="is hj"> D </strong> —依存倒置原则</li></ul><p id="ec1f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">尽管这些坚实的原则适用于任何编程语言，但在下一节中，我将使用专门用 JAVA 编写的例子来解释它们。</p><h1 id="6cc5" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">单一责任原则</h1><p id="11cc" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">这个原则规定"<strong class="is hj">一个类应该只有一个改变</strong>的理由"，这意味着每个类应该有一个单一的责任。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="d84f" class="lp ke hi ll b fi lq lr l ls lt">public class Vehicle {<br/>    public void details() {}<br/>    public double price() {}<br/>    public void addNewVehicle() {}<br/>}</span></pre><p id="c8d1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这里，该类有多种理由进行更改，因为<code class="du lu lv lw ll b">Vehicle</code>类有三个独立的职责:打印细节、打印价格和向数据库添加新的车辆。</p><p id="b623" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了实现单一责任原则的目标，我们应该实现一个只执行单一功能的单独的类。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="87c6" class="lp ke hi ll b fi lq lr l ls lt">public class VehicleDetails {<br/>    public void details() {}<br/>}</span><span id="8352" class="lp ke hi ll b fi lx lr l ls lt">public class CalculateVehiclePrice {<br/>    public double price() {}<br/>}</span><span id="dae3" class="lp ke hi ll b fi lx lr l ls lt">public class AddVehicle {<br/>    public void addNewVehicle() {}<br/>}</span></pre><h1 id="8051" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">开闭原理</h1><p id="2de5" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">这个原则声明"<strong class="is hj">软件实体(类等。)应打开以进行扩展，但关闭以进行修改</strong>。这意味着不用修改类中的任何东西，它应该是可扩展的。</p><p id="16b1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们通过一个通知服务的例子来理解这个原理:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="71e9" class="lp ke hi ll b fi lq lr l ls lt">public class NotificationService{<br/>    public void sendNotification(String medium) {<br/>         if (medium.equals("email")) {}<br/>    }<br/>}</span></pre><p id="ea6d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里，如果你想引入一个新的媒介而不是电子邮件，比如说发送一个通知到一个移动号码，那么你需要修改 NotificationService 类中的源代码。</p><p id="a815" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，为了克服这一点，你需要以这样一种方式设计你的代码，每个人都可以通过扩展它来重用你的功能，如果他们需要任何定制，他们可以扩展类并在其上添加他们的功能。</p><p id="eff3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以创建一个新界面，如下所示:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="7f9d" class="lp ke hi ll b fi lq lr l ls lt">public interface NotificationService {<br/>    public void sendNotification(String medium);<br/>}</span></pre><p id="5f0d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">电子邮件通知:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="154f" class="lp ke hi ll b fi lq lr l ls lt">public class EmailNotification implements NotificationService {<br/>    public void sendNotification(String medium){<br/>        // write Logic using for sending email<br/>    }<br/>}</span></pre><p id="fb02" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">手机通知:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="8d3e" class="lp ke hi ll b fi lq lr l ls lt">public class MobileNotification implements NotificationService {<br/>    public void sendNotification(String medium){<br/>        // write Logic using for sending notification via mobile<br/>    }<br/>}</span></pre><h1 id="17ea" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">利斯科夫替代原理</h1><p id="eb41" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">这个原则声明“<strong class="is hj">派生类必须能够替换它们的基类</strong>”。换句话说，如果类 A 是类 B 的子类，那么我们应该能够在不中断程序当前行为的情况下用 A 替换 B。</p><p id="a60c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">考虑一个从 Rectangle 基类派生的 square 类的示例:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="2868" class="lp ke hi ll b fi lq lr l ls lt">public class Rectangle {<br/>    private double height;<br/>    private double width;<br/>    public void setHeight(double h) { height = h; }<br/>    public void setWidht(double w) { width = w; }<br/>}</span><span id="2775" class="lp ke hi ll b fi lx lr l ls lt">public class Square extends Rectangle {<br/>    public void setHeight(double h) {<br/>        super.setHeight(h);<br/>        super.setWidth(h);<br/>    }<br/>    public void setWidth(double w) {<br/>        super.setHeight(w);<br/>        super.setWidth(w);<br/>    }<br/>}</span></pre><p id="64d7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在<code class="du lu lv lw ll b">Rectangle</code>类中，设置宽度和高度似乎完全合乎逻辑。然而，在 square 类中，SetWidth()和 SetHeight()没有意义，因为设置一个会改变另一个来匹配它。</p><p id="8b6f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这种情况下，Square 没有通过 Liskov 替换测试，因为您不能用它的派生类 Square 替换 Rectangle 基类。Square 类有额外的约束，即高度和宽度必须相同。因此，用 Square 类替换 Rectangle 可能会导致意外的行为。</p><h1 id="a9f4" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">界面分离原理</h1><p id="7c68" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">这个原则适用于接口，它类似于单一责任原则。它声明"<strong class="is hj">客户永远不应该被强迫实现它不使用的接口，或者客户不应该被强迫依赖他们不使用的方法。</strong>”。</p><p id="c9e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们以车辆接口为例来理解这一点:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="323a" class="lp ke hi ll b fi lq lr l ls lt">public interface Vehicle {<br/>    public void drive();<br/>    public void stop();<br/>    public void refuel();<br/>    public void openDoors();<br/>}</span></pre><p id="1b17" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们现在使用这个 Vehicle 接口创建了一个<code class="du lu lv lw ll b">Bike</code>类</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="348f" class="lp ke hi ll b fi lq lr l ls lt">public class Bike implements Vehicle {<br/>    public void drive() {}<br/>    public void stop() {}<br/>    public void refuel() {}</span><span id="b904" class="lp ke hi ll b fi lx lr l ls lt">    // Can not be implemented<br/>    public void openDoors() {}<br/>}</span></pre><p id="c45a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于自行车没有门，我们不能实现最后一个功能。</p><p id="57ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要解决这个问题，建议将接口分解成多个小接口，这样就不会强制任何类实现它不需要的任何接口或方法。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="e352" class="lp ke hi ll b fi lq lr l ls lt">public interface Vehicle {<br/>    public void drive();<br/>    public void stop();<br/>    public void refuel();<br/>}</span><span id="ff95" class="lp ke hi ll b fi lx lr l ls lt">public interface Doors{<br/>    public void openDoors();<br/>}</span></pre><p id="83e6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">创建两个类— <code class="du lu lv lw ll b">Car</code>和<code class="du lu lv lw ll b">Bike</code></p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="2498" class="lp ke hi ll b fi lq lr l ls lt">public class Bike implements Vehicle {<br/>    public void drive() {}<br/>    public void stop() {}<br/>    public void refuel() {}<br/>}</span><span id="942e" class="lp ke hi ll b fi lx lr l ls lt">public class Car implements Vehicle, Door {<br/>    public void drive() {}<br/>    public void stop() {}<br/>    public void refuel() {}<br/>    public void openDoors() {}<br/>}</span></pre><h1 id="a01c" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">从属倒置原则</h1><p id="dc5c" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">依赖倒置原则(DIP)声明"<strong class="is hj">实体必须依赖于抽象(抽象类和接口)，而不是依赖于具体的实现(类)。此外，高级模块不能依赖于低级模块，但两者都应该依赖于抽象</strong>。</p><p id="2344" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设有一家书店可以让顾客把他们喜欢的书放在特定的书架上。</p><p id="d2cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了实现这个功能，我们创建了一个<code class="du lu lv lw ll b">Book</code>类和一个<code class="du lu lv lw ll b">Shelf</code>类。Book 类将允许用户查看他们存放在书架上的每本书的评论。书架课会让他们在书架上增加一本书。举个例子，</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="3ed6" class="lp ke hi ll b fi lq lr l ls lt">public class Book {<br/>    void seeReviews() {}<br/>}</span><span id="9dba" class="lp ke hi ll b fi lx lr l ls lt">public class Shelf {<br/>     Book book;<br/>     void addBook(Book book) {}<br/>}</span></pre><p id="97b1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一切看起来都很好，但是由于高级的<code class="du lu lv lw ll b">Shelf</code>类依赖于低级的<code class="du lu lv lw ll b">Book</code>，上面的代码违反了依赖倒置原则。当商店要求我们让顾客也能在货架上添加他们自己的评论时，这一点就变得很明显了。为了满足需求，我们创建了一个新的<code class="du lu lv lw ll b">UserReview</code>类:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="0ed1" class="lp ke hi ll b fi lq lr l ls lt">public class UserReview{<br/>     void seeReviews() {}<br/>}</span></pre><p id="6a38" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们应该修改 Shelf 类，使它也可以接受用户评论。然而，这显然也会破坏开/关原则。</p><p id="0ebd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">解决方案是为底层类(Book 和 UserReview)创建一个抽象层。我们将通过引入产品接口来做到这一点，两个类都将实现它。例如，下面的代码演示了这个概念。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="69e0" class="lp ke hi ll b fi lq lr l ls lt">public interface Product {<br/>    void seeReviews();<br/>}</span><span id="10cd" class="lp ke hi ll b fi lx lr l ls lt">public class Book implements Product {<br/>    public void seeReviews() {}<br/>}</span><span id="ce93" class="lp ke hi ll b fi lx lr l ls lt">public class UserReview implements Product {<br/>    public void seeReviews() {}<br/>}</span></pre><p id="c9ab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，书架可以引用产品接口而不是它的实现(Book 和 UserReview)。重构后的代码还允许我们在以后引入新的产品类型(例如，杂志),顾客也可以把它们放在货架上。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="4ea5" class="lp ke hi ll b fi lq lr l ls lt">public class Shelf {<br/>    Product product;<br/>    void addProduct(Product product) {}<br/>    void customizeShelf() {}<br/>}</span></pre><h1 id="75ec" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">结论</h1><p id="72c9" class="pw-post-body-paragraph iq ir hi is b it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">在本文中，您了解了可靠代码的五个原则。坚持坚实的原则可以使你的项目，可扩展，容易修改，测试良好，更少的复杂性。</p></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><p id="03e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="mf">原载于</em><a class="ae jo" href="https://apoorvtyagi.tech/solid-principles-in-java" rel="noopener ugc nofollow" target="_blank"><em class="mf">https://apoorvtyagi . tech</em></a><em class="mf">。</em></p></div></div>    
</body>
</html>