<html>
<head>
<title>Local Sequence Alignment: Implementation in Python From Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">局部序列比对:从零开始用 Python 实现</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/local-sequence-alignment-implementation-in-python-from-scratch-bbcf0dd4cd11?source=collection_archive---------1-----------------------#2021-05-14">https://medium.com/nerd-for-tech/local-sequence-alignment-implementation-in-python-from-scratch-bbcf0dd4cd11?source=collection_archive---------1-----------------------#2021-05-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="69e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<a class="ae jd" href="https://rishikagupta1999.medium.com/sequence-alignment-of-dna-4224e9d61cfa" rel="noopener">之前的一篇文章</a>中，我介绍了 DNA、RNA 或蛋白质序列比对的概念。在本文中，我们将从头开始用 python 实现局部序列比对。所以让我们开始吧！！！</p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="4712" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">局部序列比对旨在获得已知序列的子序列和未知(查询)序列的子序列之间的最佳比对。</p><p id="6513" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了实现，让我们考虑第一个序列为 x，第二个序列为 y，其中:</p><blockquote class="jl"><p id="df68" class="jm jn hi bd jo jp jq jr js jt ju jc dx translated">x = '猫狗鱼'<br/> y = '狗'</p></blockquote><p id="028f" class="pw-post-body-paragraph if ig hi ih b ii jv ik il im jw io ip iq jx is it iu jy iw ix iy jz ja jb jc hb bi translated">首先也是最重要的，让我们获得一个初始矩阵，在零中填充 z。序列应该这样放置，x 矩阵的字符占据列，y 矩阵的字符占据行。</p><p id="0e26" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在这里参考我关于全球序列比对<a class="ae jd" href="https://python.plainenglish.io/global-sequence-alignment-implementation-in-python-from-scratch-5a8a611dbb1e" rel="noopener ugc nofollow" target="_blank">的文章，了解缺口、匹配和错配的概念。</a></p><p id="7696" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了适应序列中的差异，我们遵循评分模式，其中我们为特定的一组代码选择缺口分数、匹配分数以及错配分数。这里，在这种情况下:</p><blockquote class="jl"><p id="d1f0" class="jm jn hi bd jo jp jq jr js jt ju jc dx translated"><em class="ka">差距得分= -7 <br/>匹配= 10 <br/>不匹配= -5 </em></p></blockquote><figure class="kc kd ke kf kg kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kb"><img src="../Images/85c1ec1eb20569458b95292907b201cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1AGWx2f5KgwSDV8zKWaVCg.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">getMatrix:获取一个用零填充的初始矩阵</figcaption></figure><p id="73cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在用这个函数初始化一个矩阵时，我们得到的输出是:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="cd93" class="lb lc hi kx b fi ld le l lf lg">Printing the initial score matrix:<br/>[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]<br/>[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]<br/>[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]<br/>[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span></pre><p id="a9c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就像我们初始化空的分数矩阵一样，我们还初始化了一个回溯矩阵，它记录了每个细胞中哪个分数占主导地位，从而引导我们在比对后得到最终的序列集。这里，我们指定:</p><blockquote class="jl"><p id="673f" class="jm jn hi bd jo jp jq jr js jt ju jc dx translated"><em class="ka">第一个单元格= 'done' <br/>第一行除第一个以外的所有单元格= 'left' <br/>第一列除第一个以外的所有单元格= 'up' <br/>其他地方= '0' </em></p></blockquote><figure class="kc kd ke kf kg kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es lh"><img src="../Images/4ebecbcd7a8a038496751176240a8595.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jv9wnLC156SX1s7Zrg4jMA.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">traceBackMatrix:获取一个初始回溯矩阵，在第一列和第一行中分别填充 up 和 down 值，在其他位置填充 string(“0”)</figcaption></figure><p id="adee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在初始化追溯矩阵时，我们获得以下输出:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="7b0c" class="lb lc hi kx b fi ld le l lf lg">Printing the trace back matrix:<br/>['done', 'left', 'left', 'left', 'left', 'left', 'left', 'left', 'left', 'left', 'left']<br/>['up', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']<br/>['up', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']<br/>['up', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0']</span></pre><p id="2f62" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们定义一个 score 类，它将在调用一个对象时分配差距、匹配和不匹配的分数。</p><figure class="ks kt ku kv fd kh er es paragraph-image"><div class="er es li"><img src="../Images/e7d09c0d3724c94e1c2697bb13deff53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*tazdsNU8Xg2Flamb-diPow.png"/></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">ScoreParams 类:将 gap、match 和 mismatch 分值初始化为其对象，并在匹配字符时返回匹配或不匹配分值</figcaption></figure></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="46ab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">继续吧，人们，我们的框架代码就要完成了，我们准备好填充我们的矩阵，然后获得最终的答案。</p><p id="996c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们将填写分数和追溯矩阵。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="6a22" class="lb lc hi kx b fi ld le l lf lg">matrix[i][j] = max (          <br/>        matrix[i][j-1] + gap,<br/>        matrix[i-1][j] + gap,<br/>        matrix[i-1][j-1] + match(i,j)<br/>        0<br/>)</span></pre><p id="09cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面提到的片段是帮助我们填充所有矩阵单元格的指导规则。</p><p id="4ca5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为，</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="e63e" class="lb lc hi kx b fi ld le l lf lg">left = matrix[i][j-1] + gap<br/>up = matrix[i-1][j] + gap<br/>diag = matrix[i-1][j-1] + match(i,j)</span></pre><p id="3d15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的最大值也有助于我们填充追溯矩阵。</p><figure class="ks kt ku kv fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es lj"><img src="../Images/b8a2902f6cf42050304413bde2381404.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ulTE9K8SIg-mhijMAQPNUQ.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">localAlign:用分数填充全局比对矩阵，用方向填充回溯矩阵</figcaption></figure><p id="77b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在填写分数矩阵并将其打印出来后，我们获得的输出如下:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="7473" class="lb lc hi kx b fi ld le l lf lg">Printing the Score Matrix:<br/>[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]<br/>[0, 0, 0, 0, 10, 3, 0, 0, 0, 0, 0]<br/>[0, 0, 0, 0, 3, 20, 13, 6, 0, 0, 0]<br/>[0, 0, 0, 0, 0, 13, 30, 23, 16, 9, 2]</span><span id="418f" class="lb lc hi kx b fi lk le l lf lg">Printing the TraceBack Matrix:<br/>['done', 'left', 'left', 'left', 'left', 'left', 'left', 'left', 'left', 'left', 'left']<br/>['up', '0', '0', '0', 'diag', 'left', '0', '0', '0', '0', '0']<br/>['up', '0', '0', '0', 'up', 'diag', 'left', 'left', '0', '0', '0']<br/>['up', '0', '0', '0', '0', 'up', 'diag', 'left', 'left', 'left', 'left']</span></pre><p id="e5c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们到了获得比对序列的最后一步。对于对角线为'<strong class="ih hj"> diagonal </strong>'的 traceBackMatrix 单元格，两个序列都有匹配的字符，因此 y 序列中的字符被附加到结果序列中。</p><p id="c227" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当 traceBackMatrix 单元格表示“<strong class="ih hj">左</strong>”时，这意味着我们停留在同一行，并向后移动一列。类似地，当 traceBackMatrix 单元格表示“<strong class="ih hj">向上</strong>”时，这意味着我们停留在同一列并向上移动一行。在这两种情况下，字符都不会添加到结果序列中。</p><p id="0fb6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们到达'<strong class="ih hj"> done </strong>'单元格时，或者当我们的矩阵迭代器耗尽(负移入)时，或者当回溯循环值为' 0 '时，这个回溯循环中断。</p><p id="1c6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">遵循这些规则，我们编写了下面的函数，</p><figure class="ks kt ku kv fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es ll"><img src="../Images/995b1c8ef375edec1adfbe9d5a2e30c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T9VN8RWtQUwKD8cQo4laZA.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">getSequence:在局部对齐后获得最终序列</figcaption></figure><p id="0656" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在打印输出时，我们看到:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="c596" class="lb lc hi kx b fi ld le l lf lg">The best score obtained is: 30<br/>The best locally aligned sequence is from index 3 to index 6 of the string: catdogfish<br/>The sequence thus obtained: dog<br/>The sequence obtained via traceback is: dog</span></pre></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><p id="ce12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">恭喜读者！我们已经成功地从零开始在 Python 中本地比对了我们的序列。</p><p id="aa9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在以下网址查看完整代码:</p><div class="lm ln ez fb lo lp"><a href="https://github.com/risg99/Local-And-Global-Sequence-Alignment-Python-Scratch/blob/main/LocalAlignment.py" rel="noopener  ugc nofollow" target="_blank"><div class="lq ab dw"><div class="lr ab ls cl cj lt"><h2 class="bd hj fi z dy lu ea eb lv ed ef hh bi translated">risg 99/局部和全局序列比对-Python-Scratch</h2><div class="lw l"><h3 class="bd b fi z dy lu ea eb lv ed ef dx translated">该库包含 Python 中局部序列比对和全局序列比对的实现，来自…</h3></div><div class="lx l"><p class="bd b fp z dy lu ea eb lv ed ef dx translated">github.com</p></div></div><div class="ly l"><div class="lz l ma mb mc ly md km lp"/></div></div></a></div><p id="5e23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="me">感谢阅读！</em></p></div></div>    
</body>
</html>