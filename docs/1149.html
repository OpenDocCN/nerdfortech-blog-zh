<html>
<head>
<title>Catch ’em all with Kubernetes: Pokemon Go case Study</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Kubernetes抓住他们:口袋妖怪Go案例研究</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/catch-em-all-with-kubernetes-pokemon-go-case-study-37a43c5dce1b?source=collection_archive---------3-----------------------#2021-03-06">https://medium.com/nerd-for-tech/catch-em-all-with-kubernetes-pokemon-go-case-study-37a43c5dce1b?source=collection_archive---------3-----------------------#2021-03-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1acb4d3c0bddf2e0d2ef7e19f7b4df06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*LMPqrU1sDcAk93ZU_x25nQ.gif"/></div></div></figure><p id="9c78" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于这里所有的千禧一代来说，口袋妖怪从小就在我们的心中。由于口袋妖怪是由任天堂公司制作的，口袋妖怪游戏只在任天堂switch上提供。任天堂是掌机之王。但目前，Niantics与任天堂合作发布了一款适用于Android和iOS设备的口袋妖怪游戏。POKEMON去吧。这是第一个在手持设备以外的设备上玩的口袋妖怪游戏。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jo"><img src="../Images/741db62f2f3762324d34d41d1cc489e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*XPUQ7uz8EM7SqzoZh_2Zag.jpeg"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">POKEMON围棋</figcaption></figure><p id="2e9a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这款手机游戏还没上市就在市场上引起了轩然大波。游戏一经推出，对该公司的评价就大大提高了。毕竟是口袋妖怪。在澳大利亚和新西兰推出后的15分钟内，玩家流量飙升，远远超出了Niantic的预期。这对Niantic的产品和工程团队来说是第一次表明他们手上有真正特别的东西。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es jx"><img src="../Images/21d6841a42d0cac01f6d42084f5f8229.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*4ZjTVrGVCdmAx2QgQSQ8Yw.png"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">《口袋妖怪Go》超出预期</figcaption></figure><p id="9fe2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Pokemon Go是通过谷歌云推出的。球队的目标是1倍的球员流量，最坏的情况估计大约是5X这个目标。Pokémon GO的受欢迎程度迅速将玩家流量飙升至最初目标的50倍，是最坏情况估计的10倍。在全球发行的短短几周内，这款游戏在<strong class="is hj">的下载量就达到了5亿多次</strong>，在<strong class="is hj">平均每天有2000多万活跃用户</strong>。作为回应，Google CRE代表Niantic无缝地提供了额外的容量，以远远领先于他们创纪录的增长。</p><h1 id="f675" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">他们是如何在如此短的时间内实现横向扩展的？</h1><p id="9c60" class="pw-post-body-paragraph iq ir hi is b it kw iv iw ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn hb bi translated">这个问题的答案是集装箱化。Pokemon Go是一款基于容器的应用。游戏的应用逻辑运行在由开源软件Kubernetes项目驱动的谷歌容器引擎(GKE)上。</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/9314861921e7153b3cd71c8359aa33d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/1*GEgL3KSyH42G4HcxFkGPFg.png"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">码头工人</figcaption></figure><p id="9fe0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">容器:</strong>容器是一个标准的软件单元，它封装了代码及其所有依赖项，因此应用程序可以快速可靠地从一个计算环境运行到另一个计算环境。这意味着我们可以通过运行这些容器来运行应用程序，它们有自己的依赖关系，并且是隔离的，因此容器之间的冲突不会产生错误。此外，容器是轻量级的，只是为了运行一些进程而创建的，因此我们可以在几秒钟内提供和终止容器。尽管隔离是最好的方法，但是我们需要多个容器相互通信，因为单个容器只有一个进程。例如，带有web应用程序的容器需要与带有数据库的容器通信。这里，我们需要一个容器管理服务</p><figure class="jp jq jr js fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/90a5385d58e59efd635efe02d5fdb6cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*GE_wZBO72EL7HOd5lEhtpQ.png"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">库伯内特斯</figcaption></figure><p id="22e7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Kubernetes:  Kubernetes是一个开源的容器编排系统，用于自动化计算机应用程序的部署、扩展和管理。它最初是由谷歌设计的，现在由云原生计算基金会维护。Kubernetes是目前容器编排的最佳工具。Kubernetes还提供角色和IAM等功能，以及适合我们需求的各种网络解决方案。</p><p id="0b83" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Kubernetes服务由谷歌云提供，即谷歌Kubernetes引擎。Google Kubernetes Engine(<strong class="is hj">GKE</strong>)为使用Google基础设施部署、管理和扩展您的容器化应用程序提供了一个托管环境。<strong class="is hj"> GKE </strong>环境由组合在一起形成一个集群的多台机器(计算引擎实例)组成。Pokemon Go使用这项服务和十几项服务。Pokémon GO在谷歌云上使用了十几项服务。事实上，这是Kubernetes在Google Container Engine上最大的一次部署。</p><p id="538b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Kubernetes部署用于告诉Kubernetes如何创建或修改包含容器化应用程序的pod实例。<strong class="is hj">部署</strong>可以扩展副本单元的数量，以可控的方式部署更新的代码，或者在必要时回滚到更早的<strong class="is hj">部署</strong>版本。</p><p id="d858" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">部署人员会密切关注吊舱，如果任何吊舱因任何故障而关闭，它会尝试让吊舱重新联机。这意味着我们不必一直监视运行应用程序的每个节点上的每个容器。在Kubernetes的帮助下，Niantics和GoogleCloud能够横向扩展节点，从而扩展pod的数量，进而扩展容器的数量。部署等资源有助于非常轻松地自动化和管理应用程序群集，从而减少停机时间。</p><p id="66a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是Niantics和Google Cloud能够管理如此巨大的游戏流量的原因。</p><p id="25c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">谢谢大家！</p><p id="ef24" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"># vimaldaga # right education # education redefine # right mentor # world recordholder # Linux world # makingindiafutureready # righ education # arthbylw # ansibleglaxy # rightansibleconcepts # k8s #用例#自动化# kubernetes #微服务</p></div></div>    
</body>
</html>