<html>
<head>
<title>Lifting State up and Callbacks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提升状态和回调</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/lifting-state-up-and-callbacks-7a19d0bdbe53?source=collection_archive---------1-----------------------#2021-07-28">https://medium.com/nerd-for-tech/lifting-state-up-and-callbacks-7a19d0bdbe53?source=collection_archive---------1-----------------------#2021-07-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="b1ca" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">颤振状态管理编年史4</h1><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/e7e6de9bcbbd256c4b0f30864d3da5a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mmRwSA0anUxYuBQcDfKRsg.png"/></div></div></figure><p id="7197" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">所以我今天想写关于继承的窗口小部件，但是意识到提升状态和回调的概念对于更好地理解继承的窗口小部件和为继承的窗口小部件打下适当的基础可能是至关重要的，所以我从这里开始。</p><p id="ea32" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">状态管理有点有趣，它给我们的代码带来了更多的活力，使我们的编程更具反应性。</p><blockquote class="kn ko kp"><p id="d1fe" class="jp jq kq jr b js jt ju jv jw jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl km hb bi translated">然而，使用有状态小部件和flutter钩子的状态管理更多地处理本地状态；其中改变的状态或信息仅被绑定到一个小部件，并且在任何其他地方都没有用(需要)，因此对该状态的改变仅影响它所绑定的那个小部件的重建。</p></blockquote><p id="2b3c" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">但是如果我们需要一个依赖于多个小部件的状态呢？如果我们想要一个状态，当它改变时，触发依赖它的所有小部件的重建，那该怎么办？T3】</p><p id="d54f" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">比方说，我们有一个显示点击次数的BlueSquare小部件，定义如下</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ku"><img src="../Images/7262a202c37220dc93fb86323a8d69d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vPKbOC6eQcuk_I8uYnG9HA.png"/></div></div></figure><p id="546b" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">其中方块上的每一次点击都自动用该方块上更新的总点击次数来更新所显示的文本。假设我们想要一组蓝色方块，当其中任何一个被点击时，该组中的所有蓝色方块显示用户点击的累计次数。</p><p id="dedf" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">这意味着，点击次数不仅仅是一个单独的blueSquare对象的局部状态，而是一个依赖于许多其他对象的状态，也可以被多个对象操纵。</p><p id="f7c1" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated"><strong class="jr hj"> <em class="kq">那么我们该如何着手呢？</em> </strong></p><blockquote class="kn ko kp"><p id="e494" class="jp jq kq jr b js jt ju jv jw jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl km hb bi translated">在flutter中，我们有提升状态的概念，这意味着，我们获取一组小部件所依赖的状态，并将其放置在与包含所有这些小部件的父小部件一样高的位置，以便您可以将该状态传递给所有需要它的小部件(这类似于对来自react的小部件进行适当钻探的概念)。</p></blockquote><p id="b610" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">修改我们的BlueSquare小部件以接受状态“drill ”,这使得小部件不那么复杂，并且它不需要成为有状态的小部件(因为它没有自己的本地状态需要管理)。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ku"><img src="../Images/e80bca7157471ef1e69228913f462a17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q8ThAeS3ILUB8te77_4haQ.png"/></div></div></figure><p id="e0e9" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">然后我们将点击状态转移到父窗口小部件，父窗口小部件自动需要有状态，因为它将管理状态。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ku"><img src="../Images/04c45c197222ba434a36c559b9b3bdc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sv6JStQ_OvoyoJ-qeC7r8g.png"/></div></div></figure><p id="3f9f" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">到目前为止，这看起来相当不错，我们所有的蓝方都有一个共同的点击量来源，这太神奇了。但是测试代码，很明显，点击任何blueSquare对象，我们都没有观察到任何变化。</p><p id="2973" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">再看一下代码，我们发现每个blueSquare对象的ontap函数都没有任何功能，我们不能就这样给它添加一个设置状态，因为它现在是一个无状态小部件。</p><p id="5131" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated"><strong class="jr hj"> <em class="kq">实际上，我们正在寻找的是一种能够在有新信息时(例如点击；这将更新轻敲的次数)。</em>T3】</strong></p><p id="f688" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated"><strong class="jr hj"> <em class="kq">那么我们现在如何确保在每个blueSquare对象中的点击更新点击状态并触发所有其他blueSquare对象的重建呢？</em> </strong></p><p id="7a81" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">简单地说，我们如何将信息传递给父小部件？</p><p id="e040" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">我们使用回调函数，是的回调函数</p><p id="7d41" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">这里，我们在父窗口小部件中创建一个函数，并将该函数作为参数传递给子窗口小部件，这些函数使用其参数作为注入信息的手段。或者当从子部件回调时，它在父部件的范围内执行在其中定义的代码，并且它可以访问和控制父部件中的变量、参数和状态。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ku"><img src="../Images/1a107fa4130625bf677314fdb7ac5624.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WxqmjFOgDM1FUkrsCdrc7g.png"/></div></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kv"><img src="../Images/b25edcd5a4049a87165b34ac4828951d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MDeRI0JsiLW5rEbA4gv6LA.png"/></div></div></figure><p id="bde3" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">基本上，我们已经在主父窗口小部件中创建了一个函数来保存我们所有的BlueSquare窗口小部件，该函数被定义为更新setState方法中的clicks变量的值，这样它就可以触发父类的重新构建，并随之重新构建所有脏的子窗口小部件。</p><p id="0f4d" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">我们将函数作为参数传递给所有BlueSquare函数，在BlueSquare小部件中使用时，它位于onTap函数中，等待用户点击它以便调用它。</p><p id="5fb6" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">这非常有效，有助于我们处理这样的情况:一个父窗口小部件包含了它的几个子窗口小部件所依赖和修改的数据，这依赖于它们的布局，因此需要重新构建。</p><p id="472f" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">正如我们所看到的，试图以这种方式实现非本地化状态管理的小部件之间存在很强的耦合，例如，如果将来发生了什么事情，我们不需要BlueSquare对象来显示点击次数，我们需要修改BlueSquare小部件，我们还需要修改父小部件的实现，如果我们在一个大项目中有一些复杂的状态和多个级别，这将是一项非常繁琐的工作。</p><p id="a2f4" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">也</p><p id="0645" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">我们可以看到开始有太多的钻取，假设我们在BlueSquare小部件中有一个小部件，它也需要修改和访问点击次数，如果它也需要，有时一些中间小部件可能不需要点击值，但如果一个子小部件需要，我们将需要通过中间值钻取点击值(即使它不需要)，直到我们找到真正需要它的小部件。这就成了问题。</p><p id="0512" class="pw-post-body-paragraph jp jq hi jr b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km hb bi translated">在我们的下一篇文章中，我们将研究如何用继承的小部件解决这样的问题。</p></div></div>    
</body>
</html>