<html>
<head>
<title>Swift Leetcode Series: Brick Wall</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift Leetcode 系列:砖墙</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/swift-leetcode-series-brick-wall-273f424e76b4?source=collection_archive---------12-----------------------#2021-04-22">https://medium.com/nerd-for-tech/swift-leetcode-series-brick-wall-273f424e76b4?source=collection_archive---------12-----------------------#2021-04-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="e287" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">查看适用于 Leetcode 554 的 Swift 解决方案</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/3bc358327d1c5f21ad64b0cf1f8fcc75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_cilZa6CldTtG-AP_hPABg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">四月 Leetcode 挑战:第 22 天</figcaption></figure><div class="jn jo ez fb jp jq"><a href="https://theswiftnerd.com/leetcode-brick-wall-solution/" rel="noopener  ugc nofollow" target="_blank"><div class="jr ab dw"><div class="js ab jt cl cj ju"><h2 class="bd hj fi z dy jv ea eb jw ed ef hh bi translated">砖墙(Leetcode 554)</h2><div class="jx l"><h3 class="bd b fi z dy jv ea eb jw ed ef dx translated">难度:标签:四月 Leetcode 挑战:第 22 天你面前有一堵砖墙。这堵墙是长方形的…</h3></div><div class="jy l"><p class="bd b fp z dy jv ea eb jw ed ef dx translated">theswiftnerd.com</p></div></div><div class="jz l"><div class="ka l kb kc kd jz ke jh jq"/></div></div></a></div><p id="76aa" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">你也可以通过上面的链接在 Swift Nerd 博客上阅读完整的故事。</p><h1 id="02ae" class="lb lc hi bd ld le lf lg lh li lj lk ll io lm ip ln ir lo is lp iu lq iv lr ls bi translated">问题陈述</h1><p id="d0fa" class="pw-post-body-paragraph kf kg hi kh b ki lt ij kk kl lu im kn ko lv kq kr ks lw ku kv kw lx ky kz la hb bi translated">你面前有一堵砖墙。墙是长方形的，有几排砖。这些砖块高度相同，但宽度不同。你要从<strong class="kh hj">顶</strong>到<strong class="kh hj">底</strong>画一条垂直线，穿过<strong class="kh hj">最少的</strong>砖块。</p><p id="d6c7" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">砖墙由一列行表示。每一行都是一个整数列表，从左到右表示这一行中每个砖块的宽度。</p><p id="49f6" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">如果你的线穿过砖块的边缘，那么砖块不被认为是交叉的。你需要找出如何画出穿过最少砖块的线，并返回穿过砖块的数量。</p><p id="cf5e" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">你不能只沿着墙的两条垂直边中的一条画一条线，在这种情况下，这条线显然不会穿过任何砖块。</p><p id="fd3c" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated"><strong class="kh hj">举例:</strong></p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="51a8" class="md lc hi lz b fi me mf l mg mh"><strong class="lz hj">Input:</strong> [[1,2,2,1],<br/>        [3,1,2],<br/>        [1,3,2],<br/>        [2,4],<br/>        [3,1,2],<br/>        [1,3,1,1]]</span><span id="8019" class="md lc hi lz b fi mi mf l mg mh"><strong class="lz hj">Output:</strong> 2</span><span id="5826" class="md lc hi lz b fi mi mf l mg mh"><strong class="lz hj">Explanation:</strong></span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mj"><img src="../Images/2972b17e843e893d6b96fe975f61247e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8sM_24v7USs9_5y3.png"/></div></div></figure><h1 id="38a6" class="lb lc hi bd ld le lf lg lh li lj lk ll io lm ip ln ir lo is lp iu lq iv lr ls bi translated">限制</h1><ol class=""><li id="8a6e" class="mk ml hi kh b ki lt kl lu ko mm ks mn kw mo la mp mq mr ms bi translated">不同行砖块的宽度总和相同，不会超过 INT_MAX。</li><li id="59c6" class="mk ml hi kh b ki mt kl mu ko mv ks mw kw mx la mp mq mr ms bi translated">每行砖的数量在[1，10，000]的范围内。墙的高度在[1，10，000]的范围内。这堵墙的总砖数不会超过 2 万块。</li></ol><h1 id="1a9e" class="lb lc hi bd ld le lf lg lh li lj lk ll io lm ip ln ir lo is lp iu lq iv lr ls bi translated">解决办法</h1><p id="5899" class="pw-post-body-paragraph kf kg hi kh b ki lt ij kk kl lu im kn ko lv kq kr ks lw ku kv kw lx ky kz la hb bi translated">如果我们能理解你实际需要计算什么，问题就简单了。这是一个贪婪问题的例子，我们需要最小化交叉砖块的数量(或者通过它们平分)。由于砖块具有不同的长度，并且它们将相对于其他砖块层水平堆叠，因此砖块末端重合的点将会出现。把注意力集中在图片的一小部分，以便更好地理解。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es my"><img src="../Images/187ecafb0af6a0ce9eb4f36e45592fbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/0*OW2_RT5SwFVWgfu8.png"/></div></figure><p id="dfc0" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">在同一垂直线上结束的砖块需要从左边和右边有相同的偏移量。可以通过将从开始到当前砖块的所有砖块的长度相加来计算偏移量。我们可以维护一个字典来存储偏移的频率。由于一个偏移量在单个砖块行中只能出现一次，因此计数值将表示在该距离处结束的砖块的数量。</p><h1 id="25d4" class="lb lc hi bd ld le lf lg lh li lj lk ll io lm ip ln ir lo is lp iu lq iv lr ls bi translated">前缀和</h1><p id="2198" class="pw-post-body-paragraph kf kg hi kh b ki lt ij kk kl lu im kn ko lv kq kr ks lw ku kv kw lx ky kz la hb bi translated">为了计算偏移量，我们需要计算每一行的前缀总和。这可以简单地通过初始化一个行和变量，遍历砖块数组，并将当前砖块添加到和变量中来完成。在计算前缀和之后，我们需要增加字典中的频率。请注意，我们不能考虑起点和终点(因为所有砖块都在公共垂直线上开始和结束，所以答案在这两条线上总是零)。在计算前缀总和时，我们需要忽略每一行中的最后一块砖，这样就不会计算它的前缀总和。</p><h1 id="489e" class="lb lc hi bd ld le lf lg lh li lj lk ll io lm ip ln ir lo is lp iu lq iv lr ls bi translated">贪婪的方法</h1><p id="1808" class="pw-post-body-paragraph kf kg hi kh b ki lt ij kk kl lu im kn ko lv kq kr ks lw ku kv kw lx ky kz la hb bi translated">这个问题是一个经典的贪婪问题，需要最小化/最大化一些量来得到结果。为了穿过最少的砖块，我们需要最大化在一条共同的垂直线结束的砖块。答案最终将是总行数和最大行数之间的差值。</p><pre class="iy iz ja jb fd ly lz ma mb aw mc bi"><span id="508c" class="md lc hi lz b fi me mf l mg mh">min_crossed_bricks = total_brick_rows - max_rows_with_common_endpoint</span></pre><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="mz na l"/></div></figure><h1 id="a45c" class="lb lc hi bd ld le lf lg lh li lj lk ll io lm ip ln ir lo is lp iu lq iv lr ls bi translated">复杂性分析</h1><p id="7d88" class="pw-post-body-paragraph kf kg hi kh b ki lt ij kk kl lu im kn ko lv kq kr ks lw ku kv kw lx ky kz la hb bi translated">因为我们正在遍历每一块砖，所以操作将等于砖的总数。</p><p id="7b69" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated"><em class="nb">时间</em> = <strong class="kh hj"> O(N * M) </strong>其中 N 行，M 是单行中可能的最大砖块数。</p><p id="d901" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated"><em class="nb">空格</em> = <strong class="kh hj"> O(N * M) </strong></p></div><div class="ab cl nc nd gp ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="hb hc hd he hf"><p id="ffd3" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">感谢您的阅读。如果你喜欢这篇文章，并发现它很有用，请分享并像野火一样传播它！</p><p id="4c44" class="pw-post-body-paragraph kf kg hi kh b ki kj ij kk kl km im kn ko kp kq kr ks kt ku kv kw kx ky kz la hb bi translated">你可以在<a class="ae nj" href="https://theswiftnerd.com/" rel="noopener ugc nofollow" target="_blank">the swift nerd</a>|<a class="ae nj" href="https://www.linkedin.com/in/varunrathi28/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae nj" href="https://github.com/varunrathi28" rel="noopener ugc nofollow" target="_blank">Github</a>上找到我</p></div></div>    
</body>
</html>