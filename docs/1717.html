<html>
<head>
<title>Python: Instance vs Static vs Class vs Abstract Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python:实例vs静态vs类vs抽象方法</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/python-instance-vs-static-vs-class-vs-abstract-methods-1952a5c77d9d?source=collection_archive---------3-----------------------#2021-04-03">https://medium.com/nerd-for-tech/python-instance-vs-static-vs-class-vs-abstract-methods-1952a5c77d9d?source=collection_archive---------3-----------------------#2021-04-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1c2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python为OOPS概念提供了广泛的灵活性，但是它被低估了/不为人所知。今天，让我们来看看Python脚本中不同方法的用法。</p><ol class=""><li id="1182" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">实例方法</li><li id="dbe1" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">静态法</li><li id="0f9e" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">分类方法</li><li id="711e" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">抽象方法</li></ol><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es jr"><img src="../Images/bc0a0b88ab23caf355325a77c3c68333.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fDMz-4NALqPt7YP5"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">凯文·Ku在<a class="ae kh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="272a" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><strong class="ak">实例方法</strong></h1><p id="f90d" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">实例方法是我们在Python中创建类时经常使用的非常基本和简单的方法。如果我们想打印一个实例变量或实例方法，我们必须创建一个所需类的对象。它们访问唯一的数据，即实例方法将能够访问每个实例唯一的数据和属性。</p><pre class="js jt ju jv fd ll lm ln lo aw lp bi"><span id="67d2" class="lq kj hi lm b fi lr ls l lt lu">class RECTANGLE:<br/><br/>    def number_of_sides(self):<br/>        print(“I have 2 sides”)</span></pre><ol class=""><li id="9f6a" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">实例方法将self作为第一个参数。</li><li id="4110" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">实例方法不需要Decorator。</li></ol><h1 id="d541" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">静态法</h1><p id="b041" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">静态方法以某种方式与类相关，但不需要访问任何特定于类的数据。即<strong class="ih hj"> self </strong>，不一定是该方法的第一个参数，甚至不需要实例化一个实例</p><p id="3ed4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">静态方法将不能访问claas中的任何东西，完全自包含/隔离模式</p><pre class="js jt ju jv fd ll lm ln lo aw lp bi"><span id="a93f" class="lq kj hi lm b fi lr ls l lt lu">class RECTANGLE:<br/><br/>     def number_of_sides(self):<br/>          print(“I have 2 sides”)</span><span id="f2d3" class="lq kj hi lm b fi lv ls l lt lu">     @staticmethod<br/>     def info():<br/>         print("inside the Square class")</span></pre><ol class=""><li id="4281" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">当一个类中有一个与类逻辑相关的<strong class="ih hj">方法，但不一定与任何特定的实例交互时，使用静态方法。</strong></li><li id="2f58" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">静态方法是使用<strong class="ih hj"> @staticmethod </strong>装饰器创建的。</li></ol><h1 id="95a8" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">分类方法</h1><p id="5563" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">类方法是绑定到类而不是类的对象的方法。类方法知道它们的类。也就是说，它们不能访问特定的实例数据。在class方法中，函数参数的第一个参数是class，这是一个隐式的第一个参数。</p><p id="af4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">类方法可以访问指定类中的有限方法，它可以修改类的特定细节</p><pre class="js jt ju jv fd ll lm ln lo aw lp bi"><span id="d0f9" class="lq kj hi lm b fi lr ls l lt lu">class RECTANGLE:</span><span id="b59a" class="lq kj hi lm b fi lv ls l lt lu">    name = "RECTANGLE"<br/>    def number_of_sides(self):<br/>        print(“I have 2 sides”)<br/>    <br/>    @classmethod<br/>    def info_class_name(cls):<br/>        print(cls.name)</span></pre><ul class=""><li id="9457" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc lw jj jk jl bi translated">类方法是使用<strong class="ih hj"> @classmethod </strong>装饰器创建的。</li><li id="2853" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc lw jj jk jl bi translated">class方法可以访问类的状态，因为它接受指向类而不是对象实例的类参数。</li></ul><h1 id="a4b7" class="ki kj hi bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">抽象方法</h1><p id="d4d8" class="pw-post-body-paragraph if ig hi ih b ii lg ik il im lh io ip iq li is it iu lj iw ix iy lk ja jb jc hb bi translated">抽象方法是有声明但没有实现的方法。当我们设计大型功能单元时，我们使用一个抽象类。一个抽象类可以被认为是其他类的蓝图。</p><p id="eedb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Python中，抽象类没有直接的前向实现，我们需要导入abc(抽象基类)。<strong class="ih hj"> <em class="lx"> ABC </em> </strong>的工作原理是将基类的方法修饰为抽象，然后将具体的类注册为概念基的实现。</p><pre class="js jt ju jv fd ll lm ln lo aw lp bi"><span id="2219" class="lq kj hi lm b fi lr ls l lt lu">from abc import ABC, abstractmethod<br/>class POLYGON(ABC):</span><span id="ad25" class="lq kj hi lm b fi lv ls l lt lu">    @abstractmethod<br/>    def number_of_sides(self):<br/>        pass</span><span id="1db0" class="lq kj hi lm b fi lv ls l lt lu">class RECTANGLE(POLYGON):<br/><br/>    def number_of_sides(self):<br/>        print(“I have 2 sides”)</span></pre><ol class=""><li id="cde9" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">抽象方法是使用<strong class="ih hj"> @abstractmethod </strong>装饰器创建的。</li><li id="16e7" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">它们重写基类的属性。</li></ol></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><p id="d51c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望这篇文章给出了理解Python OOPS清单中不同类型方法的要点，请在评论中分享您的想法。</p></div></div>    
</body>
</html>