<html>
<head>
<title>semantically and automatically bump apps versions and releases using GitLab pipeline</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 GitLab pipeline 从语义上自动提升应用版本和发布</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/auto-bump-apps-versions-and-releases-using-gitlab-pipeline-e32f1d7fa3ee?source=collection_archive---------0-----------------------#2021-03-13">https://medium.com/nerd-for-tech/auto-bump-apps-versions-and-releases-using-gitlab-pipeline-e32f1d7fa3ee?source=collection_archive---------0-----------------------#2021-03-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if ig ih"><p id="09ff" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">我们在这篇文章中试图解决的问题是，我们需要控制、版本控制和语义自动标记我们的应用程序，以减少人为错误</p></blockquote><p id="6df0" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">我们的目标是使用 GitLab CI/CD 和<a class="ae jk" href="https://github.com/semantic-release/semantic-release" rel="noopener ugc nofollow" target="_blank">语义发布</a>来解决这个问题</p><p id="e5ce" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated"><strong class="il hj">什么是语义释放？</strong></p><p id="7a9d" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">semantic-release 自动化了整个包发布工作流，包括确定下一个版本号、生成发布说明以及发布包。</p><p id="df4a" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">它是如何工作的？</p><p id="f4f4" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">这里的关键是您的提交消息格式，语义发布使用提交消息来确定代码库中的更改类型。遵循提交消息的形式化约定，semantic-release 自动确定下一个<a class="ae jk" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">语义版本</a>号，生成变更日志，并发布发布。</p><p id="24e2" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">例如，如果您需要添加一个热修复，您的提交消息应该以这种格式编写</p><p id="94cf" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated"><code class="du jl jm jn jo b">fix(pencil): {Your message}</code></p><p id="faff" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">当您将一个“拉”请求与一个“发布”分支合并时，您应该有一个补丁发布，例如，如果在合并和批量发布后，分支主文件中最后创建的标记是 1.0.0，您应该有一个新的标记 1.0.1</p><p id="5a28" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">如果您想添加一个特性，您的提交消息应该是这样的</p><p id="b1b4" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated"><code class="du jl jm jn jo b">feat(pencil): {Your message}</code></p><p id="83b3" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">在那之后，你的下一个版本将会是 1.1.0，如果最后一个标签是 1.0.0 等等，你可以在这里找到所有的格式</p><p id="f6e3" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated"><a class="ae jk" href="https://github.com/semantic-release/semantic-release" rel="noopener ugc nofollow" target="_blank">https://github.com/semantic-release/semantic-release</a></p><p id="8742" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated"><strong class="il hj">怎么用？</strong></p><p id="05dc" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">要安装“语义发布”,您应该拥有 node ≥= 10.18</p><p id="abf1" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">然后运行以下命令来安装该软件包</p><pre class="jp jq jr js fd jt jo ju jv aw jw bi"><span id="c79d" class="jx jy hi jo b fi jz ka l kb kc">npm install --save-dev semantic-release</span></pre><p id="6bc9" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">对于其他类型的应用程序，如 python 或 maven，您可以将其全局安装在您的 CI 环境中，语义支持许多流行的 CI 环境，如 CircleCI、Github actions 和 GitLab，我们将在后面看到这一点。</p><p id="9b30" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">安装软件包后，您应该定义语义发布配置。这一步可以通过多种方式完成</p><p id="bd6b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">我强烈推荐使用”。releaserc”文件，您也可以使用 package.json 文件来配置它</p><p id="be67" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">我们需要告诉“语义”关于我们的发布分支</p><pre class="jp jq jr js fd jt jo ju jv aw jw bi"><span id="67e9" class="jx jy hi jo b fi jz ka l kb kc">{<br/>  "release": {<br/>    "branches": ["master", "next"]<br/>  }<br/>}</span></pre><p id="13c1" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">这个配置将使“语义”跳过任何其他分支，在分支列表之外创建一个发布</p><p id="6816" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">你也可以像这样配置你需要的插件</p><pre class="jp jq jr js fd jt jo ju jv aw jw bi"><span id="53af" class="jx jy hi jo b fi jz ka l kb kc">{<br/>  "plugins": ["@semantic-release/commit-analyzer", "@semantic-release/release-notes-generator", "@semantic-release/npm"]<br/>}</span></pre><p id="9009" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">从这里你可以看到更多关于插件的内容</p><p id="f7ea" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated"><a class="ae jk" href="https://github.com/semantic-release/semantic-release/blob/master/docs/usage/plugins.md" rel="noopener ugc nofollow" target="_blank">https://github . com/semantic-release/semantic-release/blob/master/docs/usage/plugins . MD</a></p><p id="a454" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">在创建配置文件之后，并且在使用有效格式或合并请求向发布分支提交更改之后，您可以运行以下命令来生成版本并创建标记</p><pre class="jp jq jr js fd jt jo ju jv aw jw bi"><span id="1ecc" class="jx jy hi jo b fi jz ka l kb kc">npx semantic-release</span></pre><p id="92ac" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated"><strong class="il hj">npx 是什么？</strong></p><p id="f4d2" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">npx 是“npm exec”的缩写，是一个 CLI，用于在本地 node_modules 文件夹或$PATH 中查找和执行 npm 二进制文件。如果找不到二进制文件，npx 将下载所需的包，并从其缓存位置执行它。该工具与 npm &gt;= 5.2 捆绑在一起，或者可以通过 npm install -g npx 安装。</p><p id="ef93" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated"><strong class="il hj">更复杂的案件</strong></p><p id="a21e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">例如，如果我们创建了一个应用程序的新功能，版本变为 1.1.0，而我们的一些客户或用户仍然使用 1.0.0，他们不使用特色功能，他们报告 1.0.0 上有一个需要维护的错误，在这种情况下我们该怎么办？</p><p id="7eb0" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">语义发布允许基于多个 Git 分支和发布渠道来管理和自动化复杂的发布工作流。</p><ul class=""><li id="2aad" class="kd ke hi il b im in iq ir jh kf ji kg jj kh jg ki kj kk kl bi translated">通过分销渠道将某些版本分发给特定的用户群</li><li id="e73d" class="kd ke hi il b im km iq kn jh ko ji kp jj kq jg ki kj kk kl bi translated">通过分支机构合并管理分销渠道上产品的可用性</li><li id="a699" class="kd ke hi il b im km iq kn jh ko ji kp jj kq jg ki kj kk kl bi translated">并行维护多行发布</li><li id="b19f" class="kd ke hi il b im km iq kn jh ko ji kp jj kq jg ki kj kk kl bi translated">在每次 Git 推送一个版本增量的正常流程之外，开发大型的未来版本</li></ul><p id="e818" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">因此，在我们的案例中是关于维护的，在这种情况下，我们需要配置我们的分支来支持维护流程。</p><pre class="jp jq jr js fd jt jo ju jv aw jw bi"><span id="6d47" class="jx jy hi jo b fi jz ka l kb kc">branches: [<br/>  "+([0-9])?(.{+([0-9]),x}).x",<br/>   "master"<br/>]</span></pre><p id="2bf6" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">在配置中，我们告诉 semantic，任何具有这个模式 1.0.x 或 1.1.x 等的分支都是发布分支，因此我们可以执行以下步骤来维护旧版本</p><ul class=""><li id="0dcd" class="kd ke hi il b im in iq ir jh kf ji kg jj kh jg ki kj kk kl bi translated">从旧标签创建一个分支，例如，我们需要维护 1.0.0 版，而不需要对包含新特性的最新 1.1.0 版进行修改</li></ul><pre class="jp jq jr js fd jt jo ju jv aw jw bi"><span id="5a92" class="jx jy hi jo b fi jz ka l kb kc"> git checkout -b 1.0.x v1.0.0</span></pre><ul class=""><li id="e0a1" class="kd ke hi il b im in iq ir jh kf ji kg jj kh jg ki kj kk kl bi translated">添加您的修补程序，并提交一个消息，如一个例子</li></ul><pre class="jp jq jr js fd jt jo ju jv aw jw bi"><span id="4843" class="jx jy hi jo b fi jz ka l kb kc">git commit -m "<!-- -->fix(pencil): {Your message}" </span></pre><ul class=""><li id="2792" class="kd ke hi il b im in iq ir jh kf ji kg jj kh jg ki kj kk kl bi translated">推你的树枝</li><li id="964d" class="kd ke hi il b im km iq kn jh ko ji kp jj kq jg ki kj kk kl bi translated">然后在这个分支上运行语义发布</li></ul><pre class="jp jq jr js fd jt jo ju jv aw jw bi"><span id="a8ac" class="jx jy hi jo b fi jz ka l kb kc">npx semantic-release</span></pre><p id="a4e4" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">现在我们将有一个新的修补程序标签 1.0.1</p><p id="ba5e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">使用工作流有很多选项，您可以像这样检查</p><p id="74b9" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated"><a class="ae jk" href="https://github.com/semantic-release/semantic-release/blob/master/docs/usage/workflow-configuration.md" rel="noopener ugc nofollow" target="_blank">https://github . com/semantic-release/semantic-release/blob/master/docs/usage/workflow-configuration . MD</a></p><p id="295b" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated"><strong class="il hj">语义在幕后做什么？</strong></p><p id="3968" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">如果您想查看，只需在发布命令中添加 debug 标志</p><pre class="jp jq jr js fd jt jo ju jv aw jw bi"><span id="2317" class="jx jy hi jo b fi jz ka l kb kc">npx semantic-release --debug</span></pre><p id="f7b4" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">下图解释了这些步骤</p><figure class="jp jq jr js fd ks er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es kr"><img src="../Images/228775ff442d5dd9617480ce30fe064a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fykheM387lFxF2RUSg1itg.png"/></div></div></figure><p id="ef7f" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated"><strong class="il hj">使用 GitLab 的 CI/CD 中的语义</strong></p><p id="7fcf" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">在这一部分中，我将解释并创建一个自动构建、测试、发布和部署的工作流。</p><p id="11cf" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">假设我们有一个 nodejs 应用程序或任何类型的应用程序，我们需要构建、测试、发布版本并将其部署在我们的 Kubernetes 集群中。当然，我将跳过关于 docker 构建和部署到 K8s 的讨论，但是如果你想了解这一点，你可以在完成这篇文章后查看我以前的文章😆</p><div class="kz la ez fb lb lc"><a href="https://regoo707.medium.com/gitlab-ci-cd-from-git-to-k8s-a57c3bf3df3a" rel="noopener follow" target="_blank"><div class="ld ab dw"><div class="le ab lf cl cj lg"><h2 class="bd hj fi z dy lh ea eb li ed ef hh bi translated">从 git 到 K8s 的 GitLab CI/CD</h2><div class="lj l"><h3 class="bd b fi z dy lh ea eb li ed ef dx translated">在本文中，我将解释如何使用 GitLab CI/CD 来构建、测试和部署 nodejs 应用程序到 K8s(通过 rancher API)</h3></div><div class="lk l"><p class="bd b fp z dy lh ea eb li ed ef dx translated">regoo707.medium.com</p></div></div><div class="ll l"><div class="lm l ln lo lp ll lq kx lc"/></div></div></a></div><p id="3d77" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">我们需要什么？</p><ul class=""><li id="a3bf" class="kd ke hi il b im in iq ir jh kf ji kg jj kh jg ki kj kk kl bi translated">非发布分支上的每一次提交，我们都需要运行、构建并创建一个 docker 映像，该映像由开发人员测试的分支名称标记</li><li id="75b9" class="kd ke hi il b im km iq kn jh ko ji kp jj kq jg ki kj kk kl bi translated">releases 分支上的每次提交，我们都需要基于这个分支上的最新标签来创建一个发布，并且依赖于我们之前解释过的提交消息形式</li><li id="4bac" class="kd ke hi il b im km iq kn jh ko ji kp jj kq jg ki kj kk kl bi translated">我们需要构建、测试、创建 docker 映像以及将我们的应用程序部署到 K8s 或任何我们正在使用它的环境中的每一个标签，我们不会关注这一点。</li><li id="e384" class="kd ke hi il b im km iq kn jh ko ji kp jj kq jg ki kj kk kl bi translated">每次在 master 上提交时，我们都需要更新最新的 docker 图像标签</li></ul><blockquote class="if ig ih"><p id="933f" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">注意:对于 GitLab，我们需要配置一个必需的环境变量 semantic contains git lab access token 来授予对您的存储库的语义访问</p></blockquote><pre class="jp jq jr js fd jt jo ju jv aw jw bi"><span id="5c08" class="jx jy hi jo b fi jz ka l kb kc">GITLAB_TOKEN or GL_TOKEN</span></pre><p id="13ac" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">让我们写下我们的。gitlab-ci.yml</p><ul class=""><li id="8560" class="kd ke hi il b im in iq ir jh kf ji kg jj kh jg ki kj kk kl bi translated">首先定义了我们的阶段</li></ul><pre class="jp jq jr js fd jt jo ju jv aw jw bi"><span id="946a" class="jx jy hi jo b fi jz ka l kb kc">stages:<br/> - build<br/> - test<br/> - build-non-release-docker-image<br/> - release<br/> - build-release-docker-image<br/> - build-latest-docker-image<br/> - create-new-k8s-app-release</span></pre><ul class=""><li id="d52d" class="kd ke hi il b im in iq ir jh kf ji kg jj kh jg ki kj kk kl bi translated">构建阶段，因为我们的应用程序是一个节点，我们将在我们的 runner 中使用节点图像</li></ul><pre class="jp jq jr js fd jt jo ju jv aw jw bi"><span id="8fc1" class="jx jy hi jo b fi jz ka l kb kc">build:<br/>  stage: build<br/>  image: node<br/>  script: <br/>    - echo "Start building App"<br/>    - npm install<br/>    - npm build<br/>    - echo "Build successed!"<br/>  artifacts:<br/>    expire_in: 1 hour<br/>    paths:<br/>      - build<br/>      - node_modules/<br/>  except:<br/>    changes:<br/>      - "*.md"<br/>      - ".gitignore"</span></pre><ul class=""><li id="d6ce" class="kd ke hi il b im in iq ir jh kf ji kg jj kh jg ki kj kk kl bi translated">测试阶段</li></ul><pre class="jp jq jr js fd jt jo ju jv aw jw bi"><span id="cbb6" class="jx jy hi jo b fi jz ka l kb kc">test:<br/> stage: test<br/> image: node<br/> script:<br/> - echo “Testing App”<br/> - npm run test<br/> - echo “Test passed!”<br/> except:<br/> changes:<br/> - “*.md”<br/> - “.gitignore”</span></pre><ul class=""><li id="2e87" class="kd ke hi il b im in iq ir jh kf ji kg jj kh jg ki kj kk kl bi translated">仅为非发布分支构建 docker 映像将在不包含在发布分支中的分支上触发</li></ul><pre class="jp jq jr js fd jt jo ju jv aw jw bi"><span id="582b" class="jx jy hi jo b fi jz ka l kb kc">build-non-release-docker-image:<br/> stage: build-non-release-docker-image<br/> image: ubuntu:18.04<br/> script:<br/> - echo “Write scripts to build the docker image”<br/> only:<br/> - branches<br/> except:<br/> refs:<br/> - master<br/> - /^(([0–9]+)\.)?([0–9]+)\.x/<br/> changes:<br/> - “*.md”<br/> - “.gitignore”</span></pre><ul class=""><li id="7696" class="kd ke hi il b im in iq ir jh kf ji kg jj kh jg ki kj kk kl bi translated">我们的重点步骤是发布阶段只在发布分支上触发</li></ul><pre class="jp jq jr js fd jt jo ju jv aw jw bi"><span id="fd3e" class="jx jy hi jo b fi jz ka l kb kc">release:<br/> stage: release<br/> image: node<br/> before_script:<br/> - echo “preparing environment”<br/> - npm install <a class="ae jk" href="http://twitter.com/semantic" rel="noopener ugc nofollow" target="_blank">@semantic</a>-release/gitlab<br/> script:<br/> - npx semantic-release<br/> only:<br/> refs:<br/> - master<br/> - /^(([0–9]+)\.)?([0–9]+)\.x/<br/> except:<br/> changes:<br/> - “*.md”<br/> - “.gitignore”</span></pre><p id="cb33" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">在这个阶段，我们准备了我们的环境，安装了语义 GitLab 集成插件，并运行 release 命令。</p><ul class=""><li id="c665" class="kd ke hi il b im in iq ir jh kf ji kg jj kh jg ki kj kk kl bi translated">仅从标记创建 docker 映像和部署 stage</li></ul><pre class="jp jq jr js fd jt jo ju jv aw jw bi"><span id="5042" class="jx jy hi jo b fi jz ka l kb kc">build-latest-docker-image:<br/> stage: build-latest-docker-image<br/> image: ubuntu:18.04<br/> script:<br/> — echo “image build successed”<br/> only:<br/> — master<br/> except:<br/> changes:<br/> — “*.md”<br/> — “.gitignore”</span><span id="3a0d" class="jx jy hi jo b fi lr ka l kb kc">create-new-k8s-app-release:<br/> stage: create-new-k8s-app-release<br/> image: ubuntu:18.04<br/> script:<br/> — echo “App version $CI_COMMIT_REF_NAME created successfully”<br/> only:<br/> — tags</span></pre><p id="5cc2" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">该阶段仅在标签上触发</p><blockquote class="if ig ih"><p id="e11c" class="ii ij ik il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">注意:语义将在创建标记时的提交消息上添加[skip CI],这将跳过标记创建时的管道触发，并且避免为手动创建的标记触发构建和部署是有意义的，但是您可以定制和添加一些解决方法，以使用 GitLab API 而不是在标记情况下的手动触发来触发管道。</p></blockquote><p id="405e" class="pw-post-body-paragraph ii ij hi il b im in io ip iq ir is it jh iv iw ix ji iz ja jb jj jd je jf jg hb bi translated">最后，我希望我解释清楚了，并帮助您控制和组织您的应用程序发布和版本。</p></div></div>    
</body>
</html>