<html>
<head>
<title>Binary Search Algorithm using Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Java实现二分搜索法算法</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/binary-search-algorithm-using-java-3c7c24d783cf?source=collection_archive---------1-----------------------#2022-05-05">https://medium.com/nerd-for-tech/binary-search-algorithm-using-java-3c7c24d783cf?source=collection_archive---------1-----------------------#2022-05-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="68a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">老弟:- </strong>老弟，我压力很大啊老弟。</p><p id="5283" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">我:- </strong>为什么老弟，发生什么事了？</p><p id="0664" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">老弟:- </strong>我就是搞不懂这个二分搜索法算法的人其路太难走了，让人摸不着头脑</p><p id="d2c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我:- 你说什么呢老弟。对于<strong class="ih hj">排序数组</strong>来说，这是最好的<strong class="ih hj">搜索算法</strong>之一，也非常简单。</p><p id="b87f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">老弟:- </strong>老弟求求你帮帮那，我实在是受不了了。</p><p id="0f0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我:- 好吧，兄弟，那我们从头开始，我们将学习如何用java实现它。</p><h1 id="0836" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">搜索算法:-</h1><p id="2aca" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">当你必须从给定的数据结构中检查或检索一个元素时，我们使用搜索算法。</p><p id="3855" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它有两种类型</p><ol class=""><li id="1520" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated"><strong class="ih hj">顺序搜索:- </strong>顺序遍历列表或数组，检查每个元素。</li><li id="c6a5" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated"><strong class="ih hj">区间搜索:- </strong>专为在排序数据结构中搜索而设计，比顺序搜索更有效，因为它们反复瞄准搜索结构的中心，并将搜索空间一分为二。</li></ol><p id="573b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">区间搜索的一个例子二分搜索法。</p><h1 id="2caa" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">二分搜索法:-</h1><p id="ce1e" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">这是一种<strong class="ih hj">高效的</strong>搜索算法，用于从有序数组或列表中查找元素。</p><p id="ca69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个排序后的数组可以是升序也可以是降序。</p><p id="1b63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">二分搜索法背后的想法是反复将数组分成两半，直到你将可能的位置缩小到只有一个。</p><h1 id="65e7" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">二分搜索法算法:-</h1><ol class=""><li id="34a4" class="kg kh hi ih b ii kb im kc iq ku iu kv iy kw jc kl km kn ko bi translated">取四个变量=&gt; start，end，middle，target。</li><li id="213b" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">找到数组的中间元素= &gt;现在你的数组被分成左右两部分。</li><li id="c4bd" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">如果<strong class="ih hj">目标元素&gt;中间元素</strong> = &gt;在<strong class="ih hj">右侧</strong>部分搜索。</li><li id="3c65" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">如果<strong class="ih hj">目标元素&lt;中间元素</strong> = &gt;在<strong class="ih hj">左侧</strong>部分搜索。</li><li id="26d7" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">If <strong class="ih hj">中间元素==目标元素</strong> = &gt;返回该元素。</li><li id="8169" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">如果<strong class="ih hj">开始&gt;结束</strong> = &gt;元件未找到。</li></ol><h2 id="3026" class="kx je hi bd jf ky kz la jj lb lc ld jn iq le lf jr iu lg lh jv iy li lj jz lk bi translated">时间复杂度分析:-</h2><ul class=""><li id="a285" class="kg kh hi ih b ii kb im kc iq ku iu kv iy kw jc ll km kn ko bi translated">在每次迭代或每次递归调用中，搜索减少到数组的一半。</li><li id="3342" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc ll km kn ko bi translated">所以对于数组中的n个元素，有log2n次迭代或者递归调用。</li></ul><p id="856d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，对于<strong class="ih hj">最佳情况</strong>，即如果我们仅在第一次迭代中得到元素(中间元素)= &gt; O(1)，对于<strong class="ih hj">平均情况和最坏情况</strong> = &gt; O(log2N)。</p><p id="43ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">空间复杂度</strong>为O(1)。</p><p id="f08b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">老弟:- </strong>感谢老弟对二分搜索法如此浅显易懂的解释。</p><p id="a7d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">我:- </strong>为你老弟两肋插刀。</p><p id="ed72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">老弟:- </strong>但是老弟，代码呢？我在写代码的时候还是有点困惑。</p><p id="bbd4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">我:- </strong>没问题老弟，那我也简化一下😉</p><h1 id="ddba" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">代码实现:-</h1><p id="c4c7" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">注意:-这里我们采用一个升序排序的数组，因为二分搜索法总是只在排序的数组上实现。</p><figure class="ln lo lp lq fd lr er es paragraph-image"><div class="er es lm"><img src="../Images/8a2bf1711fae2834aa8e9a2044a2cb1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*84gpeNmze6VyV_cpYzaL5A.png"/></div><figcaption class="lu lv et er es lw lx bd b be z dx translated">二分搜索法代码实现</figcaption></figure><h2 id="39e4" class="kx je hi bd jf ky kz la jj lb lc ld jn iq le lf jr iu lg lh jv iy li lj jz lk bi translated">解释:-</h2><ol class=""><li id="c99f" class="kg kh hi ih b ii kb im kc iq ku iu kv iy kw jc kl km kn ko bi translated">创建了一个名为binarySearch的函数，它具有数组变量和目标元素变量的参数。</li><li id="5bd5" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">用值0初始化开始变量，用arr.length -1初始化结束变量，arr . length-1表示数组的最后一个元素。因此，这里我取排序数组的开始和结束值。</li><li id="11df" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">以起始值应始终小于或等于结束值为条件开始while循环。</li><li id="c229" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">然后用给定的公式求中间的元素。</li><li id="ccda" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">现在检查二分搜索法的情况，它的算法中也有解释，如果没有一个值匹配，那么简单地返回-1。</li><li id="c80f" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">在驱动程序代码中，我采用了一个已排序的数组，并定义了需要找出其索引值的目标元素，然后调用函数。</li></ol><figure class="ln lo lp lq fd lr er es paragraph-image"><div class="er es ly"><img src="../Images/402feb31bcb22932c6523be4eff9154d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*1KFIEbQUCnjNbyi3MqeuRw.png"/></div></figure><p id="292f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">老弟:- </strong>谢谢老弟的代码讲解。这是非常简单的事情。</p><p id="5574" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我:- 告诉你老弟这很容易。现在让我们来看看它的利弊。</p><h1 id="ad7f" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">二分搜索法的优点:-</h1><ol class=""><li id="623e" class="kg kh hi ih b ii kb im kc iq ku iu kv iy kw jc kl km kn ko bi translated">通过使用每次比较的结果，它消除了进一步搜索的一半列表。</li><li id="332e" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">它指示正在搜索的元素是在列表中的当前位置之前还是之后。</li><li id="75fc" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">该信息用于缩小搜索范围。</li><li id="4a03" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">对于大型数据列表，它比线性搜索效果好得多。</li></ol><h1 id="d0c5" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">二分搜索法的缺点:-</h1><ol class=""><li id="a442" class="kg kh hi ih b ii kb im kc iq ku iu kv iy kw jc kl km kn ko bi translated">它采用需要更多堆栈空间的递归方法。</li><li id="61bd" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">编程二分搜索法算法是容易出错和困难的。</li><li id="594e" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">二分搜索法与内存层次结构(即缓存)的交互很差。</li></ol><p id="641a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">老弟:- </strong>为此感谢老哥。但是有一件事，如果我再次遇到关于你感兴趣的任何话题的任何此类疑问，我将如何联系你🤔</p><p id="bb49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">我:- </strong>这里的兄弟只是从下面提到的链接与我联系，并将保持联系<strong class="ih hj">😉</strong></p><blockquote class="lz ma mb"><p id="1227" class="if ig mc ih b ii ij ik il im in io ip md ir is it me iv iw ix mf iz ja jb jc hb bi translated"><a class="ae mg" href="https://www.linkedin.com/in/iam-aman-chopra/" rel="noopener ugc nofollow" target="_blank">领英</a></p><p id="2c76" class="if ig mc ih b ii ij ik il im in io ip md ir is it me iv iw ix mf iz ja jb jc hb bi translated"><a class="ae mg" href="https://twitter.com/iam_chopra_aman" rel="noopener ugc nofollow" target="_blank">推特</a></p><p id="ff1a" class="if ig mc ih b ii ij ik il im in io ip md ir is it me iv iw ix mf iz ja jb jc hb bi translated"><a class="ae mg" href="https://github.com/Aman1905" rel="noopener ugc nofollow" target="_blank"> GitHub </a></p><p id="81df" class="if ig mc ih b ii ij ik il im in io ip md ir is it me iv iw ix mf iz ja jb jc hb bi translated">Instagram </p></blockquote></div></div>    
</body>
</html>