<html>
<head>
<title>OC: Original Cipher (Shift Cipher aka Caesar Cipher)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OC:原始密码(移位密码，又名凯撒密码)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/oc-original-cipher-shift-cipher-aka-caesar-cipher-fac55f1aea91?source=collection_archive---------16-----------------------#2021-03-25">https://medium.com/nerd-for-tech/oc-original-cipher-shift-cipher-aka-caesar-cipher-fac55f1aea91?source=collection_archive---------16-----------------------#2021-03-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="555f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我正在加深对密码学的理解。虽然我可能应该在20年前(甚至在2014年Bit Coin开始制造噪音时)开始这样做，但没有像现在这样的时间来继续学习。我选择的一篇文章是<a class="ae jd" href="https://www.amazon.com/Understanding-Cryptography-Textbook-Students-Practitioners/dp/3642041000/ref=sr_1_1?ie=UTF8&amp;qid=1503942303&amp;sr=8-1&amp;keywords=understanding+cryptography" rel="noopener ugc nofollow" target="_blank">理解密码学</a>。计划是让我的手脏起来，跟着文本一起编码(向自己证明最低限度的能力)。我选择的武器(在过去的三年里)是JavaScript——虽然它是第一个密码的任务，但它也不是没有挑战。</p><p id="264f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该算法采用一个字母表、一个偏移量和文本，并用字母表中偏移了偏移量的字符数的值替换文本中的每个字符。如果偏移量超过了字母表的末尾，它将返回到开头。为了加密，我们取一个字符，找到它的数值(我们称之为x)，加上偏移量(我们称之为k)和模数除以字母表中的字符数(我们称之为m)。因此</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="4328" class="jn jo hi jj b fi jp jq l jr js">encrypt(x) = (x + k) mod m</span></pre><p id="734b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解密是相似的</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="a93a" class="jn jo hi jj b fi jp jq l jr js">decrypt(x) = (x - k) mod m</span></pre><p id="0b0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解决方案中的琐碎问题(我首先通过在Excel中建模来确认)在练习进行到10分钟时被打破了，结果是关于负数的模有一些模糊性。有两个<a class="ae jd" href="https://en.wikipedia.org/wiki/Modulo_operation" rel="noopener ugc nofollow" target="_blank">实现</a>，如果你没有使用正确的一个，事情就不会工作。因为javascript模操作符并不是这个用例的正确实现。这是我第一次遇到这种模奇怪，需要一些研究来解决(感谢维基百科)。我定义了自己的模函数:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="a53c" class="jn jo hi jj b fi jp jq l jr js">const quotient = (dividend,divisor) =&gt; <br/>      Math.floor(dividend/divisor)<br/><br/>const floor_modulo = (dividend,divisor) =&gt; <br/>      dividend - divisor * quotient(dividend,divisor)</span></pre><p id="2e21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在许多其他助手的帮助下(为了让我的算法易于阅读)，我最终得到了这个解决方案:</p><pre class="je jf jg jh fd ji jj jk jl aw jm bi"><span id="ca02" class="jn jo hi jj b fi jp jq l jr js">const {reduce, pipe, curry, find} = <br/>       require('../helpers/functional-bits')</span><span id="b10b" class="jn jo hi jj b fi jt jq l jr js">const {maxOr, increment, appendToObj, appendToArray, join, length,<br/>    floor_modulo, numberOfKeys, values} = require('../helpers/common-bits')<br/><br/>const maxOrNegOne = maxOr(-1)<br/><br/>const alphabet = 'abcdefghijklmnopqrstuvwxyz'<br/><br/><em class="ju">// arrayToAlphabetMap :: [k] -&gt; {k: Number}</em><br/>const arrayToAlphabetMap = reduce(<br/>    (map, a) =&gt; appendToObj(map, a, getNextValue(map)),<br/>    {}<br/>)<br/><br/><em class="ju">// getNextValue :: {character: Number} -&gt; Number</em><br/>const getNextValue = pipe([<br/>    values,<br/>    maxOrNegOne,<br/>    increment<br/>])<br/><br/><em class="ju">// enryptCharacter  :: ({character: Number} -&gt; Number -&gt; Number -&gt; <br/>//     character -&gt; character) -&gt; {character: Number} -&gt; Number -&gt; <br/>//     Number -&gt; [character] -&gt; [character]</em><br/>const applyWith = curry((algo, alphabetMap, k, m, xs) =&gt;<br/>    reduce(<br/>        (arr, x) =&gt; appendToArray(<br/>        arr, algo(alphabetMap, k, m, x))<br/>        ,[]<br/>        , xs<br/>    )<br/>)<br/><br/><em class="ju">// enryptCharacter  :: {character: Number} -&gt; Number -&gt; Number -&gt; <br/>//     character -&gt; character</em><br/>const encryptCharacter = curry((alphabetMap, k, m, x) =&gt; {<br/>    const rawValue = alphabetMap[x]<br/>    const shiftValue = floor_modulo((rawValue + k), m)<br/>    const shiftCharacter = find(alphabetMap, shiftValue)<br/>    return shiftCharacter<br/>})<br/><br/><em class="ju">// decryptCharacter  :: {character: Number} -&gt; Number -&gt; Number -&gt; <br/>//      character -&gt; character</em><br/>const decryptCharacter = curry((alphabetMap, k, m, x) =&gt; {<br/>    const shiftValue = alphabetMap[x]<br/>    const rawValue = floor_modulo((shiftValue - k), m)<br/>    const rawCharacter = find(alphabetMap, rawValue)<br/>    return rawCharacter<br/>})<br/><br/><em class="ju">// shiftCipher :: string, Number -&gt; <br/>//      { encrypt :: string -&gt; string, decrypt :: string -&gt; string }</em><br/>const shiftCipher = (alphabet, k) =&gt; {<br/>    const alphabetArray = alphabet.split('')<br/>    const alphabetMap = arrayToAlphabetMap(alphabetArray)<br/>    const m = numberOfKeys(alphabetMap)<br/><br/>    return {<br/>        encrypt: pipe([<br/>            applyWith(encryptCharacter, alphabetMap, k, m),<br/>            join<br/>        ]),<br/>        decrypt: pipe([<br/>            applyWith(decryptCharacter, alphabetMap, k, m),<br/>            join<br/>        ]),<br/>    }<br/>}<br/><br/>const raw = 'attack'<br/>const cipher = shiftCipher(alphabet, 17)<br/><br/>const secret = cipher.encrypt(raw)<br/><em class="ju">//=&gt; rkkrtb</em><br/>﻿<br/>const raw2 = cipher.decrypt(secret)<br/><em class="ju">//=&gt; attack</em></span></pre><p id="d723" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意:忍住痒——这不是一个安全的加密算法。但是请玩代码(你可以在这里找到<a class="ae jd" href="https://github.com/tb01923/understanding-cryptography" rel="noopener ugc nofollow" target="_blank">)。还拿到代码了？我很想收到你的来信，给我写封短信吧！</a></p><h2 id="ac80" class="jn jo hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">关于我</h2><div class="ko kp ez fb kq kr"><a href="https://www.linkedin.com/in/tb02118/" rel="noopener  ugc nofollow" target="_blank"><div class="ks ab dw"><div class="kt ab ku cl cj kv"><h2 class="bd hj fi z dy kw ea eb kx ed ef hh bi translated">Todd Brown——副总裁&amp;创新和敏捷工程高级总监——Liberty…</h2><div class="ky l"><h3 class="bd b fi z dy kw ea eb kx ed ef dx translated">Todd在软件行业有20多年的经验，专注于架构、安全和…</h3></div><div class="kz l"><p class="bd b fp z dy kw ea eb kx ed ef dx translated">www.linkedin.com</p></div></div><div class="la l"><div class="lb l lc ld le la lf lg kr"/></div></div></a></div></div><div class="ab cl lh li gp lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="hb hc hd he hf"><p id="b031" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ju">原载于</em><a class="ae jd" href="https://www.linkedin.com/pulse/oc-original-cipher-shift-aka-caesar-todd-brown/" rel="noopener ugc nofollow" target="_blank"><em class="ju">https://www.linkedin.com</em></a><em class="ju">。</em></p></div></div>    
</body>
</html>