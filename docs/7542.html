<html>
<head>
<title>Golang: Testing function in a simple web server project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang:在简单的 web 服务器项目中测试函数</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/golang-testing-function-in-a-simple-web-server-project-e72190bf9dd7?source=collection_archive---------1-----------------------#2022-11-27">https://medium.com/nerd-for-tech/golang-testing-function-in-a-simple-web-server-project-e72190bf9dd7?source=collection_archive---------1-----------------------#2022-11-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8aebd37a018a41d036e8358cb1b7852d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gKQwpz6sHoC86vc1U2nvaQ.png"/></div></div></figure><p id="2e99" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">构建软件项目时，测试很重要。在 Golang 中，有一些包在对我们项目中的函数进行单元测试时非常有用。在本文中，我将展示如何使用这些包来测试 web 服务器项目中的功能。项目结构如下。我们将以测试<code class="du jo jp jq jr b">Greeting</code>函数为例。如何使用 Golang 构建 web 服务器可以在我之前的<a class="ae js" rel="noopener" href="/nerd-for-tech/golang-build-a-simple-web-server-and-interact-with-it-689ee0f4d1de">文章</a>中看到。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="ab fe cl jx"><img src="../Images/8efebcbd93bb83ad9825536ea84c0b20.png" data-original-src="https://miro.medium.com/v2/format:webp/1*rNmmC6UZNoF7zF06yuy0PA.png"/></div></figure><p id="ab16" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">main.go</code>中的代码如下。</p><pre class="jt ju jv jw fd jy jr jz bn ka kb bi"><span id="867f" class="kc kd hi jr b be ke kf l kg kh">// main.go<br/><br/>package main<br/><br/>import (<br/>  "log"<br/>  "net"<br/>  "net/http"<br/>  "my-project/greeting"<br/>)<br/><br/>func main() {<br/>  http.HandleFunc("/greeting", greeting.Greeting)<br/><br/>  log.Println("Starting server....")<br/><br/>  listener, err := net.Listen("tcp", "localhost:8080")<br/>  if err != nil {<br/>    log.Fatal(err)<br/>  }<br/><br/>  http.Serve(listener, nil)<br/>}</span></pre><p id="a11b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">而<code class="du jo jp jq jr b">greeting.go</code>就像下图。</p><pre class="jt ju jv jw fd jy jr jz bn ka kb bi"><span id="3974" class="kc kd hi jr b be ke kf l kg kh">// greeting.go<br/><br/>package greeting<br/><br/>import (<br/>"fmt"<br/>"net/http"<br/>)<br/><br/>func Greeting(w http.ResponseWriter, r *http.Request) {<br/>  fmt.Fprint(w, "Hello World")<br/>}</span></pre><h2 id="d2db" class="ki kd hi bd kj kk kl km kn ko kp kq kr jb ks kt ku jf kv kw kx jj ky kz la lb bi translated">1.介绍</h2><p id="7f58" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">Golang 为我们提供了包<code class="du jo jp jq jr b">testing</code>来进行单元测试，还提供了包<code class="du jo jp jq jr b">net/http/httptest</code>，它可以用来在进行单元测试时记录 HTTP(或 HTTPS)响应。下面是对这两个包以及对进行单元测试有用的函数的介绍:</p><ul class=""><li id="d062" class="lh li hi is b it iu ix iy jb lj jf lk jj ll jn lm ln lo lp bi translated"><a class="ae js" href="https://pkg.go.dev/testing" rel="noopener ugc nofollow" target="_blank">测试</a></li></ul><p id="c8ce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">包<code class="du jo jp jq jr b">testing</code>为 Go 包的自动化测试提供支持。</p><blockquote class="lq lr ls"><p id="dacf" class="iq ir lt is b it iu iv iw ix iy iz ja lu jc jd je lv jg jh ji lw jk jl jm jn hb bi translated">要编写一个新的测试套件，创建一个名为 ends _test.go 的文件，其中包含 TestXxx 函数，如下所述。将文件放在与被测试文件相同的包中。该文件将从常规包构建中排除，但在运行“go test”命令时将包括在内。有关更多详细信息，请运行“运行帮助测试”和“运行帮助测试标志”。</p><p id="eb70" class="iq ir lt is b it iu iv iw ix iy iz ja lu jc jd je lv jg jh ji lw jk jl jm jn hb bi translated">从<code class="du jo jp jq jr b"><a class="ae js" href="https://pkg.go.dev/testing" rel="noopener ugc nofollow" target="_blank"><em class="hi">testing online document</em></a></code></p></blockquote><p id="1ee8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是一个测试函数的例子。</p><pre class="jt ju jv jw fd jy jr jz bn ka kb bi"><span id="ed87" class="kc kd hi jr b be ke kf l kg kh">func TestAbs(t *testing.T) {<br/>    got := Abs(-1)<br/>    want := 1<br/>    if got != want {<br/>        t.Errorf("Abs(-1) = %d; want %d", got, want)<br/>    }<br/>}</span></pre><ul class=""><li id="f6db" class="lh li hi is b it iu ix iy jb lj jf lk jj ll jn lm ln lo lp bi translated"><a class="ae js" href="https://pkg.go.dev/net/http/httptest@go1.19.3" rel="noopener ugc nofollow" target="_blank"> net/http/httptest </a></li></ul><p id="3cac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">包<code class="du jo jp jq jr b">httptest</code>提供了用于 HTTP 测试的工具。它提供了<code class="du jo jp jq jr b">NewRequest</code>函数来模拟一个传入的服务器请求，适合传递给一个 http。测试处理程序。<code class="du jo jp jq jr b">method</code>、<code class="du jo jp jq jr b">target</code>和<code class="du jo jp jq jr b">body</code>应传递给<code class="du jo jp jq jr b">NewRequest</code>功能。<code class="du jo jp jq jr b">method</code>是像<code class="du jo jp jq jr b">GET</code>一样的 HTTP 方法。<code class="du jo jp jq jr b">target</code>可以是路径或绝对<code class="du jo jp jq jr b">URL</code>，而<code class="du jo jp jq jr b">body</code>可以是零。</p><blockquote class="lq lr ls"><p id="f9db" class="iq ir lt is b it iu iv iw ix iy iz ja lu jc jd je lv jg jh ji lw jk jl jm jn hb bi translated">提供的主体可能为零。如果主体的类型为*bytes。读者，*字符串。读取器，或*字节。缓冲区，请求。ContentLength 已设置。</p><p id="ce15" class="iq ir lt is b it iu iv iw ix iy iz ja lu jc jd je lv jg jh ji lw jk jl jm jn hb bi translated">从<code class="du jo jp jq jr b"><a class="ae js" href="https://pkg.go.dev/net/http/httptest@go1.19.3" rel="noopener ugc nofollow" target="_blank"><em class="hi">net/http/httptest online document</em></a></code></p></blockquote><pre class="jt ju jv jw fd jy jr jz bn ka kb bi"><span id="7eee" class="kc kd hi jr b be ke kf l kg kh">func NewRequest(method, target string, body io.Reader) *http.Request</span></pre><p id="f8aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du jo jp jq jr b">NewRequest</code>函数的示例代码。</p><pre class="jt ju jv jw fd jy jr jz bn ka kb bi"><span id="353c" class="kc kd hi jr b be ke kf l kg kh">request := httptest.NewRequest("GET", "http://example.com/greeting", nil)</span></pre><p id="9366" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">包<code class="du jo jp jq jr b">httptest</code>提供了一个调用<code class="du jo jp jq jr b">ResponseRecorder</code>的类型。它是<code class="du jo jp jq jr b">http.ResponseWriter</code>的一个实现，记录了它的变化，以便以后在测试中检查，这意味着它可以用来记录测试中对 HTTP(或 HTTPS)请求的响应的内容。</p><pre class="jt ju jv jw fd jy jr jz bn ka kb bi"><span id="a3d9" class="kc kd hi jr b be ke kf l kg kh">type ResponseRecorder struct {<br/> // Code is the HTTP response code set by WriteHeader.<br/> Code int<br/>// HeaderMap contains the headers explicitly set by the Handler.<br/> // It is an internal detail.<br/> HeaderMap http.Header<br/> // Body is the buffer to which the Handler's Write calls are sent.<br/> // If nil, the Writes are silently discarded.<br/> Body *bytes.Buffer<br/> // Flushed is whether the Handler called Flush.<br/> Flushed bool<br/> // contains filtered or unexported fields<br/>}</span></pre><p id="ef3b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">包<code class="du jo jp jq jr b">httptest</code>还提供了一个函数调用<code class="du jo jp jq jr b">NewRecorder</code>，它可以返回一个初始化的<code class="du jo jp jq jr b">ResponseRecorder</code>，用于记录 HTTP(或 HTTPS)响应的模拟。</p><pre class="jt ju jv jw fd jy jr jz bn ka kb bi"><span id="505e" class="kc kd hi jr b be ke kf l kg kh">func NewRecorder() *ResponseRecorder</span></pre><p id="53d5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在测试中，包<code class="du jo jp jq jr b">httptest</code>中还有另一个有用的功能。就是<code class="du jo jp jq jr b">Result</code>功能。</p><pre class="jt ju jv jw fd jy jr jz bn ka kb bi"><span id="fea1" class="kc kd hi jr b be ke kf l kg kh">func (rw *ResponseRecorder) Header() http.Header</span></pre><p id="db3b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在下面的示例代码中。我们可以看到，在运行<code class="du jo jp jq jr b">handler</code>函数后，<code class="du jo jp jq jr b">w</code>可以调用<code class="du jo jp jq jr b">Result</code>函数，该函数将返回由处理程序生成的响应。返回的响应至少有其<code class="du jo jp jq jr b">StatusCode</code>、<code class="du jo jp jq jr b">Header</code>、<code class="du jo jp jq jr b">Body</code>。<code class="du jo jp jq jr b">Result</code>只能在处理程序完成运行后调用。</p><pre class="jt ju jv jw fd jy jr jz bn ka kb bi"><span id="cbd8" class="kc kd hi jr b be ke kf l kg kh">handler := func(w http.ResponseWriter, r *http.Request) {<br/>  fmt.Fprint(w, "Hello World")<br/>  }<br/>req := httptest.NewRequest("GET", "http://example.com/foo", nil)<br/>w := httptest.NewRecorder()<br/>handler(w, req)<br/>resp := w.Result()<br/>body := w.Body<br/>fmt.Println(resp.StatusCode)<br/>fmt.Println(resp.Header)<br/>fmt.Println(body)<br/>------------------------------------------------------------------------------<br/>Output:<br/>200<br/>map[Content-Type:[text/plain; charset=utf-8]]<br/>Hello World</span></pre></div><div class="ab cl lx ly gp lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hb hc hd he hf"><h2 id="11ac" class="ki kd hi bd kj kk kl km kn ko kp kq kr jb ks kt ku jf kv kw kx jj ky kz la lb bi translated">2.开始测试</h2><p id="1755" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">为了测试，首先，我们需要添加一个文件名以<code class="du jo jp jq jr b">_test.go</code>结尾的文件，该文件包含 TestXxx 函数，因为我们将使用包<code class="du jo jp jq jr b">testing</code>并且这是它工作的规则，所以在与<code class="du jo jp jq jr b">main.go</code>相同的文件夹中会有一个<code class="du jo jp jq jr b">main_test.go</code>文件。我们项目的结构如下图所示。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es me"><img src="../Images/33f88c1538077d1b72ea279130a6ed33.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*VvtVtRqDQY--dik2L3QmPw.png"/></div></figure><p id="7bac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们要先测试<code class="du jo jp jq jr b">Greeting</code>函数，所以<code class="du jo jp jq jr b">main_test.go</code>中的函数名是<code class="du jo jp jq jr b">TestGreeting</code>。<code class="du jo jp jq jr b">main_test.go</code>的内容如下。</p><pre class="jt ju jv jw fd jy jr jz bn ka kb bi"><span id="80ea" class="kc kd hi jr b be ke kf l kg kh">// main_test.go<br/><br/>package main<br/>import (<br/>  "net/http"<br/>  "net/http/httptest"<br/>  "testing"<br/>  // we need to call Greeting function, so need to import greeting <br/>  "my-project/greeting" <br/>)<br/>func TestGreeting(t *testing.T) {<br/>  // simulate an incoming server Request<br/>  request, _ := http.NewRequest("GET", "/greeting", nil)<br/><br/>  // record the simulation of HTTP response<br/>  response := httptest.NewRecorder()<br/>  <br/>  // run the function we want to test<br/>  greeting.Greeting(response, request)<br/><br/>  // check if the result is what we expect<br/>  got := response.Body.String()<br/>  want := "Hello World"<br/>  if got != want {<br/><br/>    // if the result is not correct print error<br/>    t.Errorf("got %v, want %v", got, want)<br/>  }<br/>}</span></pre><p id="7e97" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了运行测试，我们需要在终端中运行我们项目的根路径中的<code class="du jo jp jq jr b">go test</code>命令。如果你使用<code class="du jo jp jq jr b">VScode</code>作为编辑器，安装 Golang 扩展后，我们可以通过点击测试函数行旁边的按钮来运行测试。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mf"><img src="../Images/95a951ad3c4b3d3416e0b22e7a4881ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x-PrRK6fTbRYC3VbnQ1-Ww.png"/></div></div></figure><p id="42f6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">点击运行按钮后，我们可以在<code class="du jo jp jq jr b">VScode</code>终端看到结果。如果测试通过，它会在测试功能旁边显示一个绿色的对勾，并且它会打印日志并在终端显示<code class="du jo jp jq jr b">PASS</code>。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mg"><img src="../Images/c6f49ff811efd4c306cc9a467acac84f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hTkL6EzncLValvQnQqyLLA.png"/></div></div></figure><p id="5573" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果测试失败，它将显示我们得到的错误。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/ad1d42e4dd29d05e15b8c7f16b190940.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IQJLWUbZbwWsw9AMXjnCxA.png"/></div></div></figure><p id="47a2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们想在测试日志中添加一些描述，比如关于我们测试的更多细节，我们可以使用<code class="du jo jp jq jr b">t.Run</code>来包装我们的测试函数，如下所示。</p><pre class="jt ju jv jw fd jy jr jz bn ka kb bi"><span id="8df8" class="kc kd hi jr b be ke kf l kg kh">// main_test.go<br/><br/>package main<br/>import (<br/>  "net/http"<br/>  "net/http/httptest"<br/>  "testing"<br/>  "my-project/greeting" <br/>)<br/>func TestGreeting(t *testing.T) {<br/><br/>  // use t.Run to wrap your test<br/>  t.Run("test greeting ok", func(t *testing.T) {<br/>    request, _ := http.NewRequest("GET", "/greeting", nil)<br/>  <br/>    response := httptest.NewRecorder()<br/>    <br/>    greeting.Greeting(response, request)<br/>  <br/>    got := response.Body.String()<br/>    want := "Hello World"<br/>  <br/>    if got != want {<br/>      t.Errorf("got %v, want %v", got, want)<br/>    }<br/>  })<br/>}</span></pre><p id="a744" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">运行测试后，我们可以在日志中看到我们放入<code class="du jo jp jq jr b">t.Run</code>中的描述。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/5ee4afba7dd3f4722534901fc9ae485a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yr8E25eWw-NKWvWY8MjR7Q.png"/></div></div></figure></div><div class="ab cl lx ly gp lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="hb hc hd he hf"><h2 id="6dbf" class="ki kd hi bd kj kk kl km kn ko kp kq kr jb ks kt ku jf kv kw kx jj ky kz la lb bi translated">3.重构代码</h2><p id="4df3" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated">我们现在在<code class="du jo jp jq jr b">main_test.go</code>编写我们的测试，但是它不是一个运行测试的好地方。当人们看到文件时，很难知道它要测试什么，所以我们应该创建一个测试文件，其名称包括我们要测试的函数，并将其放在函数文件所在的文件夹中。其他人会更容易联想到我们正在测试的那些功能。</p><p id="0380" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就像我们在<code class="du jo jp jq jr b">greeting</code>文件夹中的<code class="du jo jp jq jr b">greeting.go</code>中有<code class="du jo jp jq jr b">Greeting</code>函数一样，我们应该将测试文件放在同一个文件夹中，并将其命名为<code class="du jo jp jq jr b">greeting_test.go</code>，这样当每个人看到该文件时就可以知道它正在测试<code class="du jo jp jq jr b">greeting.go</code>中的函数。项目的结构将变成如下所示。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/8f8df93ecb9d34eaad8e03edf8aa299a.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*VJk44DbzaMXTJ3jzme3DUg.png"/></div></figure><p id="d9b6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">而<code class="du jo jp jq jr b">greeting_test.go</code>如下图。我们应该将测试功能移到<code class="du jo jp jq jr b">greeting_test.go</code>中。</p><pre class="jt ju jv jw fd jy jr jz bn ka kb bi"><span id="8cbe" class="kc kd hi jr b be ke kf l kg kh">// greeting_test.go<br/><br/>package greeting<br/>import (<br/>  "net/http"<br/>  "net/http/httptest"<br/>  "testing"<br/>)<br/>func TestGreeting(t *testing.T) {<br/>  t.Run("test greeting ok", func(t *testing.T) {<br/>    request, _ := http.NewRequest("GET", "/greeting", nil)<br/>    response := httptest.NewRecorder()<br/>    Greeting(response, request)<br/>    got := response.Body.String()<br/>    want := "Hello World"<br/>    if got != want {<br/>      t.Errorf("got %v, want %v", got, want)<br/>    }<br/>  })<br/>}</span></pre><p id="51ad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">单击 run test 按钮，测试功能应该仍然可以成功运行。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/dc27c895e500b60e69e0af77954f9290.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m1ZElTLD2yrmqOGjZSbT3Q.png"/></div></div></figure><p id="c648" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们知道了如何进行单元测试，知道代码的测试覆盖率也很重要。我们可以在终端中运行项目根目录下的<code class="du jo jp jq jr b">go test -cover ./…</code>来查看结果。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/514c2a2e9f86b4dd003b9cf8f00f2e6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gRDwYSD1GK-ewwraYuyYvg.png"/></div></div></figure><p id="465d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在测试结果中，我们可以在<code class="du jo jp jq jr b">greeting</code>文件夹中看到，测试覆盖率为 100%，因为<code class="du jo jp jq jr b">greeting</code>文件夹中只有<code class="du jo jp jq jr b">Greeting</code>函数需要测试，而<code class="du jo jp jq jr b">greeting_test.go</code>中已经有了它的测试用例。</p><h2 id="0481" class="ki kd hi bd kj kk kl km kn ko kp kq kr jb ks kt ku jf kv kw kx jj ky kz la lb bi translated">参考</h2><p id="381b" class="pw-post-body-paragraph iq ir hi is b it lc iv iw ix ld iz ja jb le jd je jf lf jh ji jj lg jl jm jn hb bi translated"><a class="ae js" href="https://quii.gitbook.io/learn-go-with-tests/build-an-application/app-intro" rel="noopener ugc nofollow" target="_blank">边学边考</a></p><p id="bd9d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae js" href="https://go.dev/doc/install" rel="noopener ugc nofollow" target="_blank"> Go 官方在线文档</a></p><ul class=""><li id="59db" class="lh li hi is b it iu ix iy jb lj jf lk jj ll jn lm ln lo lp bi translated"><a class="ae js" href="https://pkg.go.dev/testing" rel="noopener ugc nofollow" target="_blank">测试</a></li><li id="11a1" class="lh li hi is b it mm ix mn jb mo jf mp jj mq jn lm ln lo lp bi translated"><a class="ae js" href="https://pkg.go.dev/net/http/httptest@go1.19.3" rel="noopener ugc nofollow" target="_blank"> net/http/httptest </a></li></ul><p id="e512" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi"><a class="ae js" href="https://willh.gitbook.io/build-web-application-with-golang-zhtw/" rel="noopener ugc nofollow" target="_blank">使用 Golang 打造 web 應用程式</a></p><p id="21a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><a class="ae js" href="https://github.com/astaxie/build-web-application-with-golang" rel="noopener ugc nofollow" target="_blank">用 Golang 构建 Web 应用</a></p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="mr ms l"/></div></figure></div></div>    
</body>
</html>