<html>
<head>
<title>Intro to Convolutional Coding — Part I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">卷积编码简介—第一部分</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/into-to-convolutional-coding-part-i-d63decab56a0?source=collection_archive---------3-----------------------#2021-05-22">https://medium.com/nerd-for-tech/into-to-convolutional-coding-part-i-d63decab56a0?source=collection_archive---------3-----------------------#2021-05-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/c011435d76501615eff0e3a6a2fa03fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*HsZpN3GJq3HhkCnlBk6PWg.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">卷积编码器，英文维基百科上的 Teridon，公共领域，通过维基共享</figcaption></figure><p id="8cb1" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这篇文章旨在成为快速介绍卷积编码的两篇文章中的第一篇。如果你对这个主题不熟悉，卷积编码是一种纠错码，用于增强数字通信的可靠性。在这篇文章中，我将介绍基础知识、表示和编码过程。下面的<a class="ae iq" href="https://yair-mz.medium.com/intro-to-convolutional-coding-part-ii-d289c109ff7a" rel="noopener">帖子</a>涵盖了使用维特比算法的解码过程。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h1 id="3253" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">那么它是什么，它是如何工作的？</h1><p id="92fc" class="pw-post-body-paragraph ir is hi it b iu ku iw ix iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo hb bi translated">卷积码已经广泛用于无线通信(WiFi、蜂窝和卫星)中，并且是广泛使用的 Turbo 编码的组成部分。与分组码不同，卷积码没有有限的分组长度，而是可以被视为线性滤波器，IIR 或 FIR。</p><p id="49fd" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">卷积编码器利用线性移位寄存器(LSR 的)将<em class="kz"> k </em>个输入位编码成<em class="kz"> n </em>个输出位，从而产生速率为<em class="kz"> R=k/n </em>的代码。每个输出位取决于最后一个和最后一个<em class="kz"> L </em>输入位，其中<em class="kz"> L </em>称为“约束长度”l 描述了编码器拥有的“内存”量(大部分文献使用大写<em class="kz"> K </em>，但我发现这很容易混淆，因为 K 很小<em class="kz">K】</em>。</p><p id="83a7" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">例如，考虑以下速率<em class="kz"> R= </em>编码器:</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es la"><img src="../Images/89121edfe8ffc80fa2f13c76335d9afe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eX7QEykL5KGXZIU6MbMrpw.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">码率为<em class="lj"> R=，约束长度为 K=2 </em>的卷积编码器</figcaption></figure><p id="646f" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">标有<em class="kz"> D </em>的模块代表延迟，因此输出取决于最后一个输入位和前两个输入。输出根据奇偶校验公式确定:</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es lk"><img src="../Images/8c205f89a8c208646e79dfb2a6ccc106.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BifRsdLroD_mU6isETEoKQ.png"/></div></div></figure><p id="4bfb" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">所有加法运算符都应视为模 2 加法(只要我们考虑二进制字母表)，可以通过 XOR 实现。</p><p id="22f3" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">根据标准术语，上述输出位与输入的关系使用<em class="kz">生成器</em>多项式来表示，其中变量<em class="kz"> x </em>的幂代表延迟。对于上面的编码器，它是这样的:</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es ll"><img src="../Images/53fcc0ac2f3cbe8fc251b2b89a69083f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IumhPGOkQxzY0z-aLcvZjw.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">上述编码器的生成多项式</figcaption></figure><p id="af30" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这些有时也表示为二进制向量，其元素是各种幂的系数，因此对于我们的示例，它表示为:</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es lm"><img src="../Images/707b8cc28dbcaf6c9ff4f32e8259c4ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ulnt6ycm1xcCCpfxWE4vDQ.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">生成器的向量表示</figcaption></figure><p id="e039" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">后者制定 FIR 滤波器的脉冲响应，并建议使用卷积将第<em class="kz"> j </em>个滤波器的输出表示为第<em class="kz"> i </em>个比特的输入:</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es ln"><img src="../Images/8a0c2d41a24fef9872425fe4498ec9ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hrh_HeKbmubSNVjkMq2ojQ.png"/></div></div></figure><p id="3b31" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">更一般地，对于每个时钟周期接受<em class="kz"> k </em>个输入比特并输出<em class="kz"> n </em>个比特的编码器，当使用约束长度<em class="kz"> r </em>时，在时间<em class="kz"> t </em>的输出将是:</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es lo"><img src="../Images/27d3c8912df981730cc9080a8796eb5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5__OvxSzDURZvL_NW9_9uw.png"/></div></div></figure></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h1 id="19d0" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">卷积编码器的其他表示</h1><h2 id="5aa7" class="lp jx hi bd jy lq lr ls kc lt lu lv kg jc lw lx kk jg ly lz ko jk ma mb ks mc bi translated">有限状态机</h2><p id="5767" class="pw-post-body-paragraph ir is hi it b iu ku iw ix iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo hb bi translated">除了上面显示的框图视图之外，还有其他方式可以产生更简单的实现形式，尤其是在软件中。具有约束长度<em class="kz"> L </em>的编码器可以被认为是有限状态机，并被描绘成具有<em class="kz"> 2ᴸ </em>顶点的有向图，表示 LSR 的可能状态。每个顶点都有<em class="kz"> 2ᵏ </em>边，表示由于<em class="kz"> 2ᵏ </em>可能的输入而产生的可能转换。这种表示可以简单地用软件实现。上述编码器可以用下面的 FSM 表示:</p><figure class="lb lc ld le fd ij er es paragraph-image"><div class="er es md"><img src="../Images/9927344f9a738a88a5a4c98757e15f6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*2IxvrOJdshVHAR8fX1GRPw.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">编码器的有限状态机表示</figcaption></figure><p id="2cbc" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">每个边缘的一位数表示上面的输入位值，两位数表示输出。使用这种表示，可以通过实现 FSM 来对流进行编码。</p><h2 id="741b" class="lp jx hi bd jy lq lr ls kc lt lu lv kg jc lw lx kk jg ly lz ko jk ma mb ks mc bi translated">框架</h2><p id="6065" class="pw-post-body-paragraph ir is hi it b iu ku iw ix iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo hb bi translated">另一种表示可以通过<a class="ae iq" href="https://en.wikipedia.org/wiki/Trellis_(graph)" rel="noopener ugc nofollow" target="_blank">网格</a>部分获得。该部分是一个二分图，将当前状态连接到以下可能的状态:</p><figure class="lb lc ld le fd ij er es paragraph-image"><div class="er es me"><img src="../Images/24371ec69a9172ceb888d0abf00ddada.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*1AfoCkuyHvr465skxcdsCg.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">代表顶部编码器的单个网格部分</figcaption></figure><p id="2bc7" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">每列具有对应于可能的编码器状态的<em class="kz"> 2ᴸ </em>顶点，并且每个顶点具有离开它的<em class="kz"> 2ᵏ </em>边，对应于可能的输入。这些部分可以连接起来形成一个网格:</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es mf"><img src="../Images/a848a23c67d2d41ec8323b19e0cfbbc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FbmZt-xBzJA5zjVfXxWymw.png"/></div></div></figure><p id="08ee" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">网格表示将在以后对使用维特比算法的解码有价值。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h1 id="8235" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">递归编码器</h1><p id="66ae" class="pw-post-body-paragraph ir is hi it b iu ku iw ix iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo hb bi translated">还有另一种流行的卷积编码器，它利用反馈环路。系统递归编码器是 turbo 编码器的基本构件。这种编码器的示例如下所示:</p><figure class="lb lc ld le fd ij er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es mg"><img src="../Images/0dba1bf68f5b915843b2bd03339d6202.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oew0jp9T-M9f5vk19Ze6yg.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">速率为<em class="lj"> R= </em>的递归系统编码器</figcaption></figure><p id="d336" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">注意反馈环路，其结果是 IIR 滤波器而不是 FIR 滤波器。今天到此为止。在下一个<a class="ae iq" href="https://yair-mz.medium.com/intro-to-convolutional-coding-part-ii-d289c109ff7a" rel="noopener">帖子</a>中，我会给出解码过程的细节。</p></div><div class="ab cl jp jq gp jr" role="separator"><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju jv"/><span class="js bw bk jt ju"/></div><div class="hb hc hd he hf"><h1 id="ba80" class="jw jx hi bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">来源</h1><p id="901c" class="pw-post-body-paragraph ir is hi it b iu ku iw ix iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo hb bi translated">在写这篇文章时，我使用了:</p><ul class=""><li id="f01f" class="mh mi hi it b iu iv iy iz jc mj jg mk jk ml jo mm mn mo mp bi translated"><a class="ae iq" href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-02-introduction-to-eecs-ii-digital-communication-systems-fall-2012/readings/MIT6_02F12_chap07.pdf" rel="noopener ugc nofollow" target="_blank">麻省理工学院开放式课件笔记</a></li><li id="6c08" class="mh mi hi it b iu mq iy mr jc ms jg mt jk mu jo mm mn mo mp bi translated">纠错编码(2019)，作者托德·k·穆恩。</li></ul></div></div>    
</body>
</html>