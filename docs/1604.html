<html>
<head>
<title>Circuit Breaker Pattern — Microservice Architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">断路器模式——微服务架构</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/circuit-breaker-pattern-microservice-architecture-4c6b1a06f3f3?source=collection_archive---------2-----------------------#2021-03-28">https://medium.com/nerd-for-tech/circuit-breaker-pattern-microservice-architecture-4c6b1a06f3f3?source=collection_archive---------2-----------------------#2021-03-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/235bef3ed91e46066b348a55deadf271.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/0*mgqGqveFskNg_2Uj"/></div></figure><p id="7c48" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi jk translated"><span class="l jl jm jn bm jo jp jq jr js di">在</span>这个教程中，我们来学习一下<strong class="io hj">断路器</strong>。断路是一种<strong class="io hj">软件设计模式</strong>，主要用于一个服务影响其他服务的情况。如果你有一些电子或电气工程的基础知识，你肯定听说过断路或<a class="ae jt" href="https://uk.rs-online.com/web/generalDisplay.html?id=ideas-and-advice/mcb-guide#:~:text=An%20MCB%20is%20an%20automatically,electrical%20faults%20and%20equipment%20failure." rel="noopener ugc nofollow" target="_blank"> <strong class="io hj"> MCB开关</strong> </a> <strong class="io hj">(微型断路器)</strong>。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es ju"><img src="../Images/68c4079c93f86d2649a3db4ccc2886ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/0*gqGhEs7a0yDk3zVU.JPG"/></div></figure><p id="fa39" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这基本上是一个电子开关，用来保护我们的家用电器。当电路出现异常时，它会自动切换以保护整个电路。这种断路概念类似于我们在软件世界中使用的概念，在软件世界中，服务实际上与许多其他服务进行交互。我们举个例子，了解一下到底是什么。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es jz"><img src="../Images/cab2183c2968accf18e9fbc7ed5465dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v-vnfkQ0CrhfXfb_ASKexA.png"/></div></div></figure><p id="9d01" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">假设有3个微服务，这3个微服务相互交互<strong class="io hj">同步</strong>。当请求到达<strong class="io hj">微服务1 </strong>时，<strong class="io hj">微服务1 </strong>正在调用<strong class="io hj">微服务2 </strong>，<strong class="io hj">微服务2 </strong>正在调用<strong class="io hj">微服务3 </strong>。如果所有服务都可用，我们肯定会得到从<strong class="io hj">微服务3 </strong>到<strong class="io hj">微服务2 </strong>和<strong class="io hj">微服务1 </strong>的响应。所以这是一条快乐的路。但是可能有一些服务不可用。并非所有的服务都是可用的。</p><h2 id="7134" class="ke kf hi bd kg kh ki kj kk kl km kn ko ix kp kq kr jb ks kt ku jf kv kw kx ky bi translated">如果微服务3宕机会怎么样？</h2><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es kz"><img src="../Images/351aa53d38993f2c3c43611516237e9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7N9G722y4xP5wMoz2Zw2gw.png"/></div></div></figure><p id="e052" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">该请求将到达<strong class="io hj">微服务1 </strong>和<strong class="io hj">微服务2 </strong>，当到达<strong class="io hj">微服务3 </strong>时，它将返回一个错误。现在，<strong class="io hj">微服务2 </strong>将收到一个错误，<strong class="io hj">微服务2 </strong>向<strong class="io hj">微服务1 </strong>响应一个错误，我们将得到一个<strong class="io hj">错误响应</strong>。这并不好，因为我们不想发回错误。我们需要用更好的方式处理它。问题可能会更多。如果<strong class="io hj">微服务2 </strong>有一个机制来重试几次，以获得来自<strong class="io hj">微服务3 </strong>的成功响应，会发生什么情况。假设<strong class="io hj">微服务2 </strong>中有5次重试机制。现在，当请求到达<strong class="io hj">微服务2 </strong>时，现在<strong class="io hj">微服务2 </strong>调用<strong class="io hj">微服务3 </strong>，但是<strong class="io hj">微服务3 </strong>运行不正常或者出现故障，我们正在恢复错误。假设<strong class="io hj"> MicroServic3 </strong>负载过重，这就是为什么我们得到了<strong class="io hj"> 500错误</strong>并且它不能处理新的到来的请求。现在，<strong class="io hj">微服务2 </strong>继续重试<strong class="io hj">微服务3 </strong> 5次，我们从<strong class="io hj">微服务3 </strong>得到更多错误。所以应该有更好的方法来处理这些事情。</p><h2 id="db1f" class="ke kf hi bd kg kh ki kj kk kl km kn ko ix kp kq kr jb ks kt ku jf kv kw kx ky bi translated">你如何让事情变得更好？</h2><p id="a882" class="pw-post-body-paragraph im in hi io b ip la ir is it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj hb bi translated">让我们给这个加一个<strong class="io hj">断路器</strong>。假设我们在每个微服务中都实现了一个断路器。断路器有三种方式帮助电路正常工作。</p><p id="b696" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">缓存响应</strong></p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es lf"><img src="../Images/f1fe6c43d0dd6f9009336c6e9f799316.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HqWbuknFlSisZofBCyUUdA.png"/></div></div></figure><p id="5002" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">当请求到达<strong class="io hj">微服务1 </strong>时，它到达<strong class="io hj">微服务2 </strong>，然后它调用<strong class="io hj">微服务3 </strong>。现在，<strong class="io hj">微服务2 </strong>知道<strong class="io hj">微服务3 </strong>行为不正常。现在<strong class="io hj">微服务2 </strong>中的断路器知道我们刚刚调用的服务返回一个错误。它实际上知道哪个服务失败了多少次。所以它知道<strong class="io hj">微服务3 </strong>只是返回一个错误。断路器假定返回一个缓存响应来返回缓存响应。这意味着，每当我们从服务收到一些错误，我们应该得到一个响应，我们实际上可以配置断路器返回缓存的响应。此缓存响应是我们在上次或服务失败之前收到的成功响应。所以现在，当服务失败时，我们实际上可以取回缓存的响应。现在用户可以接收带有<strong class="io hj">缓存响应</strong>的<strong class="io hj"> 200成功响应</strong>。</p><p id="89d9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">回退机制</strong></p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es lg"><img src="../Images/6324591a744e38f8f72d290dfbd33755.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jkqNXhYmaGXnSqa4OLRmoA.png"/></div></div></figure><p id="43a1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">实际上，我们可以将调用从<strong class="io hj">微服务2 </strong>重定向到与<strong class="io hj">微服务3 </strong>类似的其他服务，而不是返回缓存响应。现在，与<strong class="io hj">微服务3 </strong>服务一样，我们可以从第三方服务获得成功响应，而不会出现任何错误。因此，当实际服务失败时，我们可以回退到不同的替代服务。</p><p id="7ffe" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">愈合机制</strong></p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es lh"><img src="../Images/c7cb2b1cc6a83fd1fb844a730d738cae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FUEtKbs5hOtbAp6K-SNncg.png"/></div></div></figure><p id="479a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这里，当请求到来时，微服务断路器保持<strong class="io hj">微服务3 </strong>的失败次数。在给定的失败次数后，我们可以告诉<strong class="io hj">微服务2 </strong>上的断路器，而不是所有<strong class="io hj">微服务3 </strong>。先别管这个<strong class="io hj">微服务3 </strong>了。让它愈合一段时间。我们还可以配置时间。此后，任何对<strong class="io hj">微服务2 </strong>的请求都不会调用<strong class="io hj">微服务3 </strong>，直到定义的时间间隔结束。现在我们可以使用<strong class="io hj">缓存响应或回退机制返回响应。</strong>现在我们可以断开<strong class="io hj">微服务3 </strong>让它恢复。</p><p id="620e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">怎么才能恢复？</strong></p><ul class=""><li id="21ae" class="li lj hi io b ip iq it iu ix lk jb ll jf lm jj ln lo lp lq bi translated">如果队列中有任何未决的请求，它可以处理并结束。</li><li id="821e" class="li lj hi io b ip lr it ls ix lt jb lu jf lv jj ln lo lp lq bi translated">它可以被关闭并部署一个新实例，或者被配置为启动一个新实例。</li></ul><h2 id="af5e" class="ke kf hi bd kg kh ki kj kk kl km kn ko ix kp kq kr jb ks kt ku jf kv kw kx ky bi translated"><strong class="ak">超时后会发生什么？</strong></h2><p id="b208" class="pw-post-body-paragraph im in hi io b ip la ir is it lb iv iw ix lc iz ja jb ld jd je jf le jh ji jj hb bi translated">在一定的超时之后，<strong class="io hj">微服务2 </strong>将调用<strong class="io hj">微服务3 </strong>并检查响应如何。如果它仍然失败<strong class="io hj">，微服务2 </strong>将返回缓存响应或采用回退机制。如果请求成功，那么<strong class="io hj">微服务2 </strong>缓存成功响应并将响应返回给<strong class="io hj">微服务1 </strong>并保持流程正确。</p><h2 id="d86b" class="ke kf hi bd kg kh ki kj kk kl km kn ko ix kp kq kr jb ks kt ku jf kv kw kx ky bi translated">电路图</h2><ul class=""><li id="6db7" class="li lj hi io b ip la it lb ix lw jb lx jf ly jj ln lo lp lq bi translated"><strong class="io hj">闭合</strong> —当一切正常时，断路器保持闭合状态，所有呼叫都转到服务。当故障数量超过预定阈值时，断路器跳闸，并进入断开状态。</li><li id="b652" class="li lj hi io b ip lr it ls ix lt jb lu jf lv jj ln lo lp lq bi translated"><strong class="io hj">打开</strong> —断路器返回呼叫错误，不执行该功能。</li><li id="d401" class="li lj hi io b ip lr it ls ix lt jb lu jf lv jj ln lo lp lq bi translated"><strong class="io hj">半开</strong> —超时后，电路切换至半开状态，以测试潜在问题是否仍然存在。如果在这种半开状态下单个呼叫失败，断路器将再次跳闸。如果成功，断路器复位回到正常闭合状态。</li></ul><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es lz"><img src="../Images/ce452d4695e2cc0525c621395edd8216.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fpBMWTktMzeoATyM.png"/></div></div></figure><p id="3e40" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果一切正常，我们就处于<strong class="io hj">关闭状态</strong>。如果<strong class="io hj">微服务3 </strong>现在出现故障，则电路与微服务3断开，并进入<strong class="io hj">打开状态</strong>并开始返回缓存响应。延迟一段时间后，它再次调用<strong class="io hj">微服务3 </strong>并进入<strong class="io hj">半开状态</strong>，这意味着它实际上检查<strong class="io hj">微服务3 </strong>是否返回成功响应。如果它返回成功响应，我们可以进入<strong class="io hj">关闭状态</strong>，或者如果它仍然返回错误，我们可以进入打开状态。这是断路器的完整电路图。</p><p id="3260" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我想你已经了解了<strong class="io hj">断路器设计模式</strong>的基本知识。下节课再见。</p><p id="9f2f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">谢谢大家！</p></div></div>    
</body>
</html>