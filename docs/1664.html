<html>
<head>
<title>Coroutines with Unity!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">统一的协程！</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/coroutines-with-unity-fe650a4892f7?source=collection_archive---------7-----------------------#2021-03-31">https://medium.com/nerd-for-tech/coroutines-with-unity-fe650a4892f7?source=collection_archive---------7-----------------------#2021-03-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="57d1" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated"><strong class="ii hj"> <em class="je">什么是协程？</em>T3】</strong></p><p id="6925" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">通常当一个方法被调用时，它会在被调用的帧内完成执行。但是用C <strong class="ii hj"> oroutines </strong>你可以在很多帧上扩展执行。</p><p id="0c97" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">简而言之,<strong class="ii hj">协程</strong>是一种特殊的功能，它允许我们在满足特定条件时，通过暂停和恢复执行(从暂停的地方开始)来将游戏逻辑的执行分散到多个帧上。</p></div><div class="ab cl jf jg gp jh" role="separator"><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk"/></div><div class="hb hc hd he hf"><p id="18ef" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated"><strong class="ii hj"> <em class="je">如何使用协程？</em>T11】</strong></p><p id="e959" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">就像我说的，协程是一种特殊的函数，它们像普通函数一样被初始化，但是有一个唯一的返回类型，</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es jm"><img src="../Images/70e5554a587960cb8d53f28591936fc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*23gXTFOQqVQ5dw3Vex2cyg.png"/></div></div></figure><p id="2e52" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">其中<strong class="ii hj"> IEnumerator </strong>是初始化协程方法所需的类型。这就是Unity在多个帧上扩展功能执行的方式。正是这种<strong class="ii hj">类型的</strong>数据让我们可以使用<strong class="ii hj"> yield </strong>语句。</p><p id="59fe" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated"><strong class="ii hj"> Yield </strong>语句是让我们知道我们的方法是一个迭代器并将运行不止一帧的语句。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es jy"><img src="../Images/40351508305170f12c58fb8bce36b101.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*neAHz48-IcKpEjx_X-434Q.png"/></div></div></figure><p id="37da" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">这些是与<strong class="ii hj">产量相关的一些方法。</strong></p></div><div class="ab cl jf jg gp jh" role="separator"><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk jl"/><span class="ji bw bk jj jk"/></div><div class="hb hc hd he hf"><p id="9c4b" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">为什么我们需要协程？T25】</p><p id="f6f2" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">让我们举一个例子来解释为什么我们需要协程。</p><p id="0c80" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">首先，让我们创建一个简单的脚本，通过操作对象的变换将对象移动到指定的位置，</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es jz"><img src="../Images/37a82e76923e34b22902285064ff428c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*arU1SGL23z18HxR_t3aRJQ.png"/></div></div></figure><p id="a6ed" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">使用上面的方法，让我们用协程和不用协程来移动我们的对象，以观察不同之处，</p><p id="c56d" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated"><strong class="ii hj"> <em class="je">不带协程:</em> </strong></p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es ka"><img src="../Images/f0972d2d5c4fb2771d149de2fcd61f5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*-DJbgNpyOHwAjHqlkioj3w.png"/></div></figure><p id="47ad" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">从上面我们可以观察到，我们希望沿着x轴移动我们的对象，我们从位置(-9，0，0)开始，一直移动到(9，0，0)。这里"<strong class="ii hj">而</strong> " <strong class="ii hj"> </strong>循环<strong class="ii hj"> </strong>正在进行检查，以验证我们没有越过(9，0，0)点，当我们越过时，我们退出循环。“<strong class="ii hj"> while </strong>”循环，只要我们指定的条件保持为真，就在我们的代码块中循环。<em class="je">注:i++；是i = i + 1或i += 1的简写。</em></p><p id="167c" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">有了逻辑编码，让我们在每次点击<strong class="ii hj">空格键</strong>时执行它。这可以通过以下方式完成:</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es kb"><img src="../Images/5d99ee0954ffe8dab43b36ac5b451423.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RZy1946cowaxn3ZcZxYA9A.png"/></div></div></figure><p id="cae9" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">在我给你看结果之前。让我们仔细想想结果会是什么样子。<br/>所以理想的结果是对象将它的<strong class="ii hj">变换</strong>从(-9，0，0)变为(9，0，0)。但是结果不会是这样的，因为每帧调用一次<strong class="ii hj"> Update() </strong>，<strong class="ii hj">without coro routine()</strong>将在一帧内完成它的执行。让我们的对象从默认位置跳到最终位置。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es kc"><img src="../Images/e7e9c602ca99e2609fe235322623546d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*JnDH8ft3uVAKiMzcB6XDvw.gif"/></div></div></figure><p id="736c" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">在这里，我们可以观察到，按下空格键的那一刻，我们立即到达最终位置，并且值立即在我们的控制台中实例化。同样，当我们再次按下空格键时，这不会将我们带到初始位置(-9，0，0)，而是我们在最终位置(9，0，0)。这是因为我们的整个逻辑运行在一个框架中。</p><p id="7dd9" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">协程可以在不改变逻辑的情况下解决这个问题。让我们看看使用协程会得到什么。</p><p id="46d5" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated"><strong class="ii hj"> <em class="je">同</em> </strong></p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es kd"><img src="../Images/04206e6206538b91a47390bdfbcabe18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IUossZtTQz1ggnYenx-Gpg.png"/></div></div></figure><p id="8e7e" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">这里，delay是一个序列化的变量，因此我们可以在编辑器中更改它的值。</p><p id="7e24" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">我们可以观察到，<strong class="ii hj">协程()</strong>的代码与没有协程()的<strong class="ii hj">代码相同，唯一的区别是<strong class="ii hj">产出</strong>，这里我要求<strong class="ii hj">协程()</strong>暂停指定的“<strong class="ii hj">_延迟</strong>”时间段。</strong></p><p id="7ed8" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">这样我们就初始化了一个协程，但是要调用这个方法，我们需要使用，</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es ke"><img src="../Images/97342d047488b9c54ebf6d929bf255f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*8VWGTbeBJOMnpsZiegk6aA.png"/></div></figure><p id="ef40" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">所以我们可以这样做，</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es kb"><img src="../Images/e6d505b7e665b1a49c7cbb1a1ca96ba7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ssDvjvL-cYO1E3-N40NS4g.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">这里延迟设置为1秒。</figcaption></figure><p id="2874" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated"><em class="je">注意:你可以在你的Update()中直接调用StartCoroutine。</em></p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es kb"><img src="../Images/2ddb122105141c1a5316d5ec9dc103f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xqB0L5ILPZ2N0f1nrCiZuQ.png"/></div></div></figure><p id="6ff5" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">并让结果做解释。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es kc"><img src="../Images/771d6d89acf32ebac38e9ffb1451fb3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*XiPT32_xTswU6_iwEOY4Xg.gif"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">这是原版的加速版。</figcaption></figure><p id="e84e" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">在这里，我们可以观察控制台中的时间戳，看到我们每秒移动一个单位。这正是我们想要的。但是这种方法有一个问题。<strong class="ii hj">协程</strong>为了更好或更差的运行直到完成，如果我在一个协程运行时按下<strong class="ii hj">空格键</strong>，现在突然我们有两个<strong class="ii hj">协程</strong>同时运行。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es kc"><img src="../Images/6e1e6007222b2efbdd60eccfcff2ccd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*JppmGVG68ttX2_d1MUeI3w.gif"/></div></div></figure><p id="1260" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">这里我们可以看到立方体疯狂地试图完成内存中所有的<strong class="ii hj">协程</strong>。对此的一个解决方案是使用，</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div class="er es kj"><img src="../Images/78a4172f1c0771e5ad6f1e091066b196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*RCOsyk8Xf6SWnKfifFK2dw.png"/></div></figure><p id="4025" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">这将一个<strong class="ii hj">协程</strong>作为一个参数，我们可以通过执行以下操作来实现它:</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es kk"><img src="../Images/194e008bdbcaaba8b49bd6ca734915f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-6wEen3JYnRd1yzDih0UsQ.png"/></div></div></figure><p id="9720" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">这里我们创建一个变量来存储我们的<strong class="ii hj">协程</strong>(因此有了<strong class="ii hj"> IEnumerator类型</strong>)。默认情况下，<strong class="ii hj"> _currentCoroutine </strong>变量存储一个空值，除非它用一个值初始化。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es kl"><img src="../Images/04c4158bc856214f6cd66854f4f72a18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dN8JmOW9R06p_tOYk7Y-1w.png"/></div></div></figure><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es kb"><img src="../Images/2ddb122105141c1a5316d5ec9dc103f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xqB0L5ILPZ2N0f1nrCiZuQ.png"/></div></div></figure><p id="0de8" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">这给了我们下面的结果，我们可以观察到，每当按下<strong class="ii hj">空格键</strong>时，一个新的协程开始执行，如果已经有一个协程在运行，它就停止它并重新初始化一个新的协程。</p><figure class="jn jo jp jq fd jr er es paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="er es kc"><img src="../Images/e514ade4b38ff803aa6bd5481a63b0ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*wr_vWONFjUO5uzHqsZLjrw.gif"/></div></div></figure><p id="4d88" class="pw-post-body-paragraph ig ih hi ii b ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd hb bi translated">感谢您的阅读。更多信息请访问协程。</p></div></div>    
</body>
</html>