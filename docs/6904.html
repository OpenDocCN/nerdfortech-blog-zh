<html>
<head>
<title>KMM UI Architecture - Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">KMM 用户界面架构-第 1 部分</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/kmm-ui-architecture-part-1-6362e14ee52a?source=collection_archive---------1-----------------------#2022-06-15">https://medium.com/nerd-for-tech/kmm-ui-architecture-part-1-6362e14ee52a?source=collection_archive---------1-----------------------#2022-06-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/cd6e701024658d478683f07bf9fc28c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HvKqTjPsKIe8kW1JrAWgPA.png"/></div></div></figure><h1 id="b7c7" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">概观</h1><p id="7641" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">这是两篇系列文章的第 1 部分:</p><ul class=""><li id="5d9a" class="km kn hi jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><a class="ae kx" rel="noopener" href="/p/6362e14ee52a"> <strong class="jq hj">第一部分</strong> </a> <strong class="jq hj">:常见 ui 模式的总结以及我们从它们身上学到的东西</strong></li><li id="7cb5" class="km kn hi jq b jr ky jv kz jz la kd lb kh lc kl kt ku kv kw bi translated">第 2 部分:为 Kotlin 多平台创建一个简单的、适应性强的、可预测的和可组合的 UI 框架</li></ul><h1 id="0bdb" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">问题陈述</h1><p id="3b3d" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">KMM(科特林多平台手机)的承诺是字面上的:</p><blockquote class="ld le lf"><p id="e08f" class="jo jp lg jq b jr ko jt ju jv kp jx jy lh li kb kc lj lk kf kg ll lm kj kk kl hb bi translated">用纯 kot Lin(<a class="ae kx" href="https://kotlinlang.org/lp/mobile/" rel="noopener ugc nofollow" target="_blank">https://kotlinlang.org/lp/mobile</a>)语言为你的 iOS 和 Android 应用编写一次业务逻辑</p></blockquote><p id="ed03" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated">与其他跨平台框架如 Flutter 或 React Native 不同，KMM 不承诺用户界面的单一代码基础。这引发了如下问题:</p><ul class=""><li id="3d88" class="km kn hi jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated">到底什么是用户界面？</li><li id="54e5" class="km kn hi jq b jr ky jv kz jz la kd lb kh lc kl kt ku kv kw bi translated">如何分解用户界面，分解后的哪些部分是平台不可知的？</li></ul><p id="8bde" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated">通过回答这些问题，我们将能够:</p><ul class=""><li id="9c6e" class="km kn hi jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated">更好地分离不同的用户界面组件，特别是独立于平台和特定于平台的代码</li><li id="46f3" class="km kn hi jq b jr ky jv kz jz la kd lb kh lc kl kt ku kv kw bi translated">增加跨目标平台共享的代码量</li></ul><p id="aef1" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated">为了从不同的角度看待问题和潜在的解决方案，本系列的第一部分将解释一些常见的架构模式，如 MVC、MVP、MVVM、MVI、SAM、BLoC、React/Redux，并尝试提取它们的基本思想。</p><h1 id="bd55" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">用户界面问题</h1><p id="d76e" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在其最基本的形式中，一个 ui 架构有两个主要关注点(我称之为<em class="lg">关注点</em>遵循<a class="ae kx" href="https://en.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank">关注点分离原则</a>，这是“将<a class="ae kx" href="https://en.wikipedia.org/wiki/Computer_program" rel="noopener ugc nofollow" target="_blank">计算机程序</a>分离成不同部分的设计原则”，也注意到<a class="ae kx" href="https://stackoverflow.com/a/25012230/534471" rel="noopener ugc nofollow" target="_blank">这个建议</a>忽略围绕<a class="ae kx" href="https://en.wikipedia.org/wiki/Single-responsibility_principle" rel="noopener ugc nofollow" target="_blank"> SRP </a>和<a class="ae kx" href="https://en.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank"> SoC </a>的学术讨论):</p><figure class="lo lp lq lr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ln"><img src="../Images/dd3c127ad612f896e174bb4ea9af2bee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*b3hax5zvwi5Srzc3"/></div></div></figure><ol class=""><li id="b3f7" class="km kn hi jq b jr ko jv kp jz kq kd kr kh ks kl ls ku kv kw bi translated"><strong class="jq hj">显示</strong>:向用户显示一些内容=呈现状态(在大多数模型中，这是“视图”)</li><li id="04ee" class="km kn hi jq b jr ky jv kz jz la kd lb kh lc kl ls ku kv kw bi translated"><strong class="jq hj">状态管理</strong>:检索、存储、转换状态/数据- &gt;业务逻辑</li></ol><p id="d6af" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated">存在两个触发器:</p><ol class=""><li id="77a7" class="km kn hi jq b jr ko jv kp jz kq kd kr kh ks kl ls ku kv kw bi translated">用户与显示的内容进行交互，这可以导致状态改变，状态改变可以导致显示内容的改变</li><li id="4493" class="km kn hi jq b jr ky jv kz jz la kd lb kh lc kl ls ku kv kw bi translated">状态更新可以由 ui 框架之外的元素触发，例如异步网络呼叫或设备事件(位置更新、网络事件、传入消息等)。)会导致显示内容的变化</li></ol><p id="d709" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated">理论上，显示的代码可以直接读取和更新状态，或者管理状态的代码可以侦听 ui 事件来更新自身，也可以直接更新/操作显示。我们都知道这种紧密耦合的设计是一个糟糕的想法(在谷歌推出<a class="ae kx" href="https://developer.android.com/topic/libraries/architecture/viewmodel" rel="noopener ugc nofollow" target="_blank"> ViewModels </a>之前，这在 Android 上是常见的做法)。为了实现某种解耦，我们需要介于两者之间的“某种东西”:</p><figure class="lo lp lq lr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/e7e63e152b5c1e1c2e39221b760250ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*muiUBPV4zCilQ12J"/></div></div></figure><p id="5be5" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated">每个 ui 架构都定义了介于这两者之间的“某些东西”:</p><ul class=""><li id="71bb" class="km kn hi jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated">观察 ui 更改以更新状态</li><li id="09ee" class="km kn hi jq b jr ky jv kz jz la kd lb kh lc kl kt ku kv kw bi translated">获取状态并准备呈现</li></ul><p id="1208" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated">观察力敏锐的读者会注意到，我刚刚定义了(至少)另外四个关注点:</p><ol class=""><li id="3742" class="km kn hi jq b jr ko jv kp jz kq kd kr kh ks kl ls ku kv kw bi translated"><strong class="jq hj">收集:</strong>监听用户界面事件(键盘、触摸、鼠标)、过滤事件(例如去抖)、聚集事件(例如将触摸事件聚集到滑动以消除事件)</li><li id="2c4b" class="km kn hi jq b jr ky jv kz jz la kd lb kh lc kl ls ku kv kw bi translated"><strong class="jq hj">转换:</strong>将收集步骤的结果转换成状态变化(在一些框架中，该结果被称为<em class="lg">意图</em>)</li><li id="167c" class="km kn hi jq b jr ky jv kz jz la kd lb kh lc kl ls ku kv kw bi translated"><strong class="jq hj">选择:</strong>观察状态并选择与用户界面相关的变化</li><li id="d272" class="km kn hi jq b jr ky jv kz jz la kd lb kh lc kl ls ku kv kw bi translated"><strong class="jq hj">绑定:</strong>准备要显示的状态，例如通过过滤相关数据和/或将其映射为用户友好的格式，如将 UTC 时间戳转换为本地时区等。</li></ol><figure class="lo lp lq lr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/3e65873ecf6f354dde35c2b6880032db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jv5M-dymjpX5Nnty"/></div></div></figure><h2 id="efd7" class="lv ir hi bd is lw lx ly iw lz ma mb ja jz mc md je kd me mf ji kh mg mh jm mi bi translated">间奏曲:干净的建筑</h2><p id="03b1" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">现在我们有了一个通用的(唉，抽象的)ui 架构，让我们把它放到一个更大的<a class="ae kx" href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank">干净架构</a>的环境中(如果你对干净架构不感兴趣，跳过这一章):</p><figure class="lo lp lq lr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/17a6ad0bde8b583295850d6fd627f4a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hk5i4pky8jeD4ZVz.jpg"/></div></div></figure><p id="a046" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated">虽然它是在考虑 web 而不是移动应用程序的情况下创建的，但它仍然是一个有用的模型，这不仅仅是因为所提出的分解，还因为依赖规则:</p><blockquote class="ld le lf"><p id="8d44" class="jo jp lg jq b jr ko jt ju jv kp jx jy lh li kb kc lj lk kf kg ll lm kj kk kl hb bi translated">这条规则说<em class="hi">源代码依赖</em>只能向内指向<em class="hi"/>。内圈的任何东西都不可能了解外圈的任何东西。</p></blockquote><p id="a1a5" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated">将<a class="ae kx" href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" rel="noopener ugc nofollow" target="_blank">依赖性反转原则</a>应用于架构的所有层:</p><ul class=""><li id="919c" class="km kn hi jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated">没有一个组件知道位于外圈的组件</li><li id="0e3d" class="km kn hi jq b jr ky jv kz jz la kd lb kh lc kl kt ku kv kw bi translated">外环中的组件与内环中组件的抽象(例如接口)一起工作</li></ul><p id="d327" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated">在提出 KMM ui 架构时，我们将遵循这一原则。</p><p id="89ae" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated">在他的<a class="ae kx" href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank">原始文章</a>中，“Bob 叔叔”将我们上面定义的所有关注点放入绿色环中:</p><blockquote class="ld le lf"><p id="a4f9" class="jo jp lg jq b jr ko jt ju jv kp jx jy lh li kb kc lj lk kf kg ll lm kj kk kl hb bi translated">例如，正是这一层将完全包含 GUI 的 MVC 架构。演示者、视图和控制器都属于这里。</p></blockquote><p id="ada6" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated">我不想打断你，但我不同意那种说法。<br/>MVC 中的模型不仅仅是数据，它是:</p><blockquote class="ld le lf"><p id="8a6c" class="jo jp lg jq b jr ko jt ju jv kp jx jy lh li kb kc lj lk kf kg ll lm kj kk kl hb bi translated">图案的中心部分。[…]动态数据结构[…]直接管理应用程序的数据、逻辑和规则。</p></blockquote><p id="87b3" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated">根据这一点，它也是业务逻辑的一部分，因此也存在于红色的“用例”圈中。</p><p id="6751" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated"><a class="ae kx" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller" rel="noopener ugc nofollow" target="_blank"> MVC </a>里的视图显然也生活在蓝圈里。即使演示者创建了所有的 HTML/CSS/JavaScript，我们仍然需要一个浏览器(位于蓝色圆圈中)来呈现和收集用户输入。</p><p id="2a07" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated"><a class="ae kx" href="http://www.plainionist.net/Implementing-Clean-Architecture-Controller-Presenter/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>非常详细地解释了视图、演示者、控制器和模型/用例的交互，并为我们描绘了这一切:</p><figure class="lo lp lq lr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/6aa4735b5ea910a7e899567d8fb9a04d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vWCrqHU4ByTAlKmo.png"/></div></div></figure><p id="9d98" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated">这正是我们上面定义的:</p><figure class="lo lp lq lr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/a27229608141c9de63be732a85b39528.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aW4AK7_m5p7cOgDJ"/></div></div></figure><p id="cc14" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated">所以在一个<a class="ae kx" href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank">干净架构</a>的环境中，我们的 ui 架构跨越了外部三层的部分。</p><h1 id="6234" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">现有模式/框架</h1><h2 id="1eed" class="lv ir hi bd is lw lx ly iw lz ma mb ja jz mc md je kd me mf ji kh mg mh jm mi bi translated">模型-视图-控制器</h2><p id="0e69" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">当研究 MVC 时，你会发现它一点也不清晰。有两种主要模式:</p><ul class=""><li id="e300" class="km kn hi jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><a class="ae kx" href="https://tinyurl.com/mvctrianglemodel" rel="noopener ugc nofollow" target="_blank">三角形模式</a>(是 1979 年的<a class="ae kx" href="https://folk.universitetetioslo.no/trygver/themes/mvc/mvc-index.html" rel="noopener ugc nofollow" target="_blank">原始模式):视图直接与模型交互，控制器也直接与模型交互</a></li><li id="f31e" class="km kn hi jq b jr ky jv kz jz la kd lb kh lc kl kt ku kv kw bi translated"><a class="ae kx" href="https://tinyurl.com/mvcchainmodel" rel="noopener ugc nofollow" target="_blank">链式模式</a>:控制器与视图和模型交互，但视图和模型之间没有直接交互</li></ul><p id="ae5d" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated">链式模式是与我们自己的 ui 架构相匹配的，而控制器是介于两者之间的“某物”:</p><figure class="lo lp lq lr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/3cb0a95a9f0f5651a2baf4257af8d2f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5Q38yg1ul-iiCfW3"/></div></div></figure><p id="cc08" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated">这三个组件之间的交互和依赖关系(哪个组件知道其他什么组件)也没有明确定义。有拉模式、推模式或反应模式以及不同级别的解耦(视图知道控制器或视图不知道控制器的任何事情，控制器知道模型，控制器与注入模型一起工作，等等。).由于缺乏共识，我们真的无法从 MVC 模式中学到更多东西。</p><h2 id="332e" class="lv ir hi bd is lw lx ly iw lz ma mb ja jz mc md je kd me mf ji kh mg mh jm mi bi translated">模型-视图-演示者</h2><p id="5027" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在 MVP 中，演示者是视图和模型之间的粘合剂:</p><figure class="lo lp lq lr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/1a3b10a9aae3c8a421dbe238375d72cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Vf3XY7GDwLhxDBg8"/></div></div></figure><p id="c091" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated">演示者更新模型并观察或接收来自模型的更新。在大多数实现中，呈现者有一个对视图的引用，并直接与视图交互(像这里的<a class="ae kx" href="https://www.baeldung.com/mvc-vs-mvp-pattern" rel="noopener ugc nofollow" target="_blank"/>或这里的<a class="ae kx" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter" rel="noopener ugc nofollow" target="_blank"/>)反之亦然(视图直接与呈现者交互以转发 ui 事件)。视图和演示者都应该针对接口进行编码，但是它们仍然相互引用。就解耦而言，MVP 比 MVC 更好，但是演示者有太多的责任和太多关于其他组件的知识。</p><h2 id="0fb5" class="lv ir hi bd is lw lx ly iw lz ma mb ja jz mc md je kd me mf ji kh mg mh jm mi bi translated">MVVM(模型-视图-视图模型)</h2><p id="240b" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">MVVM 和 MVP 有两个主要区别:</p><ol class=""><li id="7c0a" class="km kn hi jq b jr ko jv kp jz kq kd kr kh ks kl ls ku kv kw bi translated">MVVM 的视图模型不引用视图，而在大多数 MVP 实现中，展示者引用视图。视图模型通常被注入到视图中。</li><li id="b95a" class="km kn hi jq b jr ky jv kz jz la kd lb kh lc kl ls ku kv kw bi translated">MVVM 在视图和模型的视图特定部分之间引入了数据绑定，以允许 gui 开发(视图)与业务逻辑开发的分离。</li></ol><figure class="lo lp lq lr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/94418315d80a51ed757690e16f98f3c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*h7QcLIN4qFuKtT14"/></div></div></figure><p id="c2ff" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated">MVVM 模型的新颖之处在于声明性的数据(模型)和命令(事件)绑定，这几乎消除了所有的 gui 代码(并用一些标记语言来代替，如 XML 或<a class="ae kx" href="https://en.wikipedia.org/wiki/Extensible_Application_Markup_Language" rel="noopener ugc nofollow" target="_blank"> XAML </a>)。如果没有这种绑定技术，人们通常会使用 MVP 模式。</p><h2 id="4fee" class="lv ir hi bd is lw lx ly iw lz ma mb ja jz mc md je kd me mf ji kh mg mh jm mi bi translated">MVI(模型-视图-意图)</h2><p id="5cdc" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">MVI 基本上是安卓/KMM 模式。它的新颖之处在于受<a class="ae kx" href="https://cycle.js.org/" rel="noopener ugc nofollow" target="_blank"> Cycle.js 框架</a>启发的单向循环数据流:</p><figure class="lo lp lq lr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/65a964efa76d7e79f3e37d8f6c2a5334.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*knUoGDn2_ksuMyG5gkIYyQ.png"/></div></div><figcaption class="mq mr et er es ms mt bd b be z dx translated">来源:<a class="ae kx" href="https://cycle.js.org/dialogue.html" rel="noopener ugc nofollow" target="_blank">https://cycle.js.org/dialogue.html</a></figcaption></figure><figure class="lo lp lq lr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/3181163950cd9f2c7ce4e740f244cfe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/0*u4Niqk66vmuiwrtz.jpg"/></div></div><figcaption class="mq mr et er es ms mt bd b be z dx translated">来源:<a class="ae kx" href="https://github.com/arkivanov/MVIKotlin" rel="noopener ugc nofollow" target="_blank">https://github.com/arkivanov/MVIKotlin</a></figcaption></figure><p id="933d" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated">MVI 没有提到通常位于模型和视图之间的“某物”组件。将这两个组件粘合在一起的模式是不可知的。它只定义了:</p><ul class=""><li id="5581" class="km kn hi jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated">状态是从模型中派生出来的不可变数据，由视图呈现</li><li id="01a7" class="km kn hi jq b jr ky jv kz jz la kd lb kh lc kl kt ku kv kw bi translated">用户动作被翻译成用于更新模型的<code class="du mv mw mx my b">intents</code>(尽管在某些定义中<code class="du mv mw mx my b">intent</code>是一个函数而不是“东西”)</li><li id="4972" class="km kn hi jq b jr ky jv kz jz la kd lb kh lc kl kt ku kv kw bi translated">数据流是单向的</li></ul><p id="385a" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated">您可以找到该模式的几个实现，例如<a class="ae kx" href="https://arkivanov.github.io/MVIKotlin/" rel="noopener ugc nofollow" target="_blank"> MVIKotlin </a>、<a class="ae kx" href="https://pedroql.github.io/mvflow/" rel="noopener ugc nofollow" target="_blank"> MVFlow </a>、<a class="ae kx" href="https://orbit-mvi.org/Core/architecture" rel="noopener ugc nofollow" target="_blank"> Orbit </a>或<a class="ae kx" href="https://github.com/genaku/Reduce" rel="noopener ugc nofollow" target="_blank"> Reduce </a>(列表不完整)以及一篇关于 MVI <a class="ae kx" href="https://hannesdorfmann.com/android/mosby3-mvi-1/" rel="noopener ugc nofollow" target="_blank">的精彩文章。</a></p><h2 id="422b" class="lv ir hi bd is lw lx ly iw lz ma mb ja jz mc md je kd me mf ji kh mg mh jm mi bi translated">状态-动作-模型</h2><p id="96ce" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">SAM 是 web 应用程序的一种模式，但是它的概念值得在移动应用程序的环境中讨论。两个主要的想法/概念是:</p><ol class=""><li id="31df" class="km kn hi jq b jr ko jv kp jz kq kd kr kh ks kl ls ku kv kw bi translated"><code class="du mv mw mx my b">view</code>是<code class="du mv mw mx my b">model</code>的一个函数，意味着有一段代码将<code class="du mv mw mx my b">model</code>转换成<code class="du mv mw mx my b">state representation</code>，由<code class="du mv mw mx my b">view</code>呈现/显示。<br/>执行从<code class="du mv mw mx my b">model</code>到<code class="du mv mw mx my b">state representation</code>转换的那段代码是一个名为<code class="du mv mw mx my b">State</code>的函数(这个命名是不恰当的，因为状态是所有其他模式中的数据)。在 MVP 中，<code class="du mv mw mx my b">State</code>将是<code class="du mv mw mx my b">presenter</code>的一部分，在 MVVM，这将是<code class="du mv mw mx my b">binder</code>。</li><li id="fa19" class="km kn hi jq b jr ky jv kz jz la kd lb kh lc kl ls ku kv kw bi translated">视图<code class="du mv mw mx my b">events</code>被转换成<code class="du mv mw mx my b">proposal</code>以呈现给<code class="du mv mw mx my b">model</code>潜在地导致<code class="du mv mw mx my b">model</code>更新。<br/> <code class="du mv mw mx my b">Actions</code>是执行从<code class="du mv mw mx my b">events</code>到<code class="du mv mw mx my b">proposals</code>的翻译的函数。<code class="du mv mw mx my b">Proposals</code>是 MVI 的<code class="du mv mw mx my b">Intents</code>。</li></ol><figure class="lo lp lq lr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mz"><img src="../Images/03b387778cce18f311a58cf9f0b2c5e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TP70YuebHRwinYBzi3TKOw.png"/></div></div></figure><p id="cc62" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated">在图中可以看到，<code class="du mv mw mx my b">State</code>函数也可以在创建<code class="du mv mw mx my b">state presentation</code>之前触发<code class="du mv mw mx my b">Actions</code>，因此伪代码的流程是:</p><pre class="lo lp lq lr fd na my nb nc aw nd bi"><span id="db13" class="lv ir hi my b fi ne nf l ng nh">// accept/reject proposal and alter state<br/>model.accept(proposal)     </span><span id="7fe2" class="lv ir hi my b fi ni nf l ng nh">     // optional: trigger another action (State function)<br/>     .then(nextAction)</span><span id="5d8d" class="lv ir hi my b fi ni nf l ng nh">     // create the state representation (State function)<br/>     .then(createStateRepresentation)</span><span id="0e2a" class="lv ir hi my b fi ni nf l ng nh">     // render the state representation (View)<br/>     .then(renderView)</span><span id="aa47" class="lv ir hi my b fi ni nf l ng nh">     // record and send events (View)<br/>     .then(sendEvent)</span><span id="a330" class="lv ir hi my b fi ni nf l ng nh">     // create a proposal (Action function)<br/>     .then(createProposal)</span><span id="ce0a" class="lv ir hi my b fi ni nf l ng nh">     // and here we come full circle<br/>     .then(acceptProposal)</span></pre><p id="464b" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated">像 MVI 一样，萨姆定义了模型和视图之间的单向流动，而<code class="du mv mw mx my b">Actions</code>是 MVI 的<code class="du mv mw mx my b">Intents</code>。那么这和 MVI 有什么不同呢？</p><p id="1451" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated">MVI 只把不变性、单向流和意图定义为表达用户意图的载体。剩下的部分有待解释，不同的实现有不同的解决方案来填补空白。</p><p id="9d37" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated">另一方面，SAM 在定义模式的不同部分时更加具体/精确，尤其是在定义什么是函数、对象或数据结构时。例如，<code class="du mv mw mx my b">State</code>是一个函数，而<code class="du mv mw mx my b">Actions</code>是数据。这很重要，因为最终我们需要对视图和模型之间的“某些东西”做出具体的决定。到目前为止，我们讨论的大多数模式都相当模糊。例如，维基百科关于 MVVM 的文章<a class="ae kx" href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel" rel="noopener ugc nofollow" target="_blank">将视图模型描述为:</a></p><blockquote class="ld le lf"><p id="6703" class="jo jp lg jq b jr ko jt ju jv kp jx jy lh li kb kc lj lk kf kg ll lm kj kk kl hb bi translated"><em class="hi">视图模型</em>是公开公共属性和命令的视图的抽象。[…].MVVM 有一个<em class="hi">绑定器</em>，它自动化了视图和视图模型中绑定属性之间的通信。</p></blockquote><p id="3f4c" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated">不清楚视图模型到底是什么。它公开公共属性(是对象还是函数？)还有命令(它实现了<a class="ae kx" href="https://en.wikipedia.org/wiki/Command_pattern" rel="noopener ugc nofollow" target="_blank">命令模式</a>吗？)绑定器是什么，是类/对象还是函数？</p><p id="0a0c" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated">有了萨姆，事情就一清二楚了。</p><h2 id="282b" class="lv ir hi bd is lw lx ly iw lz ma mb ja jz mc md je kd me mf ji kh mg mh jm mi bi translated">BLoC(业务逻辑组件)</h2><p id="1c47" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">块是一个抖动的概念，它非常具体地定义了视图和块(“某些东西”)之间的交互，但没有定义块和模型如何交互:</p><figure class="lo lp lq lr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nj"><img src="../Images/33b0096c0deebd8fccf41c17bb59ebe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q4DZOVOGzCoCO6Xo"/></div></div></figure><ul class=""><li id="932b" class="km kn hi jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated"><code class="du mv mw mx my b">State</code>由 Bloc 作为流发出，由视图使用。Dart 中的一个<code class="du mv mw mx my b"><a class="ae kx" href="https://api.dart.dev/stable/2.15.1/dart-async/Stream-class.html" rel="noopener ugc nofollow" target="_blank">Stream</a></code>相当于一个 Rx <code class="du mv mw mx my b"><a class="ae kx" href="http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/core/Observable.html" rel="noopener ugc nofollow" target="_blank">Observable</a></code>(可以观察到取回发射的物品)。</li><li id="abaa" class="km kn hi jq b jr ky jv kz jz la kd lb kh lc kl kt ku kv kw bi translated"><code class="du mv mw mx my b">Events</code>由视图发送到 Bloc 入汇。Dart 中的一个<code class="du mv mw mx my b"><a class="ae kx" href="https://api.dart.dev/stable/2.15.1/dart-core/Sink-class.html" rel="noopener ugc nofollow" target="_blank">Sink</a></code>相当于一个 Rx <code class="du mv mw mx my b"><a class="ae kx" href="http://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/core/Observer.html" rel="noopener ugc nofollow" target="_blank">Observer</a></code>(可以接收物品)。</li></ul><p id="f009" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated">bloc 的新特性是它在视图和 Bloc 之间传播反应模式，并引入了有意义的命名约定(event -&gt; sink，stream -&gt; state)，因为它们是自我解释的。</p><p id="783b" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated">在此基础上，触及了一个我们还没有讨论的话题，ui 到组件的分解。</p><h2 id="1d23" class="lv ir hi bd is lw lx ly iw lz ma mb ja jz mc md je kd me mf ji kh mg mh jm mi bi translated">反应/还原</h2><p id="f893" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><a class="ae kx" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj"> React </strong> </a>本身就是一个框架，用来创建声明式的、可组合的 GUI/web 组件。这些组件呈现用户界面，具有生命周期，并且可以具有本地状态。没有提到控制器、模型、视图模型等等。因此，许多不同的框架试图填补空白(状态管理和视图绑定)。我们只讨论最流行的状态管理框架及其官方绑定库:Redux 和<a class="ae kx" href="https://react-redux.js.org/" rel="noopener ugc nofollow" target="_blank"> React Redux </a>。</p><p id="a2db" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated"><a class="ae kx" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"><strong class="jq hj">Redux</strong></a><strong class="jq hj"/>相当简单:</p><figure class="lo lp lq lr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nk"><img src="../Images/26c0a89af61838730b05a76fe21a372d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CmK-HjS9w7oCIe2c"/></div></div></figure><ul class=""><li id="2016" class="km kn hi jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated">集中式的<code class="du mv mw mx my b"><strong class="jq hj">store</strong></code>管理应用程序状态。它保存当前状态(包括视图状态)并使用<code class="du mv mw mx my b"><strong class="jq hj">reducers</strong></code>修改它，这个函数的签名是:<code class="du mv mw mx my b">(state: State, action: Action) -&gt; State</code></li><li id="1a80" class="km kn hi jq b jr ky jv kz jz la kd lb kh lc kl kt ku kv kw bi translated">视图订阅状态更改并相应地更新自身</li><li id="e931" class="km kn hi jq b jr ky jv kz jz la kd lb kh lc kl kt ku kv kw bi translated">视图调度<code class="du mv mw mx my b">actions</code>，它是<code class="du mv mw mx my b">reducers</code>的输入</li><li id="ec32" class="km kn hi jq b jr ky jv kz jz la kd lb kh lc kl kt ku kv kw bi translated">状态是不可变的，流是单向的</li></ul><p id="f3c9" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated">其他状态管理库/模式如<a class="ae kx" href="https://facebook.github.io/flux/" rel="noopener ugc nofollow" target="_blank"> Flux </a>或<a class="ae kx" href="https://facebook.github.io/flux/" rel="noopener ugc nofollow" target="_blank"> MobX </a>非常相似，但是使用多个存储而不是一个。它们都共享由存储服务的不可变状态的单向流。虽然 Redux 涵盖了状态管理和 React 视图部分，但我们仍然需要连接这两者的“东西”。</p><p id="646d" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated"><a class="ae kx" href="https://react-redux.js.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj"> React Redux </strong> </a>是官方 React UI 绑定层<a class="ae kx" href="https://react-redux.js.org/api/connect" rel="noopener ugc nofollow" target="_blank">，将</a>存储状态连接到组件属性(Store - &gt; View，<code class="du mv mw mx my b"><a class="ae kx" href="https://react-redux.js.org/using-react-redux/connect-mapstate" rel="noopener ugc nofollow" target="_blank">mapStateToProps</a></code>)并公开触发状态变化的函数(View - &gt; Store，<code class="du mv mw mx my b"><a class="ae kx" href="https://react-redux.js.org/using-react-redux/connect-mapdispatch" rel="noopener ugc nofollow" target="_blank">mapDispatchToProps</a></code>)。将<code class="du mv mw mx my b">React</code>与<code class="du mv mw mx my b">Redux</code>和<code class="du mv mw mx my b">React Redux</code>一起使用很大程度上遵循了 MVVM 模式，其中<code class="du mv mw mx my b">React Redux</code>是 MVVM 特有的绑定器。</p><p id="f53a" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated">我想再提一个对视图和商店之间的交互很重要的机制，那就是<code class="du mv mw mx my b">selectors</code>的使用。如果您直接订阅商店，那么无论何时发生任何变化，即使与 ui 组件无关，您都会得到通知。通过使用像<a class="ae kx" href="https://github.com/reduxjs/reselect" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj"> Reselect </strong> </a>这样的库，视图可以选择子状态，并且只有在特定的子状态改变时才检索更新(选择器是<a class="ae kx" href="https://en.wikipedia.org/wiki/Memoization" rel="noopener ugc nofollow" target="_blank">记忆函数</a>，它会记住先前调用的结果)。</p><p id="3066" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated">React / Redux 带来了一些新的想法(与我们之前讨论的其他模式相比):</p><ul class=""><li id="537b" class="km kn hi jq b jr ko jv kp jz kq kd kr kh ks kl kt ku kv kw bi translated">一个集中的全球国有商店</li><li id="909e" class="km kn hi jq b jr ky jv kz jz la kd lb kh lc kl kt ku kv kw bi translated">更新全局状态的减速器的概念</li><li id="b190" class="km kn hi jq b jr ky jv kz jz la kd lb kh lc kl kt ku kv kw bi translated">声明性 ui 组件</li><li id="8f13" class="km kn hi jq b jr ky jv kz jz la kd lb kh lc kl kt ku kv kw bi translated">到处都是反应模式</li><li id="1f2c" class="km kn hi jq b jr ky jv kz jz la kd lb kh lc kl kt ku kv kw bi translated">记忆选择器</li></ul><h2 id="08bd" class="lv ir hi bd is lw lx ly iw lz ma mb ja jz mc md je kd me mf ji kh mg mh jm mi bi translated">总结与展望</h2><p id="78b9" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在过去的 40 多年里，我们经历了从<strong class="jq hj"> MVC </strong>(在 it<a class="ae kx" href="https://folk.universitetetioslo.no/trygver/themes/mvc/mvc-index.html" rel="noopener ugc nofollow" target="_blank">1979 年</a>的最初定义中)中的紧密耦合组件到<strong class="jq hj"> MVP </strong>中的视图和模型的解耦，再到<strong class="jq hj"> MVVM </strong>中的(工具支持的)数据绑定的演变。</p><p id="0c2c" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated"><strong class="jq hj"> MVI </strong>将不可变数据和单向流添加到等式中，而<strong class="jq hj"> SAM </strong>将流形式化，并将状态突变和视图绑定定义为功能和设计模式的一等公民。</p><p id="44d3" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated"><strong class="jq hj"> Bloc </strong>增加了反应式编程和一些有用的术语(Bloc、stream、sink)，而<strong class="jq hj"> React/Redux </strong>引入了声明式 ui 组件、全局状态存储(或 multiple with Flux/MobX)和记忆化选择器(等等)。</p><p id="086c" class="pw-post-body-paragraph jo jp hi jq b jr ko jt ju jv kp jx jy jz li kb kc kd lk kf kg kh lm kj kk kl hb bi translated">我们将在这个系列的<a class="ae kx" rel="noopener" href="/p/e52b84aeb94d">第二部分</a>中把这些都放在一起。</p></div></div>    
</body>
</html>