<html>
<head>
<title>SOAP, REST and the Need of Message Brokers ??</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SOAP、REST和消息代理的需求？？</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/soap-rest-and-the-need-of-message-brokers-8d0eb1327215?source=collection_archive---------3-----------------------#2021-05-14">https://medium.com/nerd-for-tech/soap-rest-and-the-need-of-message-brokers-8d0eb1327215?source=collection_archive---------3-----------------------#2021-05-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/749068ee0b1032b7cedc93ca2d88d300.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nlO-BaDjKjal-W1knUhCYQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">来源(<a class="ae iu" href="https://dzone.com/articles/soap-vs-rest-api-a-comparative-analysis" rel="noopener ugc nofollow" target="_blank">https://dzone . com/articles/soap-vs-rest-API-a-comparative-analysis</a>)</figcaption></figure></div><div class="ab cl iv iw gp ix" role="separator"><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja"/></div><div class="hb hc hd he hf"><p id="de03" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">当你谈论SOAP和REST时，首先，你需要理解是什么导致了这两个术语。企业应用程序是由大型企业或企业网络使用的软件系统。他们通常涉及到，</p><ul class=""><li id="64e3" class="ka kb hi je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki bi translated">数据的持久性。</li><li id="6678" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">拥有大量数据。</li><li id="37c0" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">由许多并发用户访问。</li><li id="9ad7" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">有许多用户界面。</li><li id="f27f" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">与分散在企业或业务网络中的其他企业应用程序集成。</li><li id="a7be" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">与其他企业应用程序互操作。</li></ul><p id="ef22" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">当我们谈到企业应用程序架构的发展时，首先，我们有独立的大型机遗留系统，然后我们有2层和3层客户机-服务器架构。然后，我们进入所谓的面向服务的架构(SOA)。</p><h1 id="d56f" class="ko kp hi bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">什么是面向服务的架构(SOA)</h1><p id="0c5d" class="pw-post-body-paragraph jc jd hi je b jf lm jh ji jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz hb bi translated">面向服务的架构(SOA)是一种架构风格，其中现有的或新的功能被分组到原子服务中。换句话说，面向服务的架构定义了一种通过服务接口使软件组件可重用和可互操作的方法。服务使用通用的接口标准和架构模式，因此它们可以快速地集成到新的应用程序中。这消除了应用程序开发人员以前重新开发或复制现有功能或必须知道如何连接或提供与现有功能的互操作性的任务。发明SOA的一些主要原因是:</p><ul class=""><li id="a27c" class="ka kb hi je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki bi translated"><strong class="je hj">本地和远程系统之间的紧密耦合</strong>需要大量的带宽需求(例如:- CORBA，EJB，DCOM引入了高度耦合的RPC)。</li><li id="c7a6" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated"><strong class="je hj">互操作性问题</strong>主要是由于不同语言的数据类型不兼容(EJB和DCOM被绑定到特定的平台上，根本不能互操作)。</li></ul><p id="6ad2" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">那么SOAP和REST是如何连接这个SOA的呢？<strong class="je hj"> SOAP </strong>和<strong class="je hj"> REST </strong>是<strong class="je hj"> Web服务</strong>方法，被用作<strong class="je hj">通信技术来构建SOA </strong>。SOAP是<strong class="je hj">面向服务的Web服务</strong>，REST是<strong class="je hj">面向资源的Web服务</strong>。</p></div><div class="ab cl iv iw gp ix" role="separator"><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja"/></div><div class="hb hc hd he hf"><h1 id="c99e" class="ko kp hi bd kq kr lr kt ku kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll bi translated">简单对象访问协议(SOAP)</h1><p id="1c4e" class="pw-post-body-paragraph jc jd hi je b jf lm jh ji jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz hb bi translated">SOAP是一种消息协议，用于在计算机网络中以web服务的形式交换结构化信息。使用<strong class="je hj"> XML </strong>作为其消息格式，并依赖于应用层协议，如超文本传输协议(HTTP)和简单邮件传输协议(SMTP)进行传输。SOAP允许开发人员调用运行在不同操作系统(如Windows、macOS和Linux)上的进程，使用XML进行身份验证、授权和通信。由于像HTTP这样的web协议安装并运行在所有操作系统上，SOAP允许客户端调用Web服务并接收响应，而与语言和平台无关。SOAP必须与<strong class="je hj"> UDDI </strong>和<strong class="je hj"> WSDL </strong>一起工作，用于<strong class="je hj">服务注册中心</strong>、<strong class="je hj">服务提供者</strong>和<strong class="je hj">服务消费者</strong>功能的操作。</p><ul class=""><li id="93dc" class="ka kb hi je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki bi translated"><strong class="je hj"> WSDL: </strong> XML格式，描述什么是输入和输出消息，以及如何将这些消息打包(绑定)到SOAP信封中的不同协议。</li><li id="96fc" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated"><strong class="je hj"> UDDI: </strong> UDDI是一个基于XML的标准，用于描述、发布和查找web服务。</li></ul><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lw"><img src="../Images/40528982a83f4a92eb96975db2dc6787.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CprjyRVrbiqsEVOqNgW6FQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">XML中的WSDL表示</figcaption></figure><figure class="lx ly lz ma fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/0673609f570a0295bc0a2ce32566d378.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/1*-QxeSxdq5LRdPB4ascA3KA.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图1:服务注册中心、服务提供者和服务消费者功能</figcaption></figure><p id="9382" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">通常，SOAP消息是由以下元素组成的XML文档:</p><ul class=""><li id="ab69" class="ka kb hi je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki bi translated"><strong class="je hj">信封:</strong>定义消息的开始和结束。这是一个强制性的要素。</li><li id="e052" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated"><strong class="je hj"> Header: </strong>包含与SOAP请求或响应消息相关联的特定于应用程序的信息(例如，安全或加密信息)。它是一个可选元素。</li><li id="056e" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">正文:包含正在传输的消息的XML数据。这是一个强制性的要素。</li><li id="bcdb" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated"><strong class="je hj"> Fault: </strong>可选的Fault元素，提供处理消息时出现的错误信息。</li></ul><p id="9fb9" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">默认情况下，SOAP本质上是同步的，但是根据不同的企业集成模式，可以实现同步和异步服务调用。</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div class="er es mc"><img src="../Images/55e6cf9cdd669081fd54f85832f026cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*9oypPJXOtsj-f2ccA1753Q.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图2: SOAP消息概述</figcaption></figure><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/f832b73c28c6aab27389344a2e95a224.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nT0797qN9v0MDE5uTUCipQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">XML格式的SOAP消息</figcaption></figure></div><div class="ab cl iv iw gp ix" role="separator"><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja"/></div><div class="hb hc hd he hf"><h1 id="b1c2" class="ko kp hi bd kq kr lr kt ku kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll bi translated">表征状态转移(REST)</h1><p id="0ef5" class="pw-post-body-paragraph jc jd hi je b jf lm jh ji jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz hb bi translated">REST是一种<strong class="je hj">架构风格</strong>，其中客户端和服务器实现可以相互独立；这被称为<strong class="je hj">关注点分离</strong>。此外，这种分离允许每个组件独立发展。当不同的客户端访问相同的REST端点时，执行相同的操作，并接收相同的响应。RESTful服务也是<strong class="je hj">无状态的</strong>，这意味着服务器不需要知道客户端处于哪个状态，反之亦然。通过使用资源，这是可能的。<strong class="je hj">资源</strong>是您需要存储或发送给其他服务的对象、文档或实体。因此，它们不依赖于接口的实现。其余的是架构规范，它不像在SOAP中那样强制执行我们必须遵循的严格规则或官方标准。</p><p id="a926" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">在REST架构中，客户端将向服务器发送请求，服务器将修改请求中提到的资源。通常，请求包括:</p><ul class=""><li id="e775" class="ka kb hi je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki bi translated"><strong class="je hj"> HTTP请求方法</strong>，定义要执行哪种操作。</li><li id="89fc" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated"><strong class="je hj">头，</strong>允许客户端传递关于请求的信息。</li><li id="cd9a" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">资源的<strong class="je hj">路径</strong>。</li><li id="affe" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">包含数据的可选<strong class="je hj">消息体</strong>。</li></ul><h2 id="044e" class="me kp hi bd kq mf mg mh ku mi mj mk ky jn ml mm lc jr mn mo lg jv mp mq lk mr bi translated">HTTP请求方法</h2><ul class=""><li id="3d21" class="ka kb hi je b jf lm jj ln jn ms jr mt jv mu jz kf kg kh ki bi translated"><strong class="je hj"> GET: </strong>这些请求用于从服务器检索数据。</li><li id="d0e3" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated"><strong class="je hj"> POST: </strong>该方法用于将实体发送到指定的资源，通常会导致服务器上的状态发生变化。</li><li id="4c59" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated"><strong class="je hj"> PUT: </strong>这个方法用请求负载替换目标资源的所有当前表示。通常，用于更新数据。</li><li id="d48f" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated"><strong class="je hj">删除:</strong>该方法用于删除指定的资源。</li><li id="b31a" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated"><strong class="je hj">补丁:</strong>该方法用于对资源进行部分修改。在更新服务器中现有资源的属性时使用。</li></ul><p id="0e31" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">这些是在RESTful服务中构建CRUD操作时使用的主要方法。还有一些其他的方法如<strong class="je hj">头</strong>、<strong class="je hj">连接</strong>、<strong class="je hj">选项</strong>、<strong class="je hj">跟踪</strong>。你可以在<a class="ae iu" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods" rel="noopener ugc nofollow" target="_blank">https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods</a>找到更多细节。</p><h2 id="6f3c" class="me kp hi bd kq mf mg mh ku mi mj mk ky jn ml mm lc jr mn mo lg jv mp mq lk mr bi translated">头球</h2><p id="72e3" class="pw-post-body-paragraph jc jd hi je b jf lm jh ji jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz hb bi translated">在请求的报头中，<strong class="je hj">接受</strong>字段代表；服务器可以在响应中发送的内容类型。这将确保服务器不会发送客户端不理解的数据。</p><p id="9a16" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">当向客户端发送数据有效负载时，服务器必须在响应的报头中包含一个<strong class="je hj">内容类型</strong>。这个content-type头通知客户机在响应中接收什么类型的数据。服务器在响应中发回的内容类型应该与客户机在请求中指定的accept字段相匹配。</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/f80257ae73674fbd977a70533837ecb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UwxHeeQoKLjnGc5N_B14eQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">客户端在请求头中设置接受字段</figcaption></figure><figure class="lx ly lz ma fd ij er es paragraph-image"><div class="er es mw"><img src="../Images/b2459d0056ff9525d5390bb9b6c1b413.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*5eyJeKhn96YCYocxraBrtA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">服务器在响应头中设置内容类型字段</figcaption></figure><h2 id="94e8" class="me kp hi bd kq mf mg mh ku mi mj mk ky jn ml mm lc jr mn mo lg jv mp mq lk mr bi translated">小路</h2><p id="4c6b" class="pw-post-body-paragraph jc jd hi je b jf lm jh ji jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz hb bi translated">在RESTful API操作中，请求应该包含资源的路径，这些路径应该被设计成帮助客户端理解正在发生的事情。如果您发出一个get请求来检索一个ID为10的用户，那么Path应该是fashionbug.com/user/:id.的<strong class="je hj">GET</strong>Where】:ID”是我们在调用GET请求时传递的路由参数。</p><h2 id="5940" class="me kp hi bd kq mf mg mh ku mi mj mk ky jn ml mm lc jr mn mo lg jv mp mq lk mr bi translated">响应代码</h2><p id="92f4" class="pw-post-body-paragraph jc jd hi je b jf lm jh ji jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz hb bi translated">HTTP响应状态代码帮助客户端识别HTTP请求是否成功。响应分为以下五类:</p><ol class=""><li id="5abc" class="ka kb hi je b jf jg jj jk jn kc jr kd jv ke jz mx kg kh ki bi translated">信息回复(100–199)</li><li id="a3cf" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz mx kg kh ki bi translated">成功回答(200–299)</li><li id="8fda" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz mx kg kh ki bi translated">重定向(300–399)</li><li id="86c6" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz mx kg kh ki bi translated">客户端错误(400–499)</li><li id="94c1" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz mx kg kh ki bi translated">服务器错误(500–599)</li></ol><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es my"><img src="../Images/b17d234aa7a567453cb971372c935d10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w0deSZkBaHWxXMZ2rqy-7Q.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图SOAP与REST的比较</figcaption></figure><h2 id="b72c" class="me kp hi bd kq mf mg mh ku mi mj mk ky jn ml mm lc jr mn mo lg jv mp mq lk mr bi translated">要点</h2><p id="a3a8" class="pw-post-body-paragraph jc jd hi je b jf lm jh ji jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz hb bi translated">🔸在<strong class="je hj"> HTTP 1.0 </strong>中，它为每个请求使用一个短暂的连接。对于每个请求，都会创建一个新的连接，然后在收到响应后关闭。主要问题是它消耗了打开和关闭连接的时间。除此之外，HTTP 1.0按照接收请求的顺序响应请求。</p><p id="3a68" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">🔸作为对此的解决方案，<strong class="je hj"> HTTP 1.1 </strong>引入了<strong class="je hj">持久连接</strong>和<strong class="je hj">流水线</strong>。持久连接在连续请求之间保持连接打开，减少了打开新连接所需的时间。流水线有助于发送几个请求，甚至不需要等待应答，减少了网络中的延迟。但是HTTP 1.1在HTTP 1.0的基础上做了这些修改，因为没有重大的变化。因此，即使向服务器发送了几个连续的请求，服务器也会按照收到请求的顺序进行回复。</p><p id="e21f" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">🔸因此，尽管RESTful架构指定它提供异步通信，因为它使用HTTP 1.1作为协议，但我们设计的REST APIs仍然同步工作。为了实现异步特性，我们必须使用中间服务调用<strong class="je hj">消息代理</strong>。</p></div><div class="ab cl iv iw gp ix" role="separator"><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja"/></div><div class="hb hc hd he hf"><h1 id="a309" class="ko kp hi bd kq kr lr kt ku kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll bi translated">消息代理</h1><p id="8df2" class="pw-post-body-paragraph jc jd hi je b jf lm jh ji jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz hb bi translated">消息代理使应用程序和服务能够相互通信并交换信息。Message Broker通过在正式的消息传递协议之间转换消息来实现这一点。这允许相互依赖，即使它们用不同的语言编写或在不同的平台上实现。最重要的是，它有助于实现；</p><ul class=""><li id="ab7b" class="ka kb hi je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki bi translated">松散耦合通信</li><li id="d9ed" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">异步消息传递</li><li id="dd0e" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">可靠传递(一条消息保证传递一次，且仅传递一次)。</li></ul><p id="e1b7" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">消息代理可以使用消息中间件或面向消息的中间件(MOM)解决方案来验证、存储、路由和交付消息到适当的目的地。它充当其他应用程序之间的中介。因此，发送方可以在不知道接收方位置的情况下发送消息，也不用担心接收方的活动状态。这有助于系统内流程和服务的分离。消息代理提供两种不同风格的消息传递，称为<strong class="je hj">点对点</strong>和<strong class="je hj">发布者/订阅者</strong>消息传递。</p><h2 id="ae2d" class="me kp hi bd kq mf mg mh ku mi mj mk ky jn ml mm lc jr mn mo lg jv mp mq lk mr bi translated">点对点消息传递</h2><p id="e5f0" class="pw-post-body-paragraph jc jd hi je b jf lm jh ji jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz hb bi translated">在点对点模型中，一条消息<strong class="je hj">只传递给一个接收者</strong>。作为面向消息的中间件(MOM)，使用了一个<strong class="je hj">队列</strong>。队列负责保存消息，直到接收者准备好。发送方和接收方没有<strong class="je hj">时序相关性</strong>。当客户端发送消息时，无论消息是否正在运行，接收者都可以获取消息。</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div class="er es mz"><img src="../Images/09a695ca9528c26c9f728de8a622e631.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/1*t_5aTFyo7xmNLwOYSbQxXA.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图4:点对点消息传递</figcaption></figure><h2 id="b082" class="me kp hi bd kq mf mg mh ku mi mj mk ky jn ml mm lc jr mn mo lg jv mp mq lk mr bi translated">发布者/订阅者(发布/订阅)消息传递</h2><p id="e469" class="pw-post-body-paragraph jc jd hi je b jf lm jh ji jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz hb bi translated">在发布/订阅模式中，一条消息<strong class="je hj">被传递给所有的订阅者</strong>。就像广播一样。作为面向消息的中间件，使用了一个<strong class="je hj">主题</strong>。主题负责保存和传递消息。发布者和订阅者有<strong class="je hj">时间依赖性。</strong>客户端只能使用其订阅后发布的消息，并且必须保持活动状态才能使用这些消息。</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div class="er es na"><img src="../Images/76e15b4fd9631c173927aebd5fa76160.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/1*hzLrmxBU1Gjteb252kG6Wg.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图5:发布者/订阅者(发布/订阅)消息传递</figcaption></figure><p id="6f75" class="pw-post-body-paragraph jc jd hi je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz hb bi translated">市场上有不同种类的消息经纪人，如<strong class="je hj"> Kafka </strong>、<strong class="je hj"> RabbitMQ </strong>、<strong class="je hj">亚马逊SQS </strong>、<strong class="je hj"> Google Pub/Sub </strong>等。下面列出了每个消息代理的概述。</p><h2 id="9b85" class="me kp hi bd kq mf mg mh ku mi mj mk ky jn ml mm lc jr mn mo lg jv mp mq lk mr bi translated">阿帕奇卡夫卡</h2><p id="b08f" class="pw-post-body-paragraph jc jd hi je b jf lm jh ji jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz hb bi translated">它最初被设计为一个消息队列。该软件作为一个事件流平台迅速流行起来。无论哪里需要消息队列或消息代理系统，Kafka都是一个不错的选择。下面列出了一些主要功能:</p><ul class=""><li id="0be3" class="ka kb hi je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki bi translated">允许发布和订阅记录流。</li><li id="567b" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">使用容错方法存储记录流。</li><li id="ead8" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">允许应用程序解耦。</li><li id="82a3" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">它很容易得到。</li><li id="b998" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">在管理实时数据传输时，它提供了高吞吐量。</li><li id="3f40" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">仅支持异步通信。</li></ul><h2 id="c2d7" class="me kp hi bd kq mf mg mh ku mi mj mk ky jn ml mm lc jr mn mo lg jv mp mq lk mr bi translated">兔子q</h2><p id="4d29" class="pw-post-body-paragraph jc jd hi je b jf lm jh ji jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz hb bi translated">它是用Erlang编写的，最初是为高级消息队列协议(AMQP)设计的，但已经更新为支持其他协议，包括STOMP和MQTT。下面列出了一些主要功能:</p><ul class=""><li id="9662" class="ka kb hi je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki bi translated">支持消息传递技术，如<strong class="je hj">发布-订阅</strong>、<strong class="je hj">点对点</strong>和<strong class="je hj">请求-回复消息传递</strong>。</li><li id="b7e4" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">可以实现同步和异步通信模式。</li><li id="24ad" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">确保可靠性交付确认。</li><li id="6525" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">通过在群集的多个节点上复制队列，可以确保高可用性。因此，即使在硬件故障的情况下，消息也不会丢失。</li></ul><h2 id="7923" class="me kp hi bd kq mf mg mh ku mi mj mk ky jn ml mm lc jr mn mo lg jv mp mq lk mr bi translated">亚马逊SQS</h2><p id="396a" class="pw-post-body-paragraph jc jd hi je b jf lm jh ji jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz hb bi translated">亚马逊SQS是由亚马逊提供的完全托管的分布式消息队列服务。它具有成本效益，并提供简单的技术来管理运行在云中的系统的软件组件之间的通信。下面列出了一些主要功能:</p><ul class=""><li id="ff26" class="ka kb hi je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki bi translated">自动扩展到工作负载的大小。</li><li id="c9d8" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">随着需求的增长，只为您阅读和撰写的邮件付费。</li><li id="8043" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">您可以在标准队列和FIFO队列之间选择。</li><li id="abc6" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">FIFO队列确保消息按照发送的顺序准确地传递和处理一次。</li><li id="f969" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">“死信”队列有助于维护未处理消息。</li><li id="5228" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">支持同步和异步通信。</li></ul><h2 id="e137" class="me kp hi bd kq mf mg mh ku mi mj mk ky jn ml mm lc jr mn mo lg jv mp mq lk mr bi translated">谷歌发布/订阅</h2><p id="674c" class="pw-post-body-paragraph jc jd hi je b jf lm jh ji jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz hb bi translated">Google Cloud Pub/Sub是一种异步消息服务，用于在独立的应用程序之间发送和接收消息。由于可靠的消息存储和实时消息传递的低延迟，它是分发事件通知、从不同设备传输数据的完美应用程序。下面列出了一些主要功能:</p><ul class=""><li id="fe5a" class="ka kb hi je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki bi translated">它提供低延迟和高吞吐量。</li><li id="3b8e" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">支持推和拉消息传递。</li><li id="7b58" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">高度可靠，因为每封邮件都存储在多个服务器上。</li><li id="23cb" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">高度可伸缩，每秒支持10，000条消息</li><li id="44bb" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">传递和存储的消息都是加密的。</li><li id="05ab" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated">仅支持异步通信。</li></ul></div><div class="ab cl iv iw gp ix" role="separator"><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja jb"/><span class="iy bw bk iz ja"/></div><div class="hb hc hd he hf"><h1 id="4843" class="ko kp hi bd kq kr lr kt ku kv ls kx ky kz lt lb lc ld lu lf lg lh lv lj lk ll bi translated">参考</h1><p id="e1f4" class="pw-post-body-paragraph jc jd hi je b jf lm jh ji jj ln jl jm jn lo jp jq jr lp jt ju jv lq jx jy jz hb bi translated">要进一步了解详情，请查看这些资源；</p><ul class=""><li id="d46f" class="ka kb hi je b jf jg jj jk jn kc jr kd jv ke jz kf kg kh ki bi translated"><a class="ae iu" rel="noopener" href="/double-pointer/kafka-vs-activemq-vs-rabbitmq-vs-amazon-sns-vs-amazon-sqs-vs-google-pub-sub-4b57976438db">https://medium . com/double-pointer/Kafka-vs-ActiveMQ-vs-rabbit MQ-vs-Amazon-SNS-vs-Amazon-SQS-vs-Google-pub-sub-4b 57976438 db</a></li><li id="b27d" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated"><a class="ae iu" href="https://www.ibm.com/cloud/learn/message-brokers" rel="noopener ugc nofollow" target="_blank">https://www.ibm.com/cloud/learn/message-brokers</a></li><li id="86b3" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated"><a class="ae iu" href="https://www.altexsoft.com/blog/engineering/what-is-soap-formats-protocols-message-structure-and-how-soap-is-different-from-rest/" rel="noopener ugc nofollow" target="_blank">https://www . altex soft . com/blog/engineering/what-is-soap-formats-protocols-message-structure-and-how-soap-is-different-from-rest/</a></li><li id="795f" class="ka kb hi je b jf kj jj kk jn kl jr km jv kn jz kf kg kh ki bi translated"><a class="ae iu" href="https://www.codecademy.com/articles/what-is-rest" rel="noopener ugc nofollow" target="_blank">https://www.codecademy.com/articles/what-is-rest</a></li></ul></div></div>    
</body>
</html>