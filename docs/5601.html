<html>
<head>
<title>MVVM Architecture in Android(Using Retrofit, LiveData)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android中的MVVM架构(使用翻新、LiveData)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/mvvm-architecture-in-android-using-retrofit-livedata-9ee1ad138d57?source=collection_archive---------0-----------------------#2021-10-22">https://medium.com/nerd-for-tech/mvvm-architecture-in-android-using-retrofit-livedata-9ee1ad138d57?source=collection_archive---------0-----------------------#2021-10-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7ea2e56fa1e62720863374ef4af74f31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UROfn26fkxqT6Bk_jGOw1w.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">来自<a class="ae iu" href="https://www.pexels.com/photo/boy-in-white-t-shirt-sitting-on-chair-in-front-of-computer-4709285/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> Pexels </a>的<a class="ae iu" href="https://www.pexels.com/@cottonbro?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> cottonbro </a>摄影</figcaption></figure><h2 id="5139" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">什么是建筑，我们为什么需要建筑？</h2><p id="70a8" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">架构是你构建android代码和文件的方式。让你的项目具有可扩展性和可维护性是非常重要的。开发人员花更多的时间维护一个项目，而不是创建它，因此架构应该是干净和易于维护的。通常，从头开始创建一个项目需要几个月的时间，但是根据需求的不同，在几年内会添加各种形式的错误修复和新功能。</p><h2 id="a7c6" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">MVC VS MVVM？</h2><p id="5a8a" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">MVC是android的默认架构，视图是xml布局文件，控制器是活动类。在MVVM中，活动和xml文件都被视为视图，视图模型类包含所有业务逻辑。应用程序的用户界面和业务逻辑之间没有任何联系。</p><h2 id="480e" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">MVP VS MVVM？</h2><p id="3413" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">在MVP中，演示者知道视图，视图也知道演示者。他们通过一个界面相互交流。在MVVM，只有视图知道视图模型。viewmodel不知道视图。</p><h2 id="f6ea" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">这里的目标是什么？</h2><p id="40c6" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">将所有代码都写在<code class="du ko kp kq kr b"><a class="ae iu" href="https://developer.android.com/reference/android/app/Activity" rel="noopener ugc nofollow" target="_blank">Activity</a></code>或<code class="du ko kp kq kr b"><a class="ae iu" href="https://developer.android.com/reference/android/app/Fragment" rel="noopener ugc nofollow" target="_blank">Fragment</a></code>中是一个常见的错误。这些基于UI的类应该只包含处理UI和操作系统交互的逻辑。通过保持这些类尽可能精简，您可以避免许多与生命周期相关的问题。</p><p id="7043" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">要遵循的最重要的原则是关注点分离，也就是说，您的业务逻辑、UI和数据模型应该位于不同的位置。另一个是代码的解耦:每一段代码都应该作为一个黑盒，这样改变一个类中的任何东西都不会对你的代码库的另一部分产生任何影响。</p><h1 id="895f" class="kx iw hi bd ix ky kz la jb lb lc ld jf le lf lg jj lh li lj jn lk ll lm jr ln bi translated">什么是MVVM？</h1><p id="c99c" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">MVVM架构是一个模型-视图-视图模型架构，它消除了每个组件之间的紧密耦合。最重要的是，在这种架构中，子节点没有对父节点的直接引用，它们只有通过可观察对象的引用。</p><p id="2122" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated"><strong class="jv hj">模型:<br/> </strong>一个模型代表app的数据和业务逻辑。推荐的实现之一是通过observable公开它的数据。与常规的可观察对象不同，<strong class="jv hj"> LiveData </strong>尊重其他应用组件的生命周期，如活动和片段。</p><p id="983f" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">ViewModel:  <br/> ViewModel类旨在以生命周期感知的方式存储和管理UI相关数据。ViewModel不应该知道正在交互的视图。ViewModel类允许数据在配置更改(如屏幕旋转)后仍然存在</p><p id="be6e" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated"><strong class="jv hj">视图:</strong> <br/>视图是指应用程序的UI组件，即活动和片段。视图在这个模式中的角色是观察一个ViewModel可观察对象，以获取相应更新UI元素的数据。这部分是在我们的MainActivity类中实现的，在这个类中，我们观察来自ViewModel的数据，并在适配器上设置观察到的数据。</p><h2 id="50a7" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">什么是Android仓库？</h2><p id="c94c" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">大多数应用程序可以从本地存储器或远程服务器保存和检索数据。Android存储库是决定数据应该来自服务器还是本地存储的类，将您的存储逻辑与外部类解耦。</p><p id="ef98" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">现在我们已经熟悉了我们将在项目中使用的各种术语。让我们看看实际运行的代码</p><h1 id="9a74" class="kx iw hi bd ix ky kz la jb lb lc ld jf le lf lg jj lh li lj jn lk ll lm jr ln bi translated">实施:</h1><p id="10e7" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">在这个例子中，我们将使用一个简单的项目来展示MVVM的概念，在这个项目中，我们将使用reform从API中获取数据，并在我们的应用程序中显示这些数据</p><h2 id="19b8" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">第一步</h2><p id="1882" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">我们将为我们的响应创建模型类。你也知道这是POJO类。这表示来自API的响应</p><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="1dab" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">我们还使用了ResponseAPI类，稍后您会看到。</p><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="9274" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">第二步:<br/>为了从API获取数据，我们将使用一种改进。你可以在我之前的一篇文章<a class="ae iu" rel="noopener" href="/nerd-for-tech/using-retrofit-2-for-api-calls-674f59355383"> <strong class="jv hj">中找到实现，这里</strong> </a></p><p id="e54a" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated"><strong class="jv hj">第三步:<br/> </strong>现在我们将创建我们的模型视图类。LiveData类旨在以生命周期意识的方式存储和管理与UI相关的数据。注意我们是如何在模型视图类中使用init方法从API获取客户列表的。因此，每当我们初始化CustomerViewModel类时，它都会自动从服务器获取数据。<br/>存储库类是我们进行API调用和使用Livedata观察API响应的地方</p><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="926e" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">需要注意的一点是，我们使用postValue方法向我们的观察者发送更新。<br/>有两种选择，即你可以在主线程上更新数据，也可以使用后台线程更新数据。因此，<code class="du ko kp kq kr b">setValue</code>和<code class="du ko kp kq kr b">postValue</code>的用例只取决于这两种情况。</p><p id="210c" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated">当使用主线程更改数据时，您应该使用MutableLiveData类的<code class="du ko kp kq kr b">setValue</code>方法；当使用后台线程更改LiveData时，您应该使用MutableLiveData类的<code class="du ko kp kq kr b">postValue</code>方法。</p><h2 id="8557" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">第四步:</h2><p id="737f" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd jg ke kf kg jk kh ki kj jo kk kl km kn hb bi translated">现在让我们看看我们的活动类，我们将在其中声明我们的livedata对象并在UI中显示数据</p><figure class="lo lp lq lr fd ij"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="5158" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated"><em class="lu">暂时就这样吧！！<br/>感谢阅读，别忘了分享给你的开发伙伴:)【CodeTheraphy.com】本帖最初发布于</em><a class="ae iu" href="https://www.codetheraphy.com/" rel="noopener ugc nofollow" target="_blank"><em class="lu"/></a><em class="lu"><br/>。</em></p><p id="75fa" class="pw-post-body-paragraph jt ju hi jv b jw ks jy jz ka kt kc kd jg ku kf kg jk kv ki kj jo kw kl km kn hb bi translated"><em class="lu">更多文章关注我上</em> <a class="ae iu" rel="noopener" href="/@nandishswarup"> <em class="lu">中</em> </a> <em class="lu">和</em><a class="ae iu" href="https://www.codetheraphy.com/" rel="noopener ugc nofollow" target="_blank"><em class="lu">CodeTheraphy.com</em></a><em class="lu">你也可以联系我上</em><a class="ae iu" href="http://www.linkedin.com/in/nandish-swarup" rel="noopener ugc nofollow" target="_blank"><em class="lu">LinkedIn</em></a></p></div></div>    
</body>
</html>