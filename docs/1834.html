<html>
<head>
<title>Visualizing Bubble Sort</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可视化冒泡排序</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/visualizing-bubble-sort-c5ee6173c986?source=collection_archive---------17-----------------------#2021-04-09">https://medium.com/nerd-for-tech/visualizing-bubble-sort-c5ee6173c986?source=collection_archive---------17-----------------------#2021-04-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/21b9fdc5c986f9826a7b528b8addc4d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*taMQobXdSUzKepYse28b0w.png"/></div></div></figure><p id="06b2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我很确定你以前听说过冒泡排序算法。它可能是最简单也是最弱的排序算法。老实说，我从未觉得算法有趣，但我很幸运地发现了迈克·博斯托克的这篇文章。在这篇文章中，他解释了如何可视化不同的算法。他指出，你不需要一个数据集来可视化它。你可以用数学和逻辑的优雅来创造惊人的视觉效果。</p><p id="4d40" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我在网上搜索，发现了用简单算法创造的美妙的视觉艺术。所以我决定打开画笔，开始想象不同的算法。</p><p id="3e57" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于我以前从未尝试过可视化算法，我想从简单而优雅的东西开始，我能记得的大学时代的唯一算法是冒泡排序算法。</p><h1 id="8e04" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">冒泡排序算法</h1><p id="9399" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">有很多文章可以比我更好地解释这种算法。但是我将尝试给出一个简短的概述，这样您就不必额外点击新标签。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/c77c148dcd616b75e86b5cba5904783d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q8HQg-53CO6T1x41aQNFUg.png"/></div></div></figure><p id="f429" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是冒泡排序的工作原理。你把第一个元素和紧邻的元素进行比较，然后交换它们，它符合你的排序标准。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/dd4273ca5dea7eb484b70d18a1e8d4c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DHDtvscczS9UjacBbAJe_A.png"/></div></div></figure><p id="45e2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">移动到下一个元素，再次将其与紧邻的下一个元素进行比较。重复这个过程，直到到达元素的末尾。此时，您应该在最右侧找到最大或最小的元素(基于您的标准)。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/1a727d71e7a00ab3f126ffac3a6dfe9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WDKuSrYcUUz3249wMWZAOg.png"/></div></div></figure><p id="8cf3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下一次循环遍历元素时，不需要考虑最后一个元素。这意味着我们将比前一次少循环一次元素。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ks"><img src="../Images/5e759c1ad284b3272f024853b2105b84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S1-cDiN2yDKXLA-knsltYw.png"/></div></div></figure><p id="46e5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">既然枯燥的部分已经讲过了，我们可以可视化数据了。我说的数据是指我将生成的随机值。</p><h2 id="1cbb" class="kx jq hi bd jr ky kz la jv lb lc ld jz jb le lf kd jf lg lh kh jj li lj kl lk bi translated">排序随机高度</h2><p id="d506" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我在这里用P5.js来可视化这个算法。这是一个非常强大而简单的JavaScript库，用于处理2D和3D处理。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/878ce6f94cca33eaecca2700de79c475.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nl1TglkkygdLyNHPY8upGg.png"/></div></div></figure><p id="af08" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看一下代码。这里，全局范围的两个函数— <code class="du lm ln lo lp b">setup</code>和<code class="du lm ln lo lp b">draw</code>由P5.js提供。setup函数在执行开始时只运行一次。顾名思义，这个函数可以用来设置我们处理的初始状态。每一帧都会调用<code class="du lm ln lo lp b">draw</code>函数。所以我们实际上是在画布上画画。</p><p id="d1b2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们有三个全局变量— <code class="du lm ln lo lp b">array, i and sortedArr</code>。<code class="du lm ln lo lp b">array </code>是我存储元素的地方，以便以后过滤。<code class="du lm ln lo lp b">i</code>是跟踪循环进程的计数器，最后<code class="du lm ln lo lp b">sortedArr</code>是一个可选变量，我用它来改变排序元素的颜色。</p><p id="68e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">setup()—</strong>setup函数中的第一行是<code class="du lm ln lo lp b">createCanvas()</code>，它接受画布的两个参数— <code class="du lm ln lo lp b">width</code>和<code class="du lm ln lo lp b">height</code>。在下一行—</p><pre class="kt ku kv kw fd lq lp lr ls aw lt bi"><span id="fbaa" class="kx jq hi lp b fi lu lv l lw lx">array = new Array(width).fill().map(() =&gt; floor(random() * height));</span></pre><p id="5f08" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我正在创建一个新的数组，其元素数量等于用户浏览器的宽度，并用从0到浏览器高度范围内的随机值填充它们。</p><p id="93f8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">draw() — 在draw函数中，在设置了背景颜色之后，我正在进行if检查，这将运行冒泡排序算法。</p><pre class="kt ku kv kw fd lq lp lr ls aw lt bi"><span id="5f18" class="kx jq hi lp b fi lu lv l lw lx">if (i &gt; 0) {<br/> for (let j = 0; j &lt; i; j++) {<br/>  if (array[j] &gt; array[j + 1]) {<br/>  const temp = array[j];<br/>  array[j] = array[j + 1];<br/>  array[j + 1] = temp;<br/>  }<br/> }<br/> sortedArr[i] = true;<br/> i--;<br/>}</span></pre><p id="d011" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里需要一个<code class="du lm ln lo lp b">if </code>条件来确保它在所有元素排序后停止排序，而不是继续每个后续的绘制方法。在循环内部，我检查两个相邻的元素，并根据排序标准(冒泡排序)切换它们。</p><pre class="kt ku kv kw fd lq lp lr ls aw lt bi"><span id="e4b5" class="kx jq hi lp b fi lu lv l lw lx">for (let i in array) {<br/>    stroke(42, 178, 138);<br/>    line(i, height, i, height - array[i]);<br/>}</span><span id="d9cc" class="kx jq hi lp b fi ly lv l lw lx">if (sortedArr[i]) {<br/>      stroke(24, 98, 76);<br/>      line(i, height, i, height - array[i]);<br/>    }<br/> }</span></pre><p id="05ee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这最后一段代码中，我根据元素的高度来画线。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/763168f1ef1190fa8092bce1a4ba4375.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*nGNffMmq1VhgWffOI3qZtg.gif"/></div></div></figure><h2 id="413a" class="kx jq hi bd jr ky kz la jv lb lc ld jz jb le lf kd jf lg lh kh jj li lj kl lk bi translated">排序随机灰度</h2><p id="6e63" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">让我们对灰度进行排序，而不是对线条的高度进行排序。灰度值是2⁸位。这意味着它可以保存从0到255的值。0是绝对的黑色，255是绝对的白色。</p><pre class="kt ku kv kw fd lq lp lr ls aw lt bi"><span id="eb25" class="kx jq hi lp b fi lu lv l lw lx">array = new Array(width).fill().map(() =&gt; floor(random() * 255));</span></pre><p id="2939" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里我生成0-255之间的随机值。</p><pre class="kt ku kv kw fd lq lp lr ls aw lt bi"><span id="3bc0" class="kx jq hi lp b fi lu lv l lw lx">for (let i in array) {<br/>   fill(array[i]);<br/>   rect(i, 0, 2, height);<br/>}</span></pre><p id="c0d5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这一次我创建了宽度为2像素、高度为用户浏览器的矩形。用数组中随机生成的灰度值填充它们。</p><p id="9bfb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我无法上传用于灰度排序的GIF。<a class="ae jo" href="https://ayushman-git.github.io/bubble-sort-visualization/pages/grayscale.html" rel="noopener ugc nofollow" target="_blank">点击此处预览。</a></p><h2 id="f5a4" class="kx jq hi bd jr ky kz la jv lb lc ld jz jb le lf kd jf lg lh kh jj li lj kl lk bi translated">随机圆半径排序</h2><p id="762a" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">如果我们根据圆的半径对它们进行排序，并从一个原点画出它们，那么对它们进行排序是没有用的，因为你只是改变了圆的位置，而且因为所有圆的中心都是相同的，所以不会改变视觉外观。所以我在这里改变了排序圆的颜色。最终，它的视觉效果非常好，尽管这样排序没有多大意义。</p><pre class="kt ku kv kw fd lq lp lr ls aw lt bi"><span id="c3e0" class="kx jq hi lp b fi lu lv l lw lx">array = new Array(noOfCircles)<br/>    .fill()<br/>    .map(() =&gt; floor(random(1, height - 50)));</span></pre><p id="0ea4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这一次我填充了从<code class="du lm ln lo lp b">1</code>到<code class="du lm ln lo lp b">height — 50</code>之间的随机值，以确保圆圈不会从浏览器的视图中溢出。</p><figure class="kt ku kv kw fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/5a625e5b053e3733fb8f40259a8b67a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ViS_pMAdh8EjsKvFH83PEg.gif"/></div></div></figure><h1 id="18db" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="aef2" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">可视化算法非常有趣，将来我会可视化一些高级算法。您可以使用P5.js或unity来可视化这些算法。如果你觉得这类事情很有趣，请阅读我在开头提到的文章。我建议你也看看这个<a class="ae jo" href="https://www.youtube.com/user/Cercopithecan" rel="noopener ugc nofollow" target="_blank"> youtube频道</a>(除了他在unity中创建了精彩的模拟，我对这个家伙一无所知)。你也可以访问<a class="ae jo" href="https://github.com/ayushman-git/bubble-sort-visualization" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>获取完整代码。下次再看其他的图像。</p></div></div>    
</body>
</html>