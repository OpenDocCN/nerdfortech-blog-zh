<html>
<head>
<title>Difference between double equal and triple equal operators in JavaScript.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中两倍等于和三倍等于运算符的区别。</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/difference-between-and-equality-operators-in-javascript-e70df02825bc?source=collection_archive---------0-----------------------#2020-12-28">https://medium.com/nerd-for-tech/difference-between-and-equality-operators-in-javascript-e70df02825bc?source=collection_archive---------0-----------------------#2020-12-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/26873843676312f802f7cd6f92b17adb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*Cze1vX7Dt_FvNoSPOw1szA.jpeg"/></div></figure></div><div class="ab cl im in gp io" role="separator"><span class="ip bw bk iq ir is"/><span class="ip bw bk iq ir is"/><span class="ip bw bk iq ir"/></div><div class="hb hc hd he hf"><p id="dc50" class="pw-post-body-paragraph it iu hi iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq hb bi translated">因此==(宽松等式)和===(严格等式检查)运算符之间的区别一直是互联网上讨论的话题。让我们来看看这两者有什么不同。</p><p id="e8a4" class="pw-post-body-paragraph it iu hi iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq hb bi translated"><strong class="iv hj">宽松的相等检查或双等于(==): </strong>双等于运算符允许在比较过程中进行强制转换(即从一种数据类型转换成另一种数据类型)。在比较两个值时，Double equals遵循一种算法。算法在这里定义<a class="ae jr" href="https://www.ecma-international.org/ecma-262/#sec-abstract-equality-comparison" rel="noopener ugc nofollow" target="_blank">https://www . ECMA-international . org/ECMA-262/# sec-abstract-equality-comparison</a>。</p><figure class="jt ju jv jw fd ij er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es js"><img src="../Images/e69cea04349963d2b56aeef453c5a432.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y1GIw2DVp_tS-zd2WCm4RA.jpeg"/></div></div><figcaption class="kb kc et er es kd ke bd b be z dx translated">来源:<a class="ae jr" href="https://www.ecma-international.org/ecma-262/#sec-abstract-equality-comparison" rel="noopener ugc nofollow" target="_blank">https://www . ECMA-international . org/ECMA-262/# sec-abstract-equality-comparison</a></figcaption></figure><p id="9e3c" class="pw-post-body-paragraph it iu hi iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq hb bi translated">我们将讨论这个算法的几个要点。</p><p id="5f06" class="pw-post-body-paragraph it iu hi iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq hb bi translated"><strong class="iv hj">第1点:</strong>这一点表明，如果两个变量的类型相同，则进行严格的等式比较，并返回结果。所以如果两个操作数的类型相同，那么两个等于和三个等于就没有区别了。</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="kf kg l"/></div></figure><p id="15d7" class="pw-post-body-paragraph it iu hi iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq hb bi translated"><strong class="iv hj">点2 &amp; 3: </strong>这些点陈述了这样一个事实:在宽松等式比较中，<strong class="iv hj"> null </strong>和<strong class="iv hj"> undefined </strong>彼此相等。在转换过程中，这两者可以相互转换。</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="kf kg l"/></div></figure><p id="082b" class="pw-post-body-paragraph it iu hi iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq hb bi translated">如果你不关心一个值是空的还是未定义的，你所关心的是这个值是一个空值，那么这里的double equals证明是有益的。</p><figure class="jt ju jv jw fd ij"><div class="bz dy l di"><div class="kf kg l"/></div></figure><p id="fcb4" class="pw-post-body-paragraph it iu hi iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq hb bi translated"><strong class="iv hj">点4 &amp; 5 : </strong>这些点定义了如果两个操作数(变量)中的任何一个是字符串。使用to number()方法将字符串转换为数字，然后进行比较。双等号有利于数字比较。</p><p id="b12a" class="pw-post-body-paragraph it iu hi iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq hb bi translated"><strong class="iv hj">第8点&amp;第9点:</strong>这些点处理如果两个操作数中的任何一个是boolean，那么将使用ToNumber()方法将boolean转换成数字。布尔值true将被转换为1，而false将被转换为0。</p><p id="1fb5" class="pw-post-body-paragraph it iu hi iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq hb bi translated"><strong class="iv hj"> Points 10 &amp; 11 : </strong>如果任何一个变量是一个对象，那么这个对象将首先通过ToPrimitive()方法传递，然后进行比较。</p><p id="c2cb" class="pw-post-body-paragraph it iu hi iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq hb bi translated">如果两个操作数(变量)都是对象，那么如果两个对象是相同的对象(引用相同的对象),将返回true，否则将返回false。</p><h1 id="fd23" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><strong class="ak">重要观点:</strong></h1><ol class=""><li id="0127" class="lf lg hi iv b iw lh ja li je lj ji lk jm ll jq lm ln lo lp bi translated">null和undefined彼此相等。</li><li id="1a9d" class="lf lg hi iv b iw lq ja lr je ls ji lt jm lu jq lm ln lo lp bi translated">-0和+0相等。</li><li id="0d56" class="lf lg hi iv b iw lq ja lr je ls ji lt jm lu jq lm ln lo lp bi translated">-无穷大和+无穷大不相等。</li><li id="d2cf" class="lf lg hi iv b iw lq ja lr je ls ji lt jm lu jq lm ln lo lp bi translated">NaN值彼此不相等。</li></ol><p id="06c6" class="pw-post-body-paragraph it iu hi iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq hb bi translated"><strong class="iv hj">严格的相等检查或三重相等(===): </strong>三重相等不允许强制发生。它检查操作数的类型，如果两个类型相等，则算法检查操作数的值，否则返回false。</p><p id="2bea" class="pw-post-body-paragraph it iu hi iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq hb bi translated">null和undefined被视为两个独立的值。</p><h1 id="030f" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><strong class="ak">TL；博士</strong></h1><ol class=""><li id="6334" class="lf lg hi iv b iw lh ja li je lj ji lk jm ll jq lm ln lo lp bi translated">如果涉及的值的数据类型相同，将使用严格的等式。</li><li id="b86f" class="lf lg hi iv b iw lq ja lr je ls ji lt jm lu jq lm ln lo lp bi translated">如果有的话，非基元被强制为基元。</li></ol></div></div>    
</body>
</html>