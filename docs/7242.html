<html>
<head>
<title>Understanding Execution-context, Hoisting, Call-stack, Closures, Scope, Block in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解 JavaScript 中的执行上下文、提升、调用堆栈、闭包、作用域和块</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/understanding-execution-context-hoisting-call-stack-closures-scope-block-in-javascript-66eba6abec15?source=collection_archive---------1-----------------------#2022-09-04">https://medium.com/nerd-for-tech/understanding-execution-context-hoisting-call-stack-closures-scope-block-in-javascript-66eba6abec15?source=collection_archive---------1-----------------------#2022-09-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="f24b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意:我已经从我的博客中导入了它。所以可能看起来不像原帖。如果想看博客原文。请在这里访问<a class="ae jd" href="https://www.pansofarjun.com/post/understanding-execution-context-hoisting-call-stack-closures-scope-block-in-javascript#viewer-66cr6" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"><em class="je"/></strong></a>。</p><p id="1e3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JavaScript <strong class="ih hj"> <em class="je">是同步</em> </strong>吗？是的。</p><p id="ae76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JavaScript <strong class="ih hj"> <em class="je">是单线程</em> </strong> <em class="je"> - </em> <strong class="ih hj"> <em class="je">还是多线程</em> </strong> <em class="je">？</em>是的。</p><p id="3515" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">够了行话就像<strong class="ih hj"> <em class="je">线程</em> </strong>和<strong class="ih hj"> <em class="je">同步</em> </strong> <em class="je">。</em>我们先来了解一下这些术语。</p><blockquote class="jf jg jh"><p id="c528" class="if ig je ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated"><em class="hi">同步=顺序=一个接一个。</em></p></blockquote><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="31fc" class="ju jv hi jq b fi jw jx l jy jz">var a = 10; //first line <br/>var b = 'Javascript'; //second line <br/> <br/>Here <strong class="jq hj">synchronous </strong>means: <br/>The first variable '<strong class="jq hj">a</strong>' is assigned to 10, <br/>and then variable '<strong class="jq hj">b</strong>' is assigned to 'Javascript.'  </span><span id="421f" class="ju jv hi jq b fi ka jx l jy jz">The first line is executed, and then the second line is executed.</span></pre><blockquote class="jf jg jh"><p id="7e51" class="if ig je ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated"><em class="hi">单线程=一次处理一行。</em></p></blockquote><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="3995" class="ju jv hi jq b fi jw jx l jy jz">var a = 10 ; //first line</span><span id="edac" class="ju jv hi jq b fi ka jx l jy jz">var b = 'Javascript'; //second line<br/> <br/>Here <strong class="jq hj">single threade</strong>d means:<br/>When the process of assigning 10 to variable '<strong class="jq hj">a</strong>' - no other process happens at that time. <br/>Only when the first line finishes the second line starts.</span><span id="8563" class="ju jv hi jq b fi ka jx l jy jz">If the first line or process fails, the whole code fails.</span></pre><h2 id="962b" class="ju jv hi bd kb kc kd ke kf kg kh ki kj iq kk kl km iu kn ko kp iy kq kr ks kt bi translated">深入挖掘！</h2><p id="26c2" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">上述过程发生在哪里？这个简单的双赋值操作有一些共同的步骤。</p><ul class=""><li id="6739" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated">有两个变量，<strong class="ih hj"> a </strong>和<strong class="ih hj"> b </strong>。必须有<strong class="ih hj">内存</strong>分配给他们存储。</li><li id="0f3f" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">代码是<strong class="ih hj">执行</strong>。即对变量'<strong class="ih hj"> a </strong>和'<strong class="ih hj"> b </strong>赋值操作。</li></ul><p id="8210" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些步骤发生在<strong class="ih hj">‘执行上下文’中——</strong>新学期？对！</p><blockquote class="jf jg jh"><p id="2f8a" class="if ig je ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">执行-上下文</em> </strong> <em class="hi"> =发生</em>内存创建<em class="hi">和</em>代码执行<em class="hi"> n 的地方或环境。</em></p></blockquote><h2 id="d377" class="ju jv hi bd kb kc kd ke kf kg kh ki kj iq kk kl km iu kn ko kp iy kq kr ks kt bi translated">第一阶段——记忆创造:</h2><figure class="jl jm jn jo fd lo er es paragraph-image"><div class="er es ln"><img src="../Images/d5097d0997a0454c74ad2487aa70de7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/0*uxrEKRFcL6DXVB1d.png"/></div></figure><h2 id="1526" class="ju jv hi bd kb kc kd ke kf kg kh ki kj iq kk kl km iu kn ko kp iy kq kr ks kt bi translated">第二阶段—代码执行:</h2><figure class="jl jm jn jo fd lo er es paragraph-image"><div class="er es lr"><img src="../Images/b571e16c8cd1ff84fb4759ecdd888b74.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/0*qeqSFXxj1boybeDe.png"/></div></figure><blockquote class="jf jg jh"><p id="37a2" class="if ig je ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="hi">执行上下文</em> </strong> <em class="hi"> = </em>内存创建<em class="hi"> + </em>代码执行<em class="hi"> n. </em></p></blockquote><p id="b80a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意变量<strong class="ih hj"> a </strong>和<strong class="ih hj"> b </strong>在<strong class="ih hj"> <em class="je">内存阶段被<strong class="ih hj"> <em class="je">初始化</em> </strong>到<strong class="ih hj"> <em class="je">未定义</em> </strong>。</em> </strong>在代码执行之前，变量被初始化为<strong class="ih hj">未定义的</strong>。我们稍后会解释这一点。</p><p id="a0bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">如果有函数内部使用了变量和参数怎么办？</strong></p><p id="f124" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它有<strong class="ih hj">执行上下文吗？是啊！。</strong></p><p id="2997" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是一个<strong class="ih hj">单独的</strong>执行上下文吗？<strong class="ih hj">是的！。</strong></p><h2 id="1157" class="ju jv hi bd kb kc kd ke kf kg kh ki kj iq kk kl km iu kn ko kp iy kq kr ks kt bi translated">为什么要为函数分离执行上下文？</h2><p id="d3a8" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">因为函数内外都有变量和代码。函数可以访问函数外部的变量，但反之则不行。变量的范围不同。</p><p id="1b27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，两个执行上下文— <strong class="ih hj">全局</strong>和<strong class="ih hj">运行</strong>执行上下文。</p><p id="5580" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您运行 javascript 文件时，首先会创建一个全局执行上下文。当在 javascript 文件中遇到一个函数时，会在全局执行上下文之上创建一个全新的执行上下文。</p><blockquote class="jf jg jh"><p id="cf7a" class="if ig je ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated">一个。js 文件=一个全局范围=一个全局执行上下文(GEC)</p></blockquote><p id="1868" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">那么函数的内存分配呢？</strong></p><blockquote class="jf jg jh"><p id="2813" class="if ig je ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated">任何函数的内存分配都发生在父执行上下文中。</p></blockquote><p id="31e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来看一个例子，</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="0f04" class="ju jv hi jq b fi jw jx l jy jz">index.js  var a = 10; //first line <br/>var b = 'Javascript'; //second line  </span><span id="9960" class="ju jv hi jq b fi ka jx l jy jz"><strong class="jq hj">//Declaring function </strong><br/><strong class="jq hj">function </strong>Test(x){ <br/>return x; <br/>};  </span><span id="3dac" class="ju jv hi jq b fi ka jx l jy jz"><strong class="jq hj">var c = Test('execution');</strong></span></pre><p id="d44f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当 index.js 运行时，会创建一个全局执行上下文。</p><h2 id="c09e" class="ju jv hi bd kb kc kd ke kf kg kh ki kj iq kk kl km iu kn ko kp iy kq kr ks kt bi translated">GEC:</h2><p id="25a1" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated"><em class="je">注意:这里，测试函数的内存分配是在 GEC 创建的。因为测试函数的父执行上下文是 GEC 本身。</em></p><figure class="jl jm jn jo fd lo er es paragraph-image"><div class="er es ls"><img src="../Images/4c717d0de9647038cb722ded8025fbf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/0*XmJFEqkwwlxfbO9Z.png"/></div></figure><p id="7a83" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当代码执行遇到函数调用时— <strong class="ih hj">测试(‘执行’)。它为测试创建一个函数执行上下文。</strong></p><p id="fffc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">外汇券</strong></p><figure class="jl jm jn jo fd lo er es paragraph-image"><div class="er es ls"><img src="../Images/0a827264a58b027328298dc964cd4437.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/0*gq-BGznoRMPs_fHp.png"/></div></figure><p id="167b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将 FEC 安排在 GEC 之上被称为<strong class="ih hj">执行堆栈</strong>或<strong class="ih hj">调用堆栈。</strong></p><figure class="jl jm jn jo fd lo er es paragraph-image"><div class="er es lt"><img src="../Images/51a7b92c1d75cfa629264dcecde65bb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/0*gqARVvTJMD9-CldF.png"/></div></figure><p id="611e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">有回调之类的嵌套函数怎么办？</strong></p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="a611" class="ju jv hi jq b fi jw jx l jy jz">function foo(x) { <br/>return x <br/>}  </span><span id="fc01" class="ju jv hi jq b fi ka jx l jy jz">function bar(x){ <br/>foo(x) <br/>};  </span><span id="da40" class="ju jv hi jq b fi ka jx l jy jz">function baz(x){ <br/>bar(x) <br/>};  </span><span id="c39f" class="ju jv hi jq b fi ka jx l jy jz">baz('Hello from foo');<strong class="jq hj">//Hello from foo</strong></span></pre><figure class="jl jm jn jo fd lo er es paragraph-image"><div class="er es ls"><img src="../Images/e064ba9f5177c005b2615a3def0b2801.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/0*P5tIvplnW6QnvGfk.png"/></div></figure><blockquote class="jf jg jh"><p id="b515" class="if ig je ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated">调用堆栈/执行堆栈=处理执行上下文的顺序</p></blockquote><p id="1b54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">让我们在内存创建阶段定义<em class="je">未定义的</em>:</strong></p><p id="50dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们知道，在执行上下文的内存阶段，所有声明的变量将首先被赋值给未定义的变量。即使在实际代码执行之前，这种赋值也是默认行为。</p><p id="3f93" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">举个例子，</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="03f5" class="ju jv hi jq b fi jw jx l jy jz">// We can console the variable even before it is declared without any error  </span><span id="2b16" class="ju jv hi jq b fi ka jx l jy jz">console.log(a); <br/>var a = 10;</span></pre><p id="265f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在代码执行之前，<strong class="ih hj">变量‘a’在执行上下文的内存阶段被</strong>赋值给<em class="je">未定义的</em>。因此，上面的代码导致</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="931d" class="ju jv hi jq b fi jw jx l jy jz"><strong class="jq hj">undefined </strong>--&gt; without any error</span></pre><p id="02b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当<strong class="ih hj"> var 'a' </strong>未声明时，会出现什么错误？</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="dad7" class="ju jv hi jq b fi jw jx l jy jz">console.log(a);</span></pre><p id="7948" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它给出了这样一个参考误差。</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="b65a" class="ju jv hi jq b fi jw jx l jy jz">ReferenceError: a is not defined</span></pre><blockquote class="jf jg jh"><p id="21ae" class="if ig je ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated">所以<strong class="ih hj"> <em class="hi">未定义</em> </strong>和<strong class="ih hj"> <em class="hi">未定义</em> </strong>是不同的，至少在 JavaScript 词汇中是这样的。</p></blockquote><p id="15f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">代码执行阶段之前的执行上下文中的内存创建阶段的想法被称为<strong class="ih hj">‘提升’。</strong></p><blockquote class="jf jg jh"><p id="58c7" class="if ig je ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated">提升=甚至在代码执行之前访问声明的变量和函数。它是执行上下文中内存创建阶段的结果。</p></blockquote><p id="5339" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="je">提升</em> </strong> <em class="je">是一种 JavaScript 机制，在代码执行前将变量和函数声明移动到它们作用域的顶部。</em>这里的作用域可以是全局或函数作用域。</p><h2 id="70ba" class="ju jv hi bd kb kc kd ke kf kg kh ki kj iq kk kl km iu kn ko kp iy kq kr ks kt bi translated"><strong class="ak">深入研究范围！</strong></h2><p id="812f" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">我们将说明这一点，</p><figure class="jl jm jn jo fd lo er es paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="er es lu"><img src="../Images/16f033f0e9fd0f9306c239f85d875fa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*o8ht5bs79Ww6XToJ.png"/></div></div></figure><ul class=""><li id="497c" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated">这里<strong class="ih hj">变量 a </strong>的作用域是全局的 index.js。它对函数一和函数二都可用。</li><li id="da74" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">功能一可以访问<strong class="ih hj">‘a’</strong>，但不能访问<strong class="ih hj">‘c’</strong>和<strong class="ih hj">‘d’</strong>。</li><li id="5c7c" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">函数二可以访问<strong class="ih hj">‘a’</strong>和<strong class="ih hj">‘b’</strong>以及父函数和全局作用域可用的每个变量。</li></ul><p id="e591" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们试图在全局范围内访问'<strong class="ih hj"> c </strong>或'<strong class="ih hj"> d </strong>'会得到什么错误？</p><p id="4c01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是<strong class="ih hj">未定义</strong>还是<strong class="ih hj">未定义</strong>？停下来深思！</p><p id="87e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嗯，答案是</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="c642" class="ju jv hi jq b fi jw jx l jy jz">ReferenceError: c is not defined</span></pre><p id="3496" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">为什么是</strong>？每个函数都将在调用堆栈中创建单独的执行上下文。每个都有自己的<strong class="ih hj">记忆</strong>和<strong class="ih hj">代码</strong>相位。</p><p id="4478" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您创建如上的嵌套函数时，调用堆栈将是，</p><figure class="jl jm jn jo fd lo er es paragraph-image"><div class="er es lz"><img src="../Images/aa52aaa615507aa5748a83fe14d6090f.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/0*ZvGRNsfikZ5SZHpR.png"/></div></figure><p id="6781" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">两个 FEC 可以访问一个 FEC 和一个 GEC。这种限制访问外部函数的想法被称为“闭包”</p><blockquote class="jf jg jh"><p id="f782" class="if ig je ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated">闭包=访问外部作用域。</p></blockquote><p id="a25d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">闭包用在嵌套函数或回调中。</p><p id="f5ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在调用堆栈中，最里面的函数在顶部，最外面的函数在底部。全局执行上下文将是最底层的。</p><p id="89a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在继续之前，让我们回顾一下，</p><ul class=""><li id="c180" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated">JS 是一种单线程同步语言——按顺序一次处理一个任务。</li><li id="f1c3" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">JS 代码分两个阶段实现——内存<strong class="ih hj">阶段和代码执行<strong class="ih hj">阶段。</strong></strong></li><li id="fc0a" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">首先是内存阶段，然后是代码执行。</li><li id="50d8" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">这两个发生在一个叫做<strong class="ih hj">‘执行上下文’的环境中。</strong></li><li id="bde1" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">执行上下文可以是全局或函数执行上下文。<strong class="ih hj"> (GEC 和 FEC)。</strong></li><li id="c91c" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">使用内存创建阶段将变量和函数移动到作用域的顶部。这个概念叫做<strong class="ih hj">‘吊装’。</strong></li><li id="de7f" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">堆栈中执行上下文的排序称为<strong class="ih hj">执行堆栈或调用堆栈。</strong></li><li id="7464" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">当您嵌套函数时，内部函数将可以访问所有外部函数的范围。这叫做<strong class="ih hj">‘闭包’。</strong></li></ul><h2 id="83db" class="ju jv hi bd kb kc kd ke kf kg kh ki kj iq kk kl km iu kn ko kp iy kq kr ks kt bi translated"><strong class="ak">后果:</strong></h2><p id="613f" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">让我们深入挖掘一下<strong class="ih hj"> var。</strong></p><p id="ddd4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">var 范围:</strong></p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="99bc" class="ju jv hi jq b fi jw jx l jy jz"><strong class="jq hj">var a = 1;</strong> <br/>console.log(a) // prints 1 because var 'a' is global scoped </span><span id="4256" class="ju jv hi jq b fi ka jx l jy jz">function print() { <br/><strong class="jq hj">var a = 2;</strong> <br/>console.log(a); // prints 2 because var 'a' is function scoped <br/>};</span></pre><p id="8295" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">变量寻找最近的作用域，然后向外移动到全局作用域。感谢<strong class="ih hj">关闭。为什么？Function 和 Global 有不同的执行上下文。</strong></p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="6cb7" class="ju jv hi jq b fi jw jx l jy jz"><strong class="jq hj">var say = 'Hello'</strong>  </span><span id="c192" class="ju jv hi jq b fi ka jx l jy jz">function name() { <br/>var person = <strong class="jq hj">'John'</strong> <br/>console.log(`${say} ${person}`) //Prints Hello John <br/>}</span><span id="27c6" class="ju jv hi jq b fi ka jx l jy jz">name();  </span><span id="2b88" class="ju jv hi jq b fi ka jx l jy jz">console.log(person) // <strong class="jq hj">Error</strong>: var person is not defined --&gt; person is in FEC name and it is available only to function name.</span><span id="a0ae" class="ju jv hi jq b fi ka jx l jy jz"><strong class="jq hj">Hoisting implementation</strong> <br/>console.log(a) <br/>var a = 1;  </span><span id="2fce" class="ju jv hi jq b fi ka jx l jy jz">is interpreted as<br/> <br/>var a = undefined; //First memory phase in EC </span><span id="0007" class="ju jv hi jq b fi ka jx l jy jz">console.log(a); // prints undefined because of previous step --&gt; This is <strong class="jq hj">hoisting.</strong> </span><span id="2f90" class="ju jv hi jq b fi ka jx l jy jz">a = 1 // Now assignment takes place in the code execution phase in EC</span></pre><h2 id="0462" class="ju jv hi bd kb kc kd ke kf kg kh ki kj iq kk kl km iu kn ko kp iy kq kr ks kt bi translated">Var 的真正问题是:</h2><p id="b3c9" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">我们知道有两个执行上下文——一个用于全局(覆盖整个<em class="je">)。js </em>文件)和每个函数(函数一执行，就从调用栈中移除)。</p><p id="3a9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着除了函数作用域(FEC)内的变量之外的所有其他东西，比如 if..否则，尝试..渔获量将纳入全球范围(GEC)。基本上是两个范围。</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="a787" class="ju jv hi jq b fi jw jx l jy jz">var a = 1; <br/>var b = true; <br/>console.log(a); prints 1 because Global scope  </span><span id="8918" class="ju jv hi jq b fi ka jx l jy jz">if(y) { <br/>var a = 2; <br/>} </span><span id="34bb" class="ju jv hi jq b fi ka jx l jy jz">console.log(a)  <br/>// prints <strong class="jq hj">2 </strong>because values of <strong class="jq hj">var 'a'</strong> has been changed within the global context - no new execution context is created for '<strong class="jq hj">if' </strong>statements unlike <strong class="jq hj">'functions'</strong>.</span></pre><blockquote class="jf jg jh"><p id="f26f" class="if ig je ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated">在同一个执行上下文中，<strong class="ih hj"> var </strong>声明是可变的。</p><p id="5173" class="if ig je ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated"><strong class="ih hj"> Var </strong>可以更改或更新。</p><p id="c41b" class="if ig je ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated">提升过程中，<strong class="ih hj">变量</strong>初始化为<strong class="ih hj">未定义</strong>。我们可以在<strong class="ih hj">初始化</strong>之前访问它。</p></blockquote><p id="121c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">较大的应用程序有许多变量，如 if 语句、try-catch 等。我们可能会意外地使用相同的变量名，如上面例子中的<strong class="ih hj"> var 'a' </strong>。这可能会在我们的代码中产生意想不到的后果，从而影响整个应用程序。</p><p id="38ae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以<strong class="ih hj"> var </strong>声明有两个问题，</p><ul class=""><li id="ec05" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated">它要么是功能性的，要么是全局范围的。函数之外的任何声明都将具有全局范围。</li><li id="0d63" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">它在自己的范围内是可变的——全局的或功能性的。</li></ul><h2 id="0838" class="ju jv hi bd kb kc kd ke kf kg kh ki kj iq kk kl km iu kn ko kp iy kq kr ks kt bi translated">字母的出生和<em class="ma">常量</em>:</h2><blockquote class="jf jg jh"><p id="7f45" class="if ig je ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated"><strong class="ih hj"> const </strong>处理变更问题，而<strong class="ih hj">让</strong>处理范围问题。事实上，两者都有一个新的作用域叫做<strong class="ih hj">‘块作用域</strong>，并且最初都没有初始化为<strong class="ih hj">未定义</strong></p></blockquote><p id="1fe5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是等等。这里的<em class="je">挡</em>是什么？</p><blockquote class="jf jg jh"><p id="7a59" class="if ig je ih b ii ij ik il im in io ip ji ir is it jj iv iw ix jk iz ja jb jc hb bi translated">Block =被<strong class="ih hj"> { } </strong>包围的任何东西</p></blockquote><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="443a" class="ju jv hi jq b fi jw jx l jy jz">if <strong class="jq hj">{ </strong><br/>// it is a block <br/><strong class="jq hj">} </strong><br/>else <strong class="jq hj">{ </strong><br/>// it is a block <br/><strong class="jq hj">}  </strong><br/>try <strong class="jq hj">{ </strong><br/>// it is a block <br/><strong class="jq hj">} </strong><br/>catch <strong class="jq hj">{ </strong><br/>// it is a block <br/><strong class="jq hj">}</strong></span></pre><p id="bcf9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">举个例子，</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="e65e" class="ju jv hi jq b fi jw jx l jy jz">console.log(a); <strong class="jq hj">//  Cannot access 'a' before initialization</strong>  </span><span id="feb9" class="ju jv hi jq b fi ka jx l jy jz"><strong class="jq hj">const </strong>a = 1; // Assignment with <strong class="jq hj">const</strong>  </span><span id="3d93" class="ju jv hi jq b fi ka jx l jy jz">a = 2; // <strong class="jq hj">TypeError: Assignment to constant variable.</strong>  </span><span id="9592" class="ju jv hi jq b fi ka jx l jy jz">const a = 2; //<strong class="jq hj"> SyntaxError: Identifier 'a' has already been declared</strong></span><span id="d49e" class="ju jv hi jq b fi ka jx l jy jz">console.log(a); <strong class="jq hj">//  Cannot access 'a' before initialization</strong> <br/> <br/><strong class="jq hj">let </strong>a = 1; // Assignment with <strong class="jq hj">let</strong> <br/> <br/>a = 2;  <strong class="jq hj">***//Accepts this assignment operation ***</strong>  </span><span id="de54" class="ju jv hi jq b fi ka jx l jy jz">let a = 2; //<strong class="jq hj">SyntaxError: Identifier 'a' has already been declared</strong></span></pre><p id="9300" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="je">我们可以断定</em><strong class="ih hj"><em class="je">const</em></strong><em class="je">一旦声明就不能更改其值，而</em><strong class="ih hj"><em class="je">let</em></strong><em class="je">可以在声明后更改其值。</em></p><p id="48b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="je">注意:const 和 let 都不能重声明。它会给出一个语法错误。</em></p><h2 id="5f36" class="ju jv hi bd kb kc kd ke kf kg kh ki kj iq kk kl km iu kn ko kp iy kq kr ks kt bi translated">let 和 const 中的块作用域怎么办？</h2><p id="665c" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">Block =两个花括号{ }内的任何内容。因此，这包括函数。</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="252d" class="ju jv hi jq b fi jw jx l jy jz">const a = 1; <br/>let b = 1;  </span><span id="3bd3" class="ju jv hi jq b fi ka jx l jy jz">if(true) <strong class="jq hj">{</strong> <br/>...block starts<br/>  <br/>const a =2; <br/>console.log(a) // <strong class="jq hj">Prints 2 because of block scope for const.</strong>  </span><span id="cc95" class="ju jv hi jq b fi ka jx l jy jz">let b = 3; <br/>console.log(b) // <strong class="jq hj">Prints 3 because of block scope for let.</strong>  block </span><span id="6704" class="ju jv hi jq b fi ka jx l jy jz">end... <br/><strong class="jq hj">}</strong>  </span><span id="95e6" class="ju jv hi jq b fi ka jx l jy jz"><strong class="jq hj"><em class="je">// Within the block, there must not be the same variable names!!</em></strong>  <strong class="jq hj">function testing</strong> () <strong class="jq hj">{</strong> </span><span id="f67a" class="ju jv hi jq b fi ka jx l jy jz">const a =2; <br/>console.log(a) // <strong class="jq hj">Prints 2 because of block scope for const.</strong>  <br/>let b = 3; <br/>console.log(b) // <strong class="jq hj">Prints 3 because of block scope for let.</strong></span><span id="b994" class="ju jv hi jq b fi ka jx l jy jz"> <strong class="jq hj">}</strong></span></pre><p id="b91b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">let 和 const 都吊了吗？</strong></p><p id="9873" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是啊！它们被提升—移动到作用域的顶部，但没有初始化为未定义。这就是你得到<strong class="ih hj">‘初始化前无法访问’的原因。</strong>如果不吊，就是<strong class="ih hj">'未定义</strong>'</p><p id="6065" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="je">最初发表于 2022 年 9 月 4 日</em><a class="ae jd" href="https://www.pansofarjun.com/post/understanding-execution-context-hoisting-call-stack-closures-scope-block-in-javascript" rel="noopener ugc nofollow" target="_blank"><em class="je">https://www.pansofarjun.com</em></a><em class="je">。</em></p></div></div>    
</body>
</html>