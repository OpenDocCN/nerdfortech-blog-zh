<html>
<head>
<title>Intro to Graphs (part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图表介绍(第三部分)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/intro-to-graphs-part-3-6e4e5615642b?source=collection_archive---------15-----------------------#2021-04-03">https://medium.com/nerd-for-tech/intro-to-graphs-part-3-6e4e5615642b?source=collection_archive---------15-----------------------#2021-04-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2465b9cd486b10b84e8b5a6e93178064.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UGl6hB8xZsdgElt7"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Robynne Hu 在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="d2b1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">大家好！这是图表介绍系列的第 3 部分。<a class="ae iu" rel="noopener" href="/mlearning-ai/intro-to-graphs-part-1-af14f5901a67">第一部分</a>是对什么是图的一般性介绍。总之，图数据结构是顶点(节点)的有限集合和连接一对节点的边的集合。在图中，没有规则规定节点之间的连接。无论节点的位置如何，边都可以连接节点。第 2 部分学习了表示图形的两种标准方法，邻接矩阵和邻接表。这篇文章将讨论图的遍历。</p><h1 id="8b25" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">实际用途</h1><p id="1484" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">为什么我们需要知道图形数据结构？我们日常使用的图表有许多实际用途。</p><ul class=""><li id="3c5d" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">对等网络</li><li id="7207" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">网络爬虫</li><li id="caa1" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">寻找“最接近”的匹配/推荐</li><li id="1185" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">最短路径问题:</li></ul><p id="413f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">o GPS 导航</p><p id="3aff" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">o 解决迷宫</p><p id="f07a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">o AI(赢得游戏的最短路径)</p><h1 id="0ca2" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">深度优先搜索</h1><p id="32c0" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">深度优先搜索沿单个路径遍历，一次一个子节点，直到分支结束。深度优先搜索将告诉我们是否存在从起始节点到结束节点的路径。DFS 可以使用递归或迭代来实现。</p><h1 id="9a8d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak"> DFS 递归</strong></h1><p id="288c" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">递归实现通过查看起始节点的所有子节点直到到达结束节点来确定两个节点之间是否有路径。它通过递归地一次又一次地采取相同的步骤来确定两个节点之间是否存在这样的路径。我们沿着一条路走下去，直到到达终点，或者无法再继续走下去。如果这条路变成了死胡同，我们就往回走，沿着原路返回，直到找到另一条可行的路。</p><p id="f0f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">实施</strong></p><ul class=""><li id="005e" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">创建一个数组来存储最终结果</li><li id="1938" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">创建一个对象来存储访问过的顶点</li><li id="4e4e" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">创建一个接受顶点的辅助函数:</li></ul><p id="4d6a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">o 如果顶点是空的，辅助函数应该提前返回</p><p id="36a4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">辅助函数应该将它接受的顶点放到被访问的对象中，并将该顶点推入结果数组</p><p id="f152" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">o 循环遍历该顶点的邻接表中的所有值</p><p id="6bde" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果这些值中的任何一个没有被访问过，递归调用这个顶点的帮助函数</p><ul class=""><li id="6133" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">用起始顶点调用辅助函数</li><li id="a4ca" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">返回结果数组</li></ul><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es lk"><img src="../Images/55e786fbbbd3e8c29a3e14852dd0971b.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*TigBdYjVVSWwDlVBA5PVqA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">DFS 图</figcaption></figure><p id="2040" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们希望从节点 A 开始访问图中的每个节点。我们将 A 添加到结果数组中，并在被访问的对象中将 A 标记为已访问。我们从 A 到 B，将其标记为已访问，并将其添加到我们的结果数组中。我们可以在 B 处选择去 A 或 d。我们检查 B 是否有任何被访问过的边。已经访问了 A，所以我们忽略 A，转到下一个节点 D，我们将 D 标记为已访问，并将其添加到结果数组中。b 已经被访问过，所以我们转到下一个节点 d。我们可以转到 E 或 f。我们转到 E，然后转到 c。我们现在是在一个死胡同。我们仍然没有访问 F。节点 E 有三条边，C，D 和 F。使用我们的 helper 方法的递归，我们访问 F。结果数组将是[A，B，D，E，C，F]</p><h1 id="b5eb" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak"> DFS 迭代</strong></h1><p id="f9dc" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">迭代实现与递归实现非常相似。我们使用堆栈数据结构来跟踪顶点，而不是使用递归。<a class="ae iu" href="https://javascript.plainenglish.io/stack-of-pancakes-solving-remove-all-adjacent-duplicates-in-string-c3ace240f4f7" rel="noopener ugc nofollow" target="_blank">这里的</a>是我关于书库的文章，如果需要提醒的话。</p><p id="ae2d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">实现</strong></p><ul class=""><li id="feb4" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">创建一个堆栈来帮助跟踪顶点(使用列表/数组)</li><li id="55ba" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">创建一个数组来存储最终结果</li><li id="b1c9" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">创建一个对象来存储访问过的顶点</li><li id="31ab" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">将起始顶点添加到堆栈中，并将其标记为已访问</li><li id="9f56" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">当堆栈不为空时:</li></ul><p id="dc91" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">o 从堆栈中弹出下一个顶点</p><p id="1094" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">o 如果那个顶点还没有被访问过:</p><p id="628c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将其标记为已访问</p><p id="1128" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将其添加到结果列表中</p><p id="5631" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将其所有邻居推入堆栈</p><ul class=""><li id="696c" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">返回结果数组</li></ul><p id="3f82" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将使用与上面相同的图，我们仍然希望访问从节点 A 开始的每个节点。我们将 A 标记为已访问，将其添加到结果数组中，并将其从堆栈中弹出。我们检查 A 的邻居 B 和 C 是否被访问过。它们还没有，所以我们把它们添加到堆栈中，并把它们标记为已访问。堆栈现在是[B，C]。由于 C 是堆栈中的最后一个，我们从堆栈中弹出 C，转到 C，并将其添加到结果数组中。然后，我们将 C 的尚未访问过的邻居添加到堆栈中。堆栈现在是[B，E]。我们遵循同样的模式，直到堆栈为空。结果数组将是[A，C，E，F，D，B]。</p></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><h1 id="8e8e" class="jt ju hi bd jv jw lw jy jz ka lx kc kd ke ly kg kh ki lz kk kl km ma ko kp kq bi translated">广度优先搜索(BFS)</h1><p id="10de" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">广度优先搜索图遍历依赖于在访问子节点之前访问邻居节点，而不是遍历单个路径。从起始节点开始，它有子节点，而这些子节点又有自己的子节点。我们一层一层地遍历这个图。我们先访问一个节点，然后再访问它的所有子节点，最后再访问孙节点。我们使用队列数据结构来跟踪在移动到另一层之前要访问的节点。这里是我的一篇关于排队的文章，作为复习。广度优先搜索图遍历通常用于确定图中两个节点之间的最短路径。</p><p id="578b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">实施</strong></p><ul class=""><li id="4e0a" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">创建一个队列，并将起始顶点放入其中</li><li id="146d" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">创建一个数组来存储最终结果</li><li id="2bd4" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">创建一个对象来存储访问过的节点</li><li id="2f5d" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">将起始顶点标记为已访问</li><li id="069d" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">只要队列中有任何东西，就进行循环</li><li id="fc64" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">从队列中删除第一个顶点，并将其推入存储已访问节点的数组中</li><li id="cd39" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">循环遍历邻接表中你正在访问的顶点。</li><li id="e19c" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">如果它不在存储已访问节点的对象内部，则将其标记为已访问，并将该顶点排队</li><li id="8128" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">返回结果数组</li></ul><figure class="ll lm ln lo fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/7e4dcac3d307eaaeb61e8a6afb014e1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*jdcID25RhnQ-IIJEdvR3ww.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">BFS 图</figcaption></figure><p id="e27a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该图略有不同，但我们仍然希望从节点 A 开始访问图中的每个节点。我们将 A 标记为已访问，将其添加到结果数组中，并将其从队列中移除。我们检查 A 的邻居 B 和 C 是否被访问过。他们没有，所以我们将他们添加到队列中，并标记为已访问。现在的队列是[B，C]。与使用堆栈相反，我们从队列的前面移除。B 是队列中的第一个节点，所以我们从队列中移除 B，转到 B，并将其添加到结果数组中。然后，我们将 B 的尚未访问过的邻居添加到队列中。队列现在是[C，D]。我们遵循同样的模式，直到队列为空。结果数组将是[A，B，C，D，E，F]。</p><h1 id="63c2" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">资源</h1><p id="529e" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">关于图表的更多资源，我建议看看这些有用的链接。</p><p id="2bbb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">图遍历代码:<a class="ae iu" href="https://gist.github.com/Chanson9892/3a8aa720e93a5c06630ea10c73153eef" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/chanson 9892/3 A8 aa 720 e 93 a5c 06630 ea 10 c 73153 eef</a></p><p id="b602" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第一部分:<a class="ae iu" rel="noopener" href="/mlearning-ai/intro-to-graphs-part-1-af14f5901a67">https://medium . com/mlearning-ai/intro-to-graphs-part-1-af 14 f 5901 a 67</a></p><p id="0037" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第二部分:<a class="ae iu" rel="noopener" href="/mlearning-ai/intro-to-graphs-part-2-954f6f8af70f">https://medium . com/mlearning-ai/intro-to-graphs-part-2-954 F6 F8 af 70 f</a></p><p id="5ae2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Stack 文章:<a class="ae iu" href="https://javascript.plainenglish.io/stack-of-pancakes-solving-remove-all-adjacent-duplicates-in-string-c3ace240f4f7" rel="noopener ugc nofollow" target="_blank">https://JavaScript . plain English . io/stack-of-pancakes-solving-remove-all-adjacent-duplicates-in-string-C3 ace 240 F4 f 7</a></p><p id="8ecc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">队列篇:<a class="ae iu" href="https://javascript.plainenglish.io/how-to-use-queues-33370a0c8f3b" rel="noopener ugc nofollow" target="_blank">https://JavaScript . plain English . io/how-to-use-queues-33370 A0 c8 f3b</a></p><p id="a261" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Udemy 课程:<a class="ae iu" href="https://www.udemy.com/course/js-algorithms-and-data-structures-masterclass/" rel="noopener ugc nofollow" target="_blank">https://www . udemy . com/Course/js-algorithms-and-data-structures-master class/</a></p><p id="737e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">图表:【https://medium.com/swlh/data-structures-graphs-50a8a032db03 T4】</p><p id="f6df" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">DFS 图遍历:<a class="ae iu" rel="noopener" href="/basecs/deep-dive-through-a-graph-dfs-traversal-8177df5d0f13">https://medium . com/basecs/deep-dive-through-a-Graph-DFS-Traversal-8177d F5 d0f 13</a></p><p id="7ba5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">BFS 图遍历:<a class="ae iu" rel="noopener" href="/basecs/going-broad-in-a-graph-bfs-traversal-959bd1a09255">https://medium . com/basecs/going-broad-in-a-Graph-bfs-Traversal-959 bd1a 09255</a></p></div></div>    
</body>
</html>