<html>
<head>
<title>Building simple components using React library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用 React 库构建简单的组件</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/introduction-to-react-d8a871927ac?source=collection_archive---------6-----------------------#2021-12-12">https://medium.com/nerd-for-tech/introduction-to-react-d8a871927ac?source=collection_archive---------6-----------------------#2021-12-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c3b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个库是相关程序的集合，这些程序对于解决一个特定的目的是有用的。React 库的目的是以高效的方式呈现视图。</p><h1 id="efd7" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">反应组分</h1><p id="7200" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">React 组件是 react 应用程序的构建模块。下面的例子是关于创建文章，创建的文章显示在一个列表中。该功能被划分为 React 组件的构建块。React 组件可以包含其他 React 组件来形成树。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kg"><img src="../Images/6ea2aade26555f402e912151ecb86f1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*Nz_T51mMZGgbLjmg6uNezw.png"/></div></figure><h2 id="4fdb" class="ko je hi bd jf kp kq kr jj ks kt ku jn iq kv kw jr iu kx ky jv iy kz la jz lb bi translated">小道具</h2><p id="02d0" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">React 组件渲染依赖于道具(数据)。反应组件必须以一种能对道具作出反应的方式编码。下面一行是用 JSX 格式写的表达式。</p><blockquote class="lc ld le"><p id="f143" class="if ig lf ih b ii ij ik il im in io ip lg ir is it lh iv iw ix li iz ja jb jc hb bi translated"><div> { props.showBlock？<Block/>:空</div></p></blockquote><p id="ddf9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Block 是一个反应组件。UI 中的块组件是基于 props.showBlock 值呈现的。props.showBlock true 表示组件，false 表示组件消失。</p><h2 id="18f4" class="ko je hi bd jf kp kq kr jj ks kt ku jn iq kv kw jr iu kx ky jv iy kz la jz lb bi translated">反应堆</h2><p id="29d4" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">ReactDOM 是 React 的一个包，用于在 DOM 中呈现 React 组件。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lj"><img src="../Images/622c05b78c5e611a56a2f95aad6d7543.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cdm-2FX2K6Uiai6lMmfJ5Q.png"/></div></div></figure><h2 id="8a01" class="ko je hi bd jf kp kq kr jj ks kt ku jn iq kv kw jr iu kx ky jv iy kz la jz lb bi translated">React 中的单向工作流</h2><p id="1b71" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">视图是基于道具呈现的，当事件发生时，可以重新计算道具或数据。这有助于单向工作流。此工作流导致 react 中的可预测渲染。由于渲染是基于数据的，因此可以通过更改数据来更改视图。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lo"><img src="../Images/df9082f439ddf11028ba20c4eee97b23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TMWc1LSeNRWVSggX4IBd-A.png"/></div></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">单向反应流</figcaption></figure><h1 id="e49f" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">帖子列表示例</h1><blockquote class="lc ld le"><p id="3811" class="if ig lf ih b ii ij ik il im in io ip lg ir is it lh iv iw ix li iz ja jb jc hb bi translated">创建文章会将新文章添加到项目列表中。项目列表按从最新到最早的顺序显示。</p></blockquote><p id="3efb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该示例具有以下 React 组件</p><h1 id="3111" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">应用程序组件</h1><h2 id="589b" class="ko je hi bd jf kp kq kr jj ks kt ku jn iq kv kw jr iu kx ky jv iy kz la jz lb bi translated">创建帖子</h2><ol class=""><li id="40dc" class="lt lu hi ih b ii kb im kc iq lv iu lw iy lx jc ly lz ma mb bi translated">编者ˌ编辑</li><li id="eeb5" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">纽扣</li></ol><h2 id="72cb" class="ko je hi bd jf kp kq kr jj ks kt ku jn iq kv kw jr iu kx ky jv iy kz la jz lb bi translated">发布项目</h2><ol class=""><li id="c3d7" class="lt lu hi ih b ii kb im kc iq lv iu lw iy lx jc ly lz ma mb bi translated">项目</li></ol><p id="7841" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有这些项目都组织在一个树状结构中，如下所示。数据是以道具的形式从父节点传递过来的。分离道具和组件并从根组件传递道具是很好的，这样我们可以使用道具控制应用程序中的所有渲染。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es mh"><img src="../Images/85ebf565fb18f8ef856d0c3503f1fc8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0HN1d8MF8GIz47LmpEas4w.png"/></div></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">应用程序组件</figcaption></figure><h2 id="8622" class="ko je hi bd jf kp kq kr jj ks kt ku jn iq kv kw jr iu kx ky jv iy kz la jz lb bi translated">事件</h2><p id="83f4" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">为了从父函数中捕获子函数中的事件，最好将函数引用作为道具传递给子函数。子组件在事件上调用这个函数。所以<em class="lf"> onChange </em>和<em class="lf"> CreatePost </em>是从根组件传递过来的。最好将所有数据保存在 React 树之外的一个地方。这个道具通过 ReactDOM.render 传递给 React Tree 进行渲染。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es mi"><img src="../Images/d3a24445480f7085609668374028abfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZyScTER32sP4kUqGb3lVRA.png"/></div></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">在应用程序中渲染</figcaption></figure><h2 id="a021" class="ko je hi bd jf kp kq kr jj ks kt ku jn iq kv kw jr iu kx ky jv iy kz la jz lb bi translated">捕获输入事件</h2><p id="f2dd" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">输入更改时，数据必须保存在我们在外部维护的数据中。我们将 onChange 函数作为应用程序的一部分传递并捕获它。捕获的输入被传递给编辑器，因为它需要用新数据重新呈现。</p><p id="2636" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里需要注意的一点是，当我们再次渲染时，所有的组件都会随着数据的改变而重新渲染。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es mj"><img src="../Images/5beb049ea1418504b01cb537154b7471.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gZ9Xnx7xy7N6x28fQ902JQ.png"/></div></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">输入变化</figcaption></figure><h2 id="3294" class="ko je hi bd jf kp kq kr jj ks kt ku jn iq kv kw jr iu kx ky jv iy kz la jz lb bi translated">React .备忘录</h2><p id="e478" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我们可以使用<em class="lf"> React.memo </em>来避免不必要的渲染。这将有助于重新渲染一个组件，如果通过做浅层比较改变了属性。只有在遇到性能问题时才明智地使用 React.memo，以避免比较开销。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es mk"><img src="../Images/0fa676cb6a9cb2966eb00d7d5fff8396.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pgtxdFQuEwuR3Ghhyzz8Mg.png"/></div></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">使用反应备忘录</figcaption></figure><h2 id="c1d0" class="ko je hi bd jf kp kq kr jj ks kt ku jn iq kv kw jr iu kx ky jv iy kz la jz lb bi translated">点击添加项目</h2><p id="6308" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在 click 事件中，通过丢弃旧数据并用新项目重新创建数据，并再次进行渲染。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es ml"><img src="../Images/2379fcfd69e04b9dd818e362bcde023b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FDQEcAOoRXxN4lpnj9-yhw.png"/></div></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">点击按钮时创建帖子</figcaption></figure><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="mm mn l"/></div><figcaption class="lp lq et er es lr ls bd b be z dx translated">源代码</figcaption></figure><h1 id="177b" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">注意事项</h1><ol class=""><li id="8ef1" class="lt lu hi ih b ii kb im kc iq lv iu lw iy lx jc ly lz ma mb bi translated">React 是一个库，通过将渲染抽象成 React 组件，将渲染解耦到 DOM 中。它只在需要时才呈现实际的 DOM。</li><li id="c36f" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">一个组件渲染在大多数时候应该依赖于道具</li><li id="f1c0" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">通过 props 将函数引用从父节点传递到子节点以检测事件</li><li id="51ca" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">除非我们使用 React.memo 或类似的工作流，否则在根级别更改属性将会渲染所有组件</li><li id="2212" class="lt lu hi ih b ii mc im md iq me iu mf iy mg jc ly lz ma mb bi translated">除非有明显的性能问题，否则不要担心道具变化时的多次渲染</li></ol></div></div>    
</body>
</html>