<html>
<head>
<title>An opinionated Kotlin backend service - Database / Migration / ORM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">固执己见的Kotlin后端服务——数据库/迁移/ ORM</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/an-opinionated-kotlin-backend-service-database-migration-orm-52527ce3228?source=collection_archive---------1-----------------------#2021-05-07">https://medium.com/nerd-for-tech/an-opinionated-kotlin-backend-service-database-migration-orm-52527ce3228?source=collection_archive---------1-----------------------#2021-05-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/437fdee2fa230f0a3d0dc3c16e124c50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Qiu113ms6RGCYJcA.jpg"/></div></div></figure><p id="f424" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是我的基于Kotlin的后端服务系列的第四部分。<br/>如果你错过了前三部分:</p><ul class=""><li id="b308" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><a class="ae jx" rel="noopener" href="/p/87f814e3dffd">固执己见的科特林后端服务框架</a></li><li id="c0cd" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated"><a class="ae jx" rel="noopener" href="/p/480ab5e6cdb2">固执己见的科特林后端服务——构建&amp;部署</a></li><li id="b787" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated"><a class="ae jx" rel="noopener" href="/p/1e4b02aa6245">固执己见的Kotlin后端服务——API路由和文档</a></li></ul><h1 id="064e" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">ORM</h1><figure class="lc ld le lf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lb"><img src="../Images/9f1f1ef27273bed2b94920a4c014d5ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2D-k7p9NCCqQQQQY.png"/></div></div></figure><p id="a381" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与数据库交互大致有三种方式:</p><ul class=""><li id="da17" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated">直接使用SQL</li><li id="7379" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated">使用SQL包装DSL</li><li id="119e" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated">使用ORM(对象关系映射)</li></ul><p id="39bd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些当然只是粗略的分类，还有各种各样的“中间”解决方案，但我不想详细说明不同的方法。我的目标是<strong class="is hj">而不是</strong>为高容量、低延迟的事务创建一个框架，所以我决定使用ORM。</p><p id="3dcb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从Java世界来看，有一些明显的竞争者:</p><ul class=""><li id="647f" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><a class="ae jx" href="https://hibernate.org/" rel="noopener ugc nofollow" target="_blank">冬眠</a></li><li id="b396" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated"><a class="ae jx" href="https://ibatis.apache.org/" rel="noopener ugc nofollow" target="_blank">伊巴蒂斯</a></li><li id="78af" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated"><a class="ae jx" href="https://ebean.io/" rel="noopener ugc nofollow" target="_blank"> EBean </a></li><li id="5210" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated">更多…</li></ul><p id="3e65" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">像往常一样，我想要一个用简洁明了的Kotlin DSL为Kotlin构建的框架，但是没有一个Java框架符合这个要求。AFAIK实际上只有两个用Kotlin构建的ORM框架:</p><ul class=""><li id="cca4" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><a class="ae jx" href="https://github.com/JetBrains/Exposed" rel="noopener ugc nofollow" target="_blank">暴露</a></li><li id="1b67" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated"><a class="ae jx" href="https://www.ktorm.org/" rel="noopener ugc nofollow" target="_blank">k表格</a></li></ul><p id="9c07" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">两者都提供了类型安全的SQL包装DSL和DAO /实体API(ORM)。我们将忽略SQL包装部分，专注于ORM功能。我的模板代码我实现了两个框架，你可以在<em class="lg"> application.conf </em>文件中轻松地在两者之间切换:</p><pre class="lc ld le lf fd lh li lj lk aw ll bi"><span id="c75a" class="lm ke hi li b fi ln lo l lp lq">; possible values: [KTORM, EXPOSED]<br/>orm = "KTORM"</span></pre><p id="f2b0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意，API测试(本系列的第5篇文章)运行了两次测试，一次使用Ktorm，第二次使用Exposed。</p><h2 id="531f" class="lm ke hi bd kf lr ls lt kj lu lv lw kn jb lx ly kr jf lz ma kv jj mb mc kz md bi translated">数据库连接</h2><p id="f912" class="pw-post-body-paragraph iq ir hi is b it me iv iw ix mf iz ja jb mg jd je jf mh jh ji jj mi jl jm jn hb bi translated">无论使用哪种框架，连接到数据库都非常简单:</p><pre class="lc ld le lf fd lh li lj lk aw ll bi"><span id="1805" class="lm ke hi li b fi ln lo l lp lq">// Exposed<br/>org.jetbrains.exposed.sql.Database.connect(<br/>    url,<br/>    driver,<br/>    user,<br/>    password,<br/>)</span><span id="8ff8" class="lm ke hi li b fi mj lo l lp lq">// Ktorm<br/>org.ktorm.database.Database.connect(<br/>    url,<br/>    driver,<br/>    user,<br/>    password,<br/>    ConsoleLogger(LogLevel.<em class="lg">DEBUG</em>)<br/>)</span></pre><p id="33ed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">两者都可以使用<code class="du mk ml mm li b">javax.sql.DataSource</code>，这是企业应用程序中的常见情况，例如从连接池中获益。两个框架的语法是相同的:<code class="du mk ml mm li b">Database.connect(dataSource)</code>。在<a class="ae jx" href="https://github.com/1gravity/Ktor-Template/blob/31d654e6e98d3cb855b1844858f1f7dc6da74619/account-service/src/main/kotlin/com/onegravity/accountservice/persistence/database/DatabaseBaseImpl.kt" rel="noopener ugc nofollow" target="_blank"> Ktor模板</a>中可以找到包含连接池(使用<a class="ae jx" href="https://github.com/brettwooldridge/HikariCP" rel="noopener ugc nofollow" target="_blank"> HikariCP </a>)的工作代码示例。</p><h2 id="c758" class="lm ke hi bd kf lr ls lt kj lu lv lw kn jb lx ly kr jf lz ma kv jj mb mc kz md bi translated">intermezzo:Ktor中的配置和使用Koin的依赖注入</h2><p id="b6f5" class="pw-post-body-paragraph iq ir hi is b it me iv iw ix mf iz ja jb mg jd je jf mh jh ji jj mi jl jm jn hb bi translated">在进入下一个主题之前，我想详细说明一下Ktor是如何处理配置的(包括我们刚刚使用的数据库配置)。</p><p id="4240" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lg"> application.conf </em>通常是Ktor的必经之路。有预定义的属性来决定部署、安全性等。正如你在这里看到的<a class="ae jx" href="https://ktor.io/docs/configurations.html#hocon-file" rel="noopener ugc nofollow" target="_blank"/>。你也可以使用像<code class="du mk ml mm li b">${PORT}</code>这样的环境变量，它们可以被注入到运行时环境中。您还可以使用以下语法为这些变量提供默认值:</p><pre class="lc ld le lf fd lh li lj lk aw ll bi"><span id="63f2" class="lm ke hi li b fi ln lo l lp lq">port = 5432<br/>port = ${?DB_PORT}</span></pre><p id="0688" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">配置可以在模块中读取为<code class="du mk ml mm li b">this.environment.config</code> ( <code class="du mk ml mm li b">this</code>指应用程序类):</p><pre class="lc ld le lf fd lh li lj lk aw ll bi"><span id="c2db" class="lm ke hi li b fi ln lo l lp lq">environment.config.property("path.to.property")</span></pre><p id="fa2e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">很容易将配置作为“静态”变量或顶级函数暴露给应用程序中的每个组件。然而，我们确实想要修改配置的能力，例如为了测试的目的，因为我已经使用了<a class="ae jx" href="https://insert-koin.io/" rel="noopener ugc nofollow" target="_blank"> Koin </a>作为依赖注入框架，所以我决定利用DI。我创建了一个接口<code class="du mk ml mm li b">Config</code>，公开了一些访问属性的便利方法，并创建了一个简单的Koin绑定:</p><pre class="lc ld le lf fd lh li lj lk aw ll bi"><span id="e727" class="lm ke hi li b fi ln lo l lp lq">single&lt;Config&gt; { ConfigImpl(environment.config) }</span></pre><p id="b2f5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了访问配置，一个组件实现了<code class="du mk ml mm li b">KoinComponent</code>接口，并且:</p><pre class="lc ld le lf fd lh li lj lk aw ll bi"><span id="da0e" class="lm ke hi li b fi ln lo l lp lq">private val config by <em class="lg">inject</em>&lt;Config&gt;()</span></pre><p id="e9aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">或者在一个函数(不能实现<code class="du mk ml mm li b">KoinComponent</code>)的情况下:</p><pre class="lc ld le lf fd lh li lj lk aw ll bi"><span id="f500" class="lm ke hi li b fi ln lo l lp lq">val config = <em class="lg">getKoinInstance</em>&lt;Config&gt;()</span></pre><p id="7459" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">其中<code class="du mk ml mm li b">getKoinInstance</code>为:</p><pre class="lc ld le lf fd lh li lj lk aw ll bi"><span id="1fb2" class="lm ke hi li b fi ln lo l lp lq">inline fun &lt;reified T&gt; getKoinInstance() =<br/>    object : KoinComponent {<br/>        val value: T by <em class="lg">inject</em>()<br/>    }.value</span></pre><p id="f012" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意，我的模板实际上是从<code class="du mk ml mm li b">HoconApplicationConfig(ConfigFactory.load())</code>而不是<code class="du mk ml mm li b">environment.config</code>获取配置。前者似乎更像是Java的方式，但老实说，我不知道是否有区别，两者似乎都像预期的那样工作。</p><h2 id="a3fd" class="lm ke hi bd kf lr ls lt kj lu lv lw kn jb lx ly kr jf lz ma kv jj mb mc kz md bi translated">数据库表/实体</h2><p id="3c66" class="pw-post-body-paragraph iq ir hi is b it me iv iw ix mf iz ja jb mg jd je jf mh jh ji jj mi jl jm jn hb bi translated">两种框架定义数据库表和实体的语法非常相似:</p><p id="69dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">k表格</strong></p><figure class="lc ld le lf fd ij"><div class="bz dy l di"><div class="mn mo l"/></div></figure><p id="c049" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">暴露</strong></p><figure class="lc ld le lf fd ij"><div class="bz dy l di"><div class="mn mo l"/></div></figure><ul class=""><li id="246a" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><strong class="is hj">将表列绑定到实体属性</strong> : Ktorm在表定义(<code class="du mk ml mm li b">.bindTo{ it.propertyName }</code>)中进行绑定，而Exposed在实体(<code class="du mk ml mm li b">by Customers.propertyName</code>)中进行绑定。在我看来，将实体绑定到表更有意义，我也更喜欢Exposed的委托语法。</li><li id="b251" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated"><strong class="is hj"> Id定义:</strong>都支持自动递增的主键或其他任何数据类型作为主键(当然没有自动递增)。Exposed有一个方便的类<code class="du mk ml mm li b">IntIdTable</code>来消除定义自动递增主键的明确需要。</li><li id="9661" class="jo jp hi is b it jy ix jz jb ka jf kb jj kc jn jt ju jv jw bi translated"><strong class="is hj">数据类型:</strong> Ktorm似乎支持更多的数据类型<br/><a class="ae jx" href="https://www.ktorm.org/en/schema-definition.html#SqlType" rel="noopener ugc nofollow" target="_blank">https://www.ktorm.org/en/schema-definition.html#SqlType</a><br/><a class="ae jx" href="https://github.com/JetBrains/Exposed/wiki/DataTypes" rel="noopener ugc nofollow" target="_blank">https://github.com/JetBrains/Exposed/wiki/DataTypes</a><br/>我费了点劲才让Postgres ENUMs正常工作(大多是用Exposed)。Ktorm在其Postres库(<em class="lg">org . k torm:k torm-support-PostgreSQL</em>)中有一个特定的数据类型<code class="du mk ml mm li b">pgEnum</code>，它开箱即用。另一方面，Exposed需要定义一个不能开箱即用的<code class="du mk ml mm li b">customEnumeration</code>，我花了一些时间才找到:</li></ul><figure class="lc ld le lf fd ij"><div class="bz dy l di"><div class="mn mo l"/></div></figure><ul class=""><li id="d79a" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><strong class="is hj">引用:</strong> Exposed的语法比Ktorm更简洁:</li></ul><pre class="lc ld le lf fd lh li lj lk aw ll bi"><span id="9a8b" class="lm ke hi li b fi ln lo l lp lq">reference(“account_id”, Accounts)</span></pre><p id="c3dd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">相比于:</p><pre class="lc ld le lf fd lh li lj lk aw ll bi"><span id="bc58" class="lm ke hi li b fi ln lo l lp lq"><em class="lg">int</em>("account_id").<em class="lg">references</em>(Accounts) { it.account }</span></pre><ul class=""><li id="7693" class="jo jp hi is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw bi translated"><strong class="is hj">实体:</strong>在Ktorm中，实体是接口，这使得它们很难“重用”，例如作为HTTP请求的模型(例如，你不能用kotlinx.serialization来序列化/反序列化接口)。虽然从2.5版本开始支持数据类和常规类(参见这里的<a class="ae jx" href="https://www.ktorm.org/en/define-entities-as-any-kind-of-classes.html" rel="noopener ugc nofollow" target="_blank">和</a>)，但是这些限制太严重了，使它们无法真正替代接口(列绑定不可用，实体需要手动创建，实体操作API不可用)。使用Exposed，实体是常规类(而不是数据类),这肯定更方便。</li></ul><p id="24fb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当谈到表和实体定义的基础时，总体公开是明显的赢家！</p><h2 id="834d" class="lm ke hi bd kf lr ls lt kj lu lv lw kn jb lx ly kr jf lz ma kv jj mb mc kz md bi translated">实体操作</h2><p id="233d" class="pw-post-body-paragraph iq ir hi is b it me iv iw ix mf iz ja jb mg jd je jf mh jh ji jj mi jl jm jn hb bi translated">所有操作代码都封装在两个<em class="lg"> AccountDao.kt </em>和<em class="lg"> CustomerDao.kt </em>类中，因此您可以很容易地比较这两个框架</p><p id="b792" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">k torm:</strong><a class="ae jx" href="https://github.com/1gravity/Ktor-Template/blob/main/account-service/src/main/kotlin/com/onegravity/accountservice/persistence/model/ktorm/AccountDao.kt" rel="noopener ugc nofollow" target="_blank">account . Dao</a>/<a class="ae jx" href="https://github.com/1gravity/Ktor-Template/blob/main/account-service/src/main/kotlin/com/onegravity/accountservice/persistence/model/ktorm/CustomerDao.kt" rel="noopener ugc nofollow" target="_blank">customer . Dao</a><br/>k torm有一个<code class="du mk ml mm li b">EntitySequence</code>的概念，用来查询实体。通过将实体添加到实体序列来插入新实体，删除和更新发生在实体本身上(在从实体序列中检索它之后)。更新需要使用<code class="du mk ml mm li b">flushChanges</code>函数显式写回。</p><p id="25bf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">Exposed:</strong><a class="ae jx" href="https://github.com/1gravity/Ktor-Template/blob/main/account-service/src/main/kotlin/com/onegravity/accountservice/persistence/model/exposed/AccountDao.kt" rel="noopener ugc nofollow" target="_blank">account . Dao</a>/<a class="ae jx" href="https://github.com/1gravity/Ktor-Template/blob/main/account-service/src/main/kotlin/com/onegravity/accountservice/persistence/model/exposed/CustomerDao.kt" rel="noopener ugc nofollow" target="_blank">customer . Dao</a><br/>Exposed的操作API对实体本身进行操作:<code class="du mk ml mm li b">Entity.find()</code>进行查询，<code class="du mk ml mm li b">Entity.new { }</code>插入新实体。更新和删除是直接在实体上执行的，不需要将更改与数据库“同步”, Exposed会处理这些。一个不便之处是每个数据库操作都需要一个活动的事务。如果你不把所有事情都打包到一个<code class="du mk ml mm li b">transaction { }</code>调用中，它将失败，并显示“没有上下文中的事务”错误。</p><p id="7f81" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">总的来说，这两个框架中的操作都很简单，这主要取决于你喜欢哪一个。我发现需要将每个操作打包到<code class="du mk ml mm li b">transaction { }</code>中，这不仅会带来不便(使代码更加冗长),还会带来潜在的bug。</p><h1 id="bd6a" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">数据库迁移</h1><p id="e3c5" class="pw-post-body-paragraph iq ir hi is b it me iv iw ix mf iz ja jb mg jd je jf mh jh ji jj mi jl jm jn hb bi translated">模式版本控制和迁移是一个需要很好解决的问题。我决定研究一下<a class="ae jx" href="https://www.liquibase.org/" rel="noopener ugc nofollow" target="_blank"> Liquibase </a>和<a class="ae jx" href="https://flywaydb.org/" rel="noopener ugc nofollow" target="_blank"> Flyway </a>。据我所知，他们两个都做这项工作。Liquibase的优势是在SQL之上支持XML、JSON和YML用于迁移脚本，这在具有多种数据库技术的异构环境中是一个优势，这将导致不同的SQL迁移脚本(例如，使用H2的本地开发和使用Postgres的测试/生产)。Liquibase将使用XML、JSON或YML格式的技术不可知的迁移脚本来支持这个用例。这里可以找到一篇比较这两种工具的好文章:<a class="ae jx" rel="noopener" href="/@ruxijitianu/database-version-control-liquibase-versus-flyway-9872d43ee5a4"> Liquibase vs Flyway </a>。</p><p id="c1f2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我最终决定使用Flyway。有一个免费的社区版，不允许作为两个最严重的限制(IMO)的模拟运行和撤销(向下迁移)。在添加了Gradle dependency(<em class="lg">org . flywaydb:flyway-core</em>)之后，它基本上需要这段代码:</p><pre class="lc ld le lf fd lh li lj lk aw ll bi"><span id="1cb2" class="lm ke hi li b fi ln lo l lp lq">Flyway<br/>    .configure()<br/>    .dataSource(jdbcUrl, username, password)<br/>    .load()<br/>    .migrate()</span></pre><p id="b7af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它将从resources文件夹加载迁移脚本，并在需要时进行迁移:</p><figure class="lc ld le lf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/0787c77867bbd54d814bb7c0608ad699.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/format:webp/1*wr0A5nNKEn0lSNSm8WpMTA.png"/></div></div></figure><p id="9955" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">仅此而已。确保坚持他们的版本化模式<code class="du mk ml mm li b">Vx__name.sql</code>(原文如此！)下划线。使用单个下划线是行不通的。</p><h1 id="2b20" class="kd ke hi bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">数据库创建</h1><p id="5952" class="pw-post-body-paragraph iq ir hi is b it me iv iw ix mf iz ja jb mg jd je jf mh jh ji jj mi jl jm jn hb bi translated">Flyway只创建和迁移模式，而不创建数据库本身。最初，我按照一些教程和文章手动创建了该数据库，如本文:<a class="ae jx" rel="noopener" href="/coding-blocks/creating-user-database-and-adding-access-on-postgresql-8bfcd2f4a91e">https://medium . com/coding-blocks/creating-user-database-and-adding-access-on-PostgreSQL-8 bfcd 2 F4 a91e</a>。因为我的模板是在docker容器中运行的，所以在Flyway施展魔法之前，您还需要执行到容器中来设置一切。</p><p id="c130" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在不同的电脑上做了几次之后(既费时又容易出错)，我决定自动化这个过程，并幸运地找到了这个答案:<a class="ae jx" href="https://stackoverflow.com/a/61729115/534471" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/a/61729115/534471</a>。</p><p id="3d64" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">解决方案基本上是创建一个<em class="lg"> init-database.sh </em>脚本(参见此处的<a class="ae jx" href="https://github.com/1gravity/Ktor-Template/blob/main/docker-databases/create-databases.sh" rel="noopener ugc nofollow" target="_blank"/>)并在<em class="lg"> docker-compose.yml </em>文件中引用它:</p><pre class="lc ld le lf fd lh li lj lk aw ll bi"><span id="bb12" class="lm ke hi li b fi ln lo l lp lq">volumes:<br/>  - ./init-database.sh:/docker-entrypoint-initdb.d/init-database.sh</span></pre><p id="bb45" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不再需要手动创建数据库！</p><p id="2cef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是本系列的第4部分。如果你喜欢这一点，那么请继续<a class="ae jx" rel="noopener" href="/p/87f814e3dffd">一个固执己见的Kotlin后端服务测试</a>。</p><p id="ed4b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">像往常一样，请随时提供反馈。编码快乐！</p></div></div>    
</body>
</html>