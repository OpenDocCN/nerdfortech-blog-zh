<html>
<head>
<title>DRY, WET, OR AHA?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">干，湿，还是啊哈？</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/dry-wet-or-aha-7c2132aaf047?source=collection_archive---------13-----------------------#2021-03-11">https://medium.com/nerd-for-tech/dry-wet-or-aha-7c2132aaf047?source=collection_archive---------13-----------------------#2021-03-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c645" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">软件工程是一个不断发展的行业，工程师或程序员面临着各种挑战。其中之一就是编写可伸缩和可维护的代码。</p><p id="917f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实现可维护代码库的方法之一是代码的抽象和可重用性，以防止代码中到处重复。这就是通常所说的干(不要重复自己)。</p><p id="63b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们考虑一个例子:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/132716f61f6836cc1721e319504a6a99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8wDARBtB6BpCkHotUxkxnQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">筛选关键字不在关键字数组中的对象</figcaption></figure><p id="d6e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个函数很简单。它接受一个对象和一个键数组，如果该对象持有任何键，则删除该对象条目。</p><p id="674f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个函数与这个用例密切相关，可以在我们代码库中的任何地方用来过滤对象。太好了！。</p><p id="257a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们需要添加另一个用例，函数需要过滤并返回一个新的对象，其中 obj 键出现在 keys 数组中，该怎么办？本着干的精神，我们可能会做这样的事情(当然可以改进，但你得抓住要点)</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jt"><img src="../Images/09ddb51e067d1028024315ad85a49e7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yF3Mcbm0opglRGK2XnoZEQ.png"/></div></div></figure><p id="6142" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">万岁！！，我们的功能还是干的，可重用的，但是可维护吗？</p><p id="7fe3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们给一个简单的函数增加了另一层复杂性；因此，它没有做好一件事。你可能会说，但这是一个简单的“如果-否则语句”事实是，它不是“一个简单的 if-else 语句”。</p><p id="d011" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑到仍然围绕这些函数的其他用例，我们开始到处都有条件，我们创建了一个对每个人来说都是噩梦的怪物函数。</p><p id="5a32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用桑迪梅茨的话说；</p><blockquote class="ju jv jw"><p id="a7e1" class="if ig jx ih b ii ij ik il im in io ip jy ir is it jz iv iw ix ka iz ja jb jc hb bi translated">复制比错误的抽象要便宜得多。—桑迪·梅斯</p></blockquote><p id="38b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就把我们引向了湿(每样东西都写两遍)。</p><p id="8c94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑到上面的例子，即使上面的函数是相似的，如果把它们写在需要的地方会更好，因此去掉了不必要的抽象，并且容易维护。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/132716f61f6836cc1721e319504a6a99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8wDARBtB6BpCkHotUxkxnQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">筛选关键字不在关键字数组中的对象</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jt"><img src="../Images/914ef750c6a20b377992c489e4fdb1b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yORYhSO7gtR_nqji8sc4Ww.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">关键字出现在关键字数组中的对象的筛选器</figcaption></figure><p id="6dee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样，我们就有了两个易于维护和理解的功能，而不会增加额外的复杂性。</p><p id="5b95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一个好的抽象揭示了一个模式，而没有增加太多的复杂性。</p><p id="aa6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对我来说，一个经验法则是，一旦一个 if 语句出现在我的抽象中，我就“把所有东西都写两遍”</p><p id="2714" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">啊哈呢？它只是代表“避免草率的抽象”</p><p id="ef8d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们在上面的例子中遵循这个简单的术语，我们会很快发现我们在抽象上过于草率，这会导致一个巨大的函数超时。</p><p id="89a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们考虑一个例子:(归功于<strong class="ih hj">肯特·c·多兹</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kb"><img src="../Images/bdd3b291990d163a6f3eeb7716e94468.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IQPX19maJ1nU41UwOIsyuw.png"/></div></div></figure><p id="5c1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们在代码库或文件中处处都使用这种典型状态。考虑到我们还有另外两个将状态更新为 Pending 和 Success 的函数。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kc"><img src="../Images/857257bbe957dcde636a07ceb7e64acc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YeblLmf_tqkOmNwLBIacdA.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">将状态更新为待定</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kd"><img src="../Images/4a1358607e1a57722617d15e1b044f15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1qiBJLw2qfZ1cjCFiScDpQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">成功更新状态</figcaption></figure><p id="3d65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经编写了这些函数，正如我上面所说的，一个好的抽象揭示了一个模式。</p><p id="9e3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以提取返回的状态，如下所示:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ke"><img src="../Images/827feb4d6eb3ecd6a1a197e7579d0c40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*vkSaBIjLbmfH2i26YUHe4w.png"/></div></figure><p id="5cef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们避免了任何草率的抽象，并允许模式在这个用例中显露出来。</p><p id="3ba9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望，当你写你的可重用函数时，你会考虑干的，湿的，还是啊哈？</p><p id="7307" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢阅读。</p></div></div>    
</body>
</html>