<html>
<head>
<title>HTTP Request Smuggling: Part-2 (Identify &amp; Exploit)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">HTTP请求走私:第2部分(识别和利用)</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/http-request-smuggling-part-2-tl-ce-exploit-ec1171a88459?source=collection_archive---------0-----------------------#2021-07-31">https://medium.com/nerd-for-tech/http-request-smuggling-part-2-tl-ce-exploit-ec1171a88459?source=collection_archive---------0-----------------------#2021-07-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="65a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简而言之:对于笔测试者</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/2664e23adddf7eccd81f3aaf20bc1048.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*HetzyWaxL08FQp5vT-myRg.png"/></div></figure><p id="c628" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你是那些免费去太空旅行并直接回到这里的成员之一，建议你先看看<a class="ae jl" rel="noopener" href="/nerd-for-tech/http-request-smuggling-part-1-concepts-b89bfe17b210"> Part-1 【T1:)</a></p><p id="7ca2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当安全研究员詹姆斯·凯特尔(James Kettle)在2019年发现利用该漏洞的有趣方法时，HTTP请求走私漏洞这个老计时器重新浮出水面。这是为了简化白皮书第2部分。</p><h1 id="1f80" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">语境</h1><p id="b093" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">假设您已经阅读了<a class="ae jl" rel="noopener" href="/nerd-for-tech/http-request-smuggling-part-1-concepts-b89bfe17b210">第1部分</a>，现在我们已经清楚了基本概念，让我们来看看如何识别和利用HTTP请求走私的不同组合。但在此之前，让我们先解决房间里的大象。</p><h1 id="a4c1" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">向房间里的大象致辞</h1><blockquote class="kp kq kr"><p id="9fc2" class="if ig ks ih b ii ij ik il im in io ip kt ir is it ku iv iw ix kv iz ja jb jc hb bi translated">"根据HTTP/1.1标准，如果同时传递了内容长度和传输编码头，则传输编码优先."</p></blockquote><p id="e8ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当然，显而易见的意思是，如果传递了两个头，传输编码优先，但是服务器必须能够在任何给定的时间处理这两个头。让我们看一个例子:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es kw"><img src="../Images/cb0ab7299688603ba1f6fb2ae50f93a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZADekyf7S9r2sRM3ztLVQw.png"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx translated">理想场景</figcaption></figure><ul class=""><li id="a01b" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated">用户blue发送了一个只有内容长度头的理想请求，前端处理CL，后端也处理CL，响应得到了满意的服务</li><li id="5fed" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">类似地，用户green发送一个只有Transfer-Encoding报头的理想请求，前端处理TE，后端也处理TE，响应被愉快地服务</li></ul><p id="a6ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">相反，让我们把我们的请求分成两部分:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es lt"><img src="../Images/adcd869a64d8f3788e355d24ebfc88a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N1OM3YeO3UX0m2aXCEHSdg.png"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx translated">父母和孩子走私请求</figcaption></figure><ul class=""><li id="8b95" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated"><strong class="ih hj">父走私请求</strong>——这个请求有两个报头来欺骗服务器</li><li id="f2f5" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated"><strong class="ih hj">子走私请求</strong> -隐藏在父走私请求中的理想请求，为什么理想？因为它只有一个头</li></ul><p id="9854" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，我们正在讨论的这个房间里的大象到底是什么呢？前端服务器处理C1并将整个请求转发给后端服务器。</p><blockquote class="kp kq kr"><p id="a14e" class="if ig ks ih b ii ij ik il im in io ip kt ir is it ku iv iw ix kv iz ja jb jc hb bi translated">当上述请求到达后端服务器时，父走私请求用传输编码头进行处理，当未处理的块(也称为我们的子走私请求)被忽略时，当下一个用户的请求被添加到其中时，子走私请求现在用内容长度头进行处理，这意味着服务器(具体地说，在这种情况下是后端服务器)能够在任何给定时间处理CL和TE，这是房间中的大象:)</p></blockquote><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es lu"><img src="../Images/08176574f976685f0f32ec39d39612f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YX6Jq5LVNcTRlhWhZV2tOA.png"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx translated">后端处理TE和CL</figcaption></figure><p id="8842" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很棒吧？是的，如果你很好地理解了这一点，HTTP请求走私就像小菜一碟。</p><h1 id="4943" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">识别组合CL。TE还是TE。化学发光</h1><p id="b7c7" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">在<a class="ae jl" rel="noopener" href="/nerd-for-tech/http-request-smuggling-part-1-concepts-b89bfe17b210"> Part-1 </a>之后，我得到了几个问题，主要是，我如何识别前端是CE，后端是TL，或者相反。好问题。这就是为什么我想先解决房间里的大象，也就是说，如果一次发送一个头，服务器能够处理两个头。</p><p id="3cce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么CL是什么呢？TE还是TE。那CL呢？它是我们的有效负载，或者更具体地说是我们有效负载的结果，有效负载欺骗一个服务器处理内容长度，另一个服务器处理传输编码，反之亦然。让我们以这样一个有效载荷为例进行分析，注意，在Transfer-Encoding前面有一个空格:</p><pre class="je jf jg jh fd lv lw lx ly aw lz bi"><span id="3858" class="ma jn hi lw b fi mb mc l md me">Content-Length: 10<br/> Transfer-Encoding : chunked</span></pre><blockquote class="kp kq kr"><p id="8245" class="if ig ks ih b ii ij ik il im in io ip kt ir is it ku iv iw ix kv iz ja jb jc hb bi translated">理解这一点也很重要，HTTP/1.1只是一个标准，服务器实现它，这也意味着每个服务器都有自己的相同标准的实现。</p></blockquote><p id="d308" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述有效载荷导致CL。TE:</p><ul class=""><li id="3ae1" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated">即使传递了两个头，前端服务器也只处理内容长度，为什么？服务器有一个不处理前面有空格的头的验证，所以它认为传输编码头是无效的，很容易选择内容长度</li><li id="91c1" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">后端服务器在逆向处理传输编码，为什么？可能服务器没有对头前面的空格进行验证，这意味着它接受空格和传输编码头，所以它找到了这两个头，并且根据HTTP/1.1标准，传输编码优先</li></ul><p id="1a2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">坦率地说，这只是一个有效载荷，还有许多这样的有效载荷来混淆服务器并得到一个组合。</p><p id="a500" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">综上所述，为了识别请求走私及其组合，我们需要尝试所有可用的有效负载，看看哪一个有效。但是请记住，这需要在不中断应用程序的情况下安全地完成。</p><blockquote class="kp kq kr"><p id="be03" class="if ig ks ih b ii ij ik il im in io ip kt ir is it ku iv iw ix kv iz ja jb jc hb bi translated"><a class="ae jl" href="https://portswigger.net/bappstore/aaaa60ef945341e8a450217a54a11646" rel="noopener ugc nofollow" target="_blank">HTTP Request smugger</a>burp扩展在尝试所有可能的有效负载方面做得非常好，如果发现了组合，它会提醒您。它还使用基于超时的机制安全地识别漏洞。</p></blockquote><h1 id="f8ed" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">知道何时捕获队列</h1><p id="8f2f" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">此漏洞不同于传统的漏洞，在传统的漏洞中，您发送一个带有有效负载的HTTP请求，并根据即时响应来确认漏洞的存在。请记住，您正在一个TCP连接中处理多个HTTP请求。</p><p id="a608" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当您试图识别/利用HTTP请求走私时，有两种可能的情况:</p><ul class=""><li id="4267" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated"><strong class="ih hj"> <em class="ks">其他人得到响应</em> </strong> -您希望其他人得到我们发送的走私请求的响应。例如，当我们试图取消队列同步时。我们该怎么做？很简单，只需发送parent-straighted(红色)请求，等待队列去同步，其他人(绿色)得到意外的响应</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es mf"><img src="../Images/e923f2d69b53b47346d59a03ee73a200.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xT8N14jpfDTjXzW2AK0aKg.png"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx translated">其他人得到了回应</figcaption></figure><ul class=""><li id="655d" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated"><strong class="ih hj"> <em class="ks">你想要回复</em></strong>——大多数时候，别人得到回复并不会帮助我们。这是因为当我们试图识别/利用漏洞时，作为一种证明，我们将需要反馈给我们自己的响应。那么，我们该怎么做呢？嗯，我们自己也变成了用户绿色，这意味着我们需要连续/并发地发送多个HTTP请求，并且<strong class="ih hj">捕获队列</strong>，以便增加获得响应的机会。红色也是我们的要求，深红色也是我们的要求。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es mf"><img src="../Images/216b3ee2833a37e1c13222a478697c53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uSSw-AJ6H5zy7Z0kGyhjDQ.png"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx translated">我们得到回应</figcaption></figure><blockquote class="kp kq kr"><p id="5531" class="if ig ks ih b ii ij ik il im in io ip kt ir is it ku iv iw ix kv iz ja jb jc hb bi translated">在<!-- --> Burp中，您可以使用中继器发送多个请求并观察响应的差异，也可以使用<a class="ae jl" href="https://portswigger.net/bappstore/9abaa233088242e8be252cd4ff534988" rel="noopener ugc nofollow" target="_blank">Turbo intrusor</a>发送并发请求。在ZAP中，您可以使用Fuzz并在选项中配置并发扫描线程。</p></blockquote><h1 id="14d2" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">利用CL。特- (SSRF)</h1><p id="2a8f" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">好了，让我们进入实际的故事，在<a class="ae jl" rel="noopener" href="/nerd-for-tech/http-request-smuggling-part-1-concepts-b89bfe17b210">第1部分</a>中，我们看到了如何使用CL去同步一个队列。TE组合，并使用户收到用户不想收到的响应。让我们更进一步，看看我们如何利用CL。发动对SSRF的攻击。</p><p id="84b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">网络、应用程序的配置总是以易用性为优先，而不是安全性。您会发现某些应用程序的设计方式是这样的，一旦您通过前端服务器，您就可以访问有限的一组内部应用程序或几乎所有的应用程序，请记住，只有当您在组织的网络内部时，才能访问这些应用程序。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es mg"><img src="../Images/c9af55c685b9bd07952bd00ef0a26c2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AjXLXm3Vlz3KrPbzAvIGLA.png"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx translated">后端服务器作为代理</figcaption></figure><p id="ae76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的例子中，后端服务器是一个代理。它根据主机标头等标头将从前端收到的请求转发到不同的服务器。那么，如果我们发送下面的请求，在主机头中带有“stg”环境值，会发生什么呢？</p><pre class="je jf jg jh fd lv lw lx ly aw lz bi"><span id="fedd" class="ma jn hi lw b fi mb mc l md me">POST https://abcdefsecurity.com/ HTTP/1.1<br/>Host: <strong class="lw hj">stg.abcdefsecurity.com</strong></span></pre><p id="afb8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">前端服务器将拒绝该请求，因为主机头值是一个临时环境，它不允许您访问其内部网络。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es mh"><img src="../Images/224b0ac85eded2a9a32d81a14188536f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SVokcrNXTTXldEtHm_d_UA.png"/></div></div></figure><p id="5821" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是请记住，在某些应用中，一旦越过前端服务器，您就可以访问有限或完整的内部堆栈，如果我们以某种方式将此请求直接发送到后端服务器，会发生什么情况呢？那么这个请求肯定有可能被“stg”服务器处理。现在，想起来了吗？什么事？没有吗？好吧，这样吧，我们用CL。TE，发出一个访问“stg”服务器的走私请求，并让它只由后端服务器处理。酷吗？</p><p id="634b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实际上，我们想通过SSRF访问的是特定于应用程序或组件的，就像试图访问tomcat管理页面一样。对于这种情况，让我们假设在“stg.abcdefsecurity.com”中有一个“/admin”页面，它具有默认凭据“admin:admin ”,这就是将尝试对其进行SSRF的内容。</p><p id="8b48" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">修正我们是否需要回复的概念，这里是SSRF，所以我们肯定需要回复。如果我们需要我们的响应，我们需要捕获队列，这意味着我们发送多个请求以及父请求，以增加获得响应的机会。接下来，我们的父-走私的请求，如果发送这个请求到前端服务器会发生什么？</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es mi"><img src="../Images/c0b07a6efafa29579f72759ffed2479f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oMVJsa_NxKuRZV-qRblulg.png"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx translated">父级走私请求</figcaption></figure><ul class=""><li id="936c" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated">前端服务器接收请求，忽略传输编码，可能是因为它的验证引擎不允许重复的头，处理内容长度。它的值是159，这是包括孩子走私请求在内的整个主体的大小。它是完美的，它将请求转发到后端。</li><li id="7b19" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">后端服务器接收请求，忽略Content-Length，这可能是因为它的验证引擎没有任何重复报头的规则，所以它看到CL和TE报头，并且根据HTTP/1.1标准，传输编码优先，它处理第一个有效但为空的块。它不能处理下一个块，因为它是无效的，块仍然存在。</li><li id="87cf" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">现在，用户green的请求来了。注意，由于我们发送多个请求，我们也是绿色用户，所以我们的下一个请求是:</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es mj"><img src="../Images/3e16a2d272b94ab0ba32c93cbcac8ea0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CTfdqnAOLRq4jid5xjNFmA.png"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx translated">我们队列中的下一个请求</figcaption></figure><p id="f71d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这被添加到我们未处理的块中</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es mk"><img src="../Images/7a6d2fb0c31775d0cd29ba34814fcba6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x40eK4lPVVGHRIcaY-K0Sw.png"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx translated">下一个请求被追加到未处理的块中</figcaption></figure><ul class=""><li id="5ca1" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated">现在是有趣的部分，记住房间里的大象，用TE处理父走私请求的同一个后端服务器现在将使用CL处理子走私请求。我们指定的CL是什么？25，这正好是我们POST主体的长度，这样下一个请求就会被忽略。</li><li id="4ba2" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">如果/admin页面确实有默认凭据，响应将被发送回用户green，在本例中也是us，然后SSRF攻击成功。</li></ul><pre class="je jf jg jh fd lv lw lx ly aw lz bi"><span id="ef59" class="ma jn hi lw b fi mb mc l md me">HTTP/1.1 200 OK</span><span id="bc93" class="ma jn hi lw b fi ml mc l md me">You login is successful !</span></pre><h1 id="aa43" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">使用请求反射来识别标头</h1><p id="c4d7" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">我们可以认为以上是一个简单的例子。我们所要做的就是改变孩子走私请求中的主机头，对吗？现在，如果我们收到的是这个回复而不是200 OK，会怎么样呢？</p><pre class="je jf jg jh fd lv lw lx ly aw lz bi"><span id="0927" class="ma jn hi lw b fi mb mc l md me">HTTP/1.1 400 Bad Request</span><span id="c3b3" class="ma jn hi lw b fi ml mc l md me">Missing Internal Header 1 and Internal Header 2</span></pre><p id="67e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，实时内部报头的一个例子是“X-Forwarded-For”报头。等等，但是谁添加了这些头？前端处理请求并添加这些额外的内部标头。好了，现在我们如何找到这些内部头，让我们看看一种方法，通过使用一个叫做请求反射的概念。</p><blockquote class="kp kq kr"><p id="0411" class="if ig ks ih b ii ij ik il im in io ip kt ir is it ku iv iw ix kv iz ja jb jc hb bi translated">注意-请求反射将是你必须做的一个额外的预备步骤，在你做实际的SSRF步骤之前。</p></blockquote><p id="588a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了解释请求反射，让我们考虑下面的HTTP请求/响应:</p><pre class="je jf jg jh fd lv lw lx ly aw lz bi"><span id="c184" class="ma jn hi lw b fi mb mc l md me"><strong class="lw hj">REQUEST<br/></strong> <br/>POST /forgotuser HTTP/1.1<br/>Host: abcdefsecurity.com<br/>Content-Type: application/x-www-form-urlencoded<br/>Content-Length: 26<br/>Connection: Keep-Alive</span><span id="b07d" class="ma jn hi lw b fi ml mc l md me"><a class="ae jl" href="mailto:email=ironman@avengers.com" rel="noopener ugc nofollow" target="_blank">email=ironman@avengers.com</a></span><span id="f497" class="ma jn hi lw b fi ml mc l md me"><strong class="lw hj">RESPONSE</strong></span><span id="d3b4" class="ma jn hi lw b fi ml mc l md me">HTTP/1.1 200 OK</span><span id="28cb" class="ma jn hi lw b fi ml mc l md me">Email "ironman@avengers.com" does not exist</span></pre><p id="6cfb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这难道不是用户输入或email参数值完全反映在响应中的典型场景吗？在我们的笔试中，我们确实看到了很多这样的例子，不是吗？好了，这和获取内部头有什么关系呢？现在假设您试图利用SSRF的应用程序有一个类似的请求，我们将选择它并创建一个父级走私请求。是的，前一步也是另一个请求走私攻击。如果我们将下面的父走私请求发送到前端服务器，会发生什么？</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es mm"><img src="../Images/45e1ef2f5c742c5bd4b1dbb61bfa4da9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C6tHgHUDx5ttDqqilR6PJQ.png"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx translated">前端服务器处理之前的父级走私请求</figcaption></figure><ul class=""><li id="3dbb" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated">同样的故事，前端处理CL，CL是156，发送整个请求到后端。但在此之前，它会向请求添加几个内部标头，如下所示。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es mn"><img src="../Images/1b21da982dfe19876cfcd44147753399.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iRTCy_zP0htn16zCMeLLKQ.png"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx translated">前端服务器处理后的父级走私请求</figcaption></figure><ul class=""><li id="f2bb" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated">但可悲的是，我们将无法看到这些头，只有后端服务器可以。我们需要找到一种方法来查看这些标题。别担心，如果我们<strong class="ih hj"> <em class="ks">捕获了队列，它会自动发生；)</em> </strong></li><li id="ec67" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">后端接收请求，处理TE，识别第一个块，它是空的有效块，移动到下一个。它将无法处理我们的孩子走私的请求，这将作为一个未处理的块。</li><li id="1b9b" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">现在，队列中的下一个请求来了，因为我们正在捕获队列，所以下一个请求也是我们的。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es mo"><img src="../Images/37bc40480cf793ed5afc116d4f0df2e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z1RkXzxAWCgiY-Zh3ro1Sg.png"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx translated">我们的下一个要求</figcaption></figure><ul class=""><li id="94bb" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated">内部头也在这里，当然，前端会将内部头添加到它转发给后端的所有请求中。这个请求被附加到未处理的块上。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es mp"><img src="../Images/d13702ac28e8f1520696af6531f03c60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mT5MEKwF0gGyNCKyMHA6Zw.png"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx translated">我们的下一个请求被追加到未处理的儿童走私请求中</figcaption></figure><ul class=""><li id="20b6" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated">现在，后端将处理这个请求，但是作为CL，是的，房间概念中的相同大象。</li><li id="2c64" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">但是你有没有注意到这个请求中的CL实际上比POST主体内容要大？帖体'<strong class="ih hj"/>'的实际CL只有26，而我们提到的是165。这是它从下一个请求开始拉取的地方，这也是我们的请求。因此，下一个请求会被附加到email参数上。</li><li id="4cc7" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">我们知道这是一种请求，其中“电子邮件”参数的值反映在响应中，对于错误的电子邮件，您将得到:</li></ul><pre class="je jf jg jh fd lv lw lx ly aw lz bi"><span id="6ef1" class="ma jn hi lw b fi mb mc l md me">HTTP/1.1 200 OK</span><span id="e6ce" class="ma jn hi lw b fi ml mc l md me">Email "ironman@avengers.comGET /accountdetails HTTP/1.1<br/>Host: abcdefsecurity.com<br/>Internal-header: 1<br/>Internal-header: 2<br/>Cookie: JSESSIONID=45af3e9b-e498-4582-afab-" does not exist</span></pre><p id="5e73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">瞧，我们已经得到了我们的内部头和它的值。将这些头附加到子走私请求中，更改父走私请求的内容长度以适应内部头，发送它，SSRF应该会再次成功。</p><pre class="je jf jg jh fd lv lw lx ly aw lz bi"><span id="e5b9" class="ma jn hi lw b fi mb mc l md me"><strong class="lw hj">SSRF REQUEST:</strong></span><span id="a726" class="ma jn hi lw b fi ml mc l md me">POST / HTTP/1.1<br/>Host: abcdefsecurity.com<br/><strong class="lw hj">Content-Length: 188</strong><br/>Transfer-Encoding: chunked<br/>Transfer-Encoding: x<br/>Connection: Keep-Alive</span><span id="b1cf" class="ma jn hi lw b fi ml mc l md me">0</span><span id="8223" class="ma jn hi lw b fi ml mc l md me">POST /admin HTTP/1.1<br/>Host: stg.abcdefsecurity.com<br/>Content-Type: application/x-www-form-urlencoded<br/><strong class="lw hj">Internal-Header: 1<br/>Internal-Header: 2</strong><br/>Content-Length: 25</span><span id="6365" class="ma jn hi lw b fi ml mc l md me">user=admin&amp;password=admin</span><span id="1b2c" class="ma jn hi lw b fi ml mc l md me"><strong class="lw hj">SSRF RESPONSE:</strong></span><span id="05eb" class="ma jn hi lw b fi ml mc l md me">HTTP/1.1 200 OK</span><span id="6374" class="ma jn hi lw b fi ml mc l md me">You login is successful !</span></pre><blockquote class="kp kq kr"><p id="07da" class="if ig ks ih b ii ij ik il im in io ip kt ir is it ku iv iw ix kv iz ja jb jc hb bi translated">请记住，要使这一预备步骤成功，关键是在孩子走私请求中玩弄内容长度，比如它是165，不断增加它们，直到您得到您想要的，或者直到它在您超出请求后超时。</p></blockquote><p id="ad3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">休息一下，回忆一下:)</p><h1 id="8169" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">开发TE。CL(请求存储)</h1><p id="8652" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">最后一部分，我保证:)让我们，看看剥削TE。使用请求存储。请求存储与请求反射非常相似，只是它将存储在某个地方，与反射和存储的XSS不一样，但有些相似。让我们考虑一个请求，你试图从摄影师到博客更新你的简历:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mq"><img src="../Images/f2815a9286ce971036e5ebf944232425.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*cAvgqlh1lKuqbkrNGuVhbg.png"/></div><figcaption class="lb lc et er es ld le bd b be z dx translated">用户界面中的生物</figcaption></figure><pre class="je jf jg jh fd lv lw lx ly aw lz bi"><span id="8306" class="ma jn hi lw b fi mb mc l md me">PUT /updateprofile HTTP/1.1<br/>Host: abcdefsecurity.com<br/>Content-Type: application/x-www-form-urlencoded<br/>Content-Length: 21</span><span id="3ec9" class="ma jn hi lw b fi ml mc l md me">name=user&amp;bio=blogger</span></pre><p id="d0c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们构造我们的父走私请求，看看如果我们把它转发到前端服务器会发生什么？</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es mp"><img src="../Images/6025752f7f5ec2773c15d6332102ce27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jUWkyyxWxZ73wltiaqFJ0A.png"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx translated">TE。化学发光</figcaption></figure><ul class=""><li id="3a2f" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated">前端服务器可以看到这两个头，在传输编码头中分块之前，验证引擎不会验证“tab”。所以它看到了头，传输编码优先。它处理块，它是一个有效的块，它将整个请求发送到后端服务器。</li><li id="fd97" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">后端服务器忽略传输编码可能是因为它的验证引擎不允许任何头值有“制表符”，所以它处理有效的内容长度头。Content-Length是4，因此在上面的请求中只处理“96”和“\r\n”。剩余的未处理数据，也就是我们的子节点走私的请求，保留在后端服务器中。</li><li id="5d04" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">注意，对于这种攻击，我们不必捕获队列，我们只需发送第一个父级走私请求并离开它。所以前端服务器转发给后端服务器的下一个请求实际上是另一个用户的请求。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es mr"><img src="../Images/4907f9ab20800bd88f90e4d297792667.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lZGDITAGYytWsj7srIqMpQ.png"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx translated">另一个用户的实际请求</figcaption></figure><blockquote class="kp kq kr"><p id="b3bc" class="if ig ks ih b ii ij ik il im in io ip kt ir is it ku iv iw ix kv iz ja jb jc hb bi translated">警告——在测试时，不要真的期待这样的大奖请求:)但是你可以期待一个cookie！</p></blockquote><p id="64e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，下一个用户的请求被附加到我们未处理的儿童走私请求中</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es mp"><img src="../Images/b76c130ca94da86fe26a652853b54756.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9GOg3Eji0zUMKJgGSIjtLA.png"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx translated">未处理的请求被附加到另一个用户的请求上</figcaption></figure><ul class=""><li id="a83a" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated">后端服务器处理请求，它读取唯一有效的头内容长度。它的值是150，大于child-straighted请求的POST主体，因此它从另一个用户的请求中读取值。同样，它只会读取Content-Length中指定的字符数。但是这里最重要的一点是这些额外的字符被添加到“bio”参数中。</li><li id="4308" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">因为我们没有捕获队列，只发送了一个请求，所以响应实际上会发送给另一个用户，对吗？我们不在乎，为什么？这里真正的问题是，当应用程序代码在发送响应之前处理请求时，它会在我们的“bio”参数中附加来自另一个用户请求的额外字符。</li><li id="94c6" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">因此，如果我们转到我们的个人资料页面，现在我们将能够看到另一个用户的cookies参数请求。</li></ul><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ms"><img src="../Images/9faeec69e7f39aa240d01e8e2aadfc8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*1c-Xu4VYfyjV3NUdyTvyCQ.png"/></div><figcaption class="lb lc et er es ld le bd b be z dx translated">存储在我们简历中的另一个用户的请求</figcaption></figure><p id="2d63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请求存储的唯一缺点是，由于应用程序代码处理请求，它会区分以' &amp; '开头的参数，因此可能会删除请求中第一个' &amp; '后面的任何值。但除此之外我们都很好。</p><p id="6724" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就是这样！！！我建议你在此之后阅读詹姆斯·凯特尔的白皮书。</p><p id="f43d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">坦白地说，第二部分对我来说就像一个糟糕的蛇和梯子游戏:)每次我假设一个概念是正确的，我都在想我在游戏中接近100，但95年的蛇会把我放下，我会回到起点。我希望你喜欢阅读博客:)</p><p id="97f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">鼓掌，如果你喜欢的话。你知道你可以添加任意数量的掌声，对吗？日安！</p><p id="97e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">特别感谢我的朋友斯坦科·扬科维奇和普拉特克·库马尔·尼斯查尔帮助我理清了一些概念:)</p><p id="94f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">参考资料:</p><ul class=""><li id="ea4e" class="lf lg hi ih b ii ij im in iq lh iu li iy lj jc lk ll lm ln bi translated"><a class="ae jl" href="https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn" rel="noopener ugc nofollow" target="_blank">https://ports wigger . net/research/http-desync-attacks-request-走私-重生</a></li><li id="1dc4" class="lf lg hi ih b ii lo im lp iq lq iu lr iy ls jc lk ll lm ln bi translated">【https://portswigger.net/web-security/request-smuggling T4】</li></ul></div></div>    
</body>
</html>