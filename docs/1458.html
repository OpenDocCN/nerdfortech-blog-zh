<html>
<head>
<title>A Discussion on Circuit Breaks in the Microservices Architecture: Policy Manager Implementation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务架构中电路中断的讨论:策略管理器实现</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/a-discussion-on-circuit-breaks-in-the-microservices-architecture-policy-manager-implementation-8c66ab8ab058?source=collection_archive---------8-----------------------#2021-03-20">https://medium.com/nerd-for-tech/a-discussion-on-circuit-breaks-in-the-microservices-architecture-policy-manager-implementation-8c66ab8ab058?source=collection_archive---------8-----------------------#2021-03-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ab3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章是关于<strong class="ih hj">电路中断的系列文章的一部分，</strong>下面你可以找到所有这些问题的列表。</p><ul class=""><li id="4c9e" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><a class="ae jm" href="https://barrocaeric.medium.com/a-discussion-on-circuit-breaks-in-the-microservices-architecture-c0f45e6b37ca" rel="noopener">关于微服务架构中电路中断的讨论</a></li><li id="ac52" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated"><a class="ae jm" rel="noopener" href="/@barrocaeric/a-discussion-on-circuit-breaks-in-the-microservices-architecture-httpclient-implementation-9c7211c4758e">关于微服务架构中断路的讨论:HttpClient实现</a> <em class="js">。</em></li><li id="39aa" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated"><a class="ae jm" rel="noopener" href="/@barrocaeric/a-discussion-on-circuit-breaks-in-the-microservices-architecture-policy-manager-implementation-8c66ab8ab058">关于微服务架构中电路中断的讨论:策略管理器实施</a>。⬅ <em class="js">你在这里</em></li></ul><p id="bce0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之前，在<a class="ae jm" href="https://barrocaeric.medium.com/a-discussion-on-circuit-breaks-in-the-microservices-architecture-c0f45e6b37ca" rel="noopener">关于微服务架构</a>中的断路器的讨论中，我们简要地讨论了<em class="js">什么是<strong class="ih hj">断路器</strong>、<em class="js">它们如何工作以及<em class="js">为什么</em>它可以成为<strong class="ih hj">微服务架构</strong>中的一个好工具。</em></em></p><p id="fdec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下图显示了一个<strong class="ih hj">断路器状态机</strong>的概要，以供修改。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es jt"><img src="../Images/98f63273d065216dd018d5bad6e5034d.png" data-original-src="https://miro.medium.com/v2/resize:fit:48/0*FQoZwN2HbTsArm9g"/></div></figure><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es kb"><img src="../Images/d79bf19a8649b65c30c7854d9d73f740.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*4Udk-CaJzwhVOy556ZBefw.png"/></div><figcaption class="kc kd et er es ke kf bd b be z dx translated">断路器流程—改编自[1]</figcaption></figure><p id="a8df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还讨论了如何用一个<strong class="ih hj"> HttpClient </strong>来实现它。</p><p id="c455" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，在这最后一篇文章中，我们将讨论如何实现<strong class="ih hj">断路器</strong> <strong class="ih hj">，使用工厂来管理作为我们方法外壳的策略。</strong>完成实施后，我们将讨论该设计面临的挑战和优势。</p><ul class=""><li id="7ff4" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><em class="js">*对于本文任务，我使用</em> <a class="ae jm" href="https://dotnet.microsoft.com/download" rel="noopener ugc nofollow" target="_blank"> <em class="js">。net core </em> </a> <em class="js">和</em><a class="ae jm" href="https://www.nuget.org/packages/Polly/" rel="noopener ugc nofollow" target="_blank"><em class="js">Polly</em></a><em class="js">包。</em></li></ul><h1 id="4161" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">深入探究Polly政策和方法</h1><p id="8f0b" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">如前几篇文章所述，<strong class="ih hj"> Polly </strong>由<strong class="ih hj">策略对象</strong>组成，这些策略对象使我们能够在选择/期望的策略内执行我们的代码[2]。如果我们进一步抽象使用“信封”来执行一个动作的概念，我们会得出如下想法:</p><blockquote class="lj lk ll"><p id="b0a6" class="if ig js ih b ii ij ik il im in io ip lm ir is it ln iv iw ix lo iz ja jb jc hb bi translated"><em class="hi"/><strong class="ih hj">策略是将一个函数(我们的代码)的执行包装到另一个函数(策略)</strong>。”</p></blockquote><p id="303d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在许多语言(如javascript和C#)中，我们有被视为一等公民的函数(方法)。这意味着我们可以通过名字调用函数，也可以将它们存储在内存地址(变量)中。因此，使我们能够将一个函数作为参数传递给另一个函数。这是一个基本的<strong class="ih hj">函数式编程范例</strong>，称为<strong class="ih hj">函数组合。</strong></p><p id="5201" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="js">现在你说…“是啊…那又怎样？”</em></p><p id="45c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我们创建<strong class="ih hj">策略管理器实现</strong>的基本概念。使用这个概念，我们可以存储<strong class="ih hj">断路策略</strong>(在Polly情况下是对象)【4】并调用它们来使用组合函数概念执行我们的代码。</p></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><h1 id="b13f" class="kg kh hi bd ki kj lw kl km kn lx kp kq kr ly kt ku kv lz kx ky kz ma lb lc ld bi translated">策略管理器实现</h1><p id="dace" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">为本文设计的<strong class="ih hj">策略管理器</strong>如下所示，它是一个简化的<strong class="ih hj">抽象工厂</strong>，我们通过依赖注入将它注入到我们的服务类中(然而这只是一种方式)。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mb mc l"/></div><figcaption class="kc kd et er es ke kf bd b be z dx translated">策略管理器. cs</figcaption></figure><p id="8f67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的代码来看，最有趣的方法是<strong class="ih hj">CreateDefaultCircuitBreakPolicy</strong>。该方法创建了一个<strong class="ih hj">电路断开策略</strong>，在两次不成功的尝试(不成功是指异常)之后，它将电路断开一分钟。</p><p id="ede6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要使用这个工厂，应该调用<strong class="ih hj"> GetCircuitBreaker </strong>方法。这个函数接收一个名称，如果在我们的字典(在<em class="js">行19 </em>中定义)中没有找到，它允许我们的管理器创建一个<strong class="ih hj">断路策略</strong>并返回它，否则它返回存储在同一字典中的已经创建的策略。</p><p id="798e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的代码演示了如何使用策略管理器提供的<strong class="ih hj"> GetCircuitBreaker </strong>方法来封装给定的<strong class="ih hj">断路策略</strong>的函数。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mb mc l"/></div><figcaption class="kc kd et er es ke kf bd b be z dx translated">订单服务. cs</figcaption></figure><p id="82b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基本上，在<em class="js">行49 </em>上，我们调用我们的管理器来检索所需的<strong class="ih hj">断路策略</strong>(如果不存在，则创建该策略)。然后，利用手头的策略对象，我们调用一个执行方法(在本例中为<strong class="ih hj"> ExecuteAndCaptureAsync </strong>)并向其传递我们的函数，该函数将由策略包装执行(这里使用的是组合函数！).</p><p id="64ac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">概括地说，在这个设计中，当我们试图调用我们的管理器来按名称获取策略时，它会返回给我们现有的策略或新创建的策略。这很重要，因为我们的断路事件是由策略配置决定的。<strong class="ih hj">因此，如果我们想让它正常工作的话，我们应该为同一个块调用相同的策略</strong>。</p><p id="e374" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="js">* *不要忘记在Startup.cs文件中将PolicyManager注册为单一服务。只有正确注册了依赖注入容器，它才能找到我们的管理器，并将其注入到我们的服务中。</em></p><p id="3b17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">* *【https://github.com/ericbarroca/circuitbreak.】上可以找到本文的完整源代码: <a class="ae jm" href="https://github.com/ericbarroca/circuitbreak/tree/http-client-implementation" rel="noopener ugc nofollow" target="_blank"/></p><h1 id="4e27" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">实施的好处和挑战</h1><p id="fc85" class="pw-post-body-paragraph if ig hi ih b ii le ik il im lf io ip iq lg is it iu lh iw ix iy li ja jb jc hb bi translated">也许现在您已经感受到了这个实现带来的好处……(如果您阅读了上一篇文章中关于<a class="ae jm" rel="noopener" href="/@barrocaeric/a-discussion-on-circuit-breaks-in-the-microservices-architecture-httpclient-implementation-9c7211c4758e"> HttpClient实现的内容，那就更好了)。但是不用担心，我们现在将讨论这种实现的好处和挑战。从利益出发。</a></p><p id="0d8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，有了像组装的工厂/管理器那样简单的工厂/管理器，人们可以对他们拥有的任何功能使用策略，而不仅仅是对使用<strong class="ih hj"> HttpClient </strong>的请求。这意味着您可以使用任何协议包装数据库请求或对任何外部系统的任何调用。</p><p id="6255" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二，我们对策略和何时执行策略有更多的控制，我们可以将请求前所需的计算密集型代码块包装到策略中，从而为用户节省大量时间，例如，如果这个<strong class="ih hj">断路发生在</strong>处于打开状态。</p><p id="5ec1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，并非一切都是完美的，这个简单的实现确实给我们带来了一些挑战。开发人员需要记住策略名称，可能他们有时会混淆，调用错误的策略，或者最终为已经指定了策略的块创建新策略。幸运的是，这可以通过更复杂的实现来改进，或者使用<strong class="ih hj"> Polly </strong>框架上的<strong class="ih hj"> PolicyRegistry </strong>来实现更严格的场景(不幸的是，这超出了本文的范围)。</p><p id="cd15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们将结束这个关于电路中断的系列。希望你们喜欢，也希望不久能在新的话题上见到你们=)</p><h1 id="5c95" class="kg kh hi bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">参考</h1><ul class=""><li id="5bbe" class="jd je hi ih b ii le im lf iq md iu me iy mf jc ji jj jk jl bi translated">马丁·福勒。(2014年3月6日)。<a class="ae jm" href="https://martinfowler.com/bliki/CircuitBreaker.html" rel="noopener ugc nofollow" target="_blank">断路器</a>:【https://martinfowler.com/bliki/CircuitBreaker.html】T4</li><li id="4695" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">[2]波利。波利:<a class="ae jm" href="https://github.com/App-vNext/Polly" rel="noopener ugc nofollow" target="_blank">https://github.com/App-vNext/Polly</a></li><li id="a562" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">[3] <a class="ae jm" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">维基百科。函数式编程:https://en.wikipedia.org/wiki/Functional_programming</a></li><li id="386f" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated">[4] <a class="ae jm" href="https://github.com/App-vNext/Polly/wiki/Circuit-Breaker" rel="noopener ugc nofollow" target="_blank"> App vNext。断路器:https://github.com/App-vNext/Polly/wiki/Circuit-Breaker</a></li></ul></div></div>    
</body>
</html>