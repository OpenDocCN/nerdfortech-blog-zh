<html>
<head>
<title>How the shell it works?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">外壳是如何工作的？</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/ls-command-execution-in-our-own-shell-fe4672cc80eb?source=collection_archive---------18-----------------------#2021-04-12">https://medium.com/nerd-for-tech/ls-command-execution-in-our-own-shell-fe4672cc80eb?source=collection_archive---------18-----------------------#2021-04-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/09f68d675887bd09109337cfea0d04d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*oEdMX4Tjvf5uxNLDZ0CCGA.jpeg"/></div></figure><p id="3053" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">大事由小事组成。在这里，我将用非常简单的语言解释当我们键入“ls -l *时，shell会做什么。命令行中的c"。这有助于理解什么是命令行解释器(重视它),或者作为在C编程中编写自己的shell的资源。</p><h1 id="5369" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">贝壳</h1><p id="9319" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated"><strong class="io hj">第一步。</strong>每个<strong class="io hj">外壳都是一个bucle </strong>从屏幕上这样写的提示开始:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="44ba" class="kw jl hi ks b fi kx ky l kz la">$</span></pre><p id="0bf1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">或者:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="292d" class="kw jl hi ks b fi kx ky l kz la">username@hostname:~$</span></pre><p id="fb1e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">或者:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="8205" class="kw jl hi ks b fi kx ky l kz la">username@hostname /etc/mail&gt;</span></pre><p id="b7d4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">将要打印的提示保存在文件<strong class="io hj"> /etc/bashrc </strong>中设置的一个名为<strong class="io hj"> PS1 </strong>的变量中。</p><p id="d38e" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">有些人觉得很有创意，编辑了这个默认值来显示日期和时间、内核版本、你所在的完整路径，甚至可以用不同的颜色来显示！</p><p id="9abe" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">第二步。</strong>C函数<strong class="io hj"> getline </strong>从命令行中写入的输入中获取一行，并保存在字符数组中，我们这里称之为全字符串。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="a8ec" class="kw jl hi ks b fi kx ky l kz la">char *fullstring[] = {ls -l *.c};</span></pre><p id="9a38" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">第三步。</strong>分析字符串，判断数组是否为空，不做任何事情，再次显示提示，或者数组是否为<strong class="io hj"> EOF </strong>。当你在命令行中键入<strong class="io hj"> Ctrl +D </strong>时，它被解释为EOF，这意味着<strong class="io hj">E</strong>nd<strong class="io hj">O</strong>F<strong class="io hj">F</strong>文件。这是一个在“stdio.h”中声明的宏，意思是-1，如果找到EOF，shell必须退出。</p><p id="c8f9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">第四步。</strong>一个循环遍历整个字符串，寻找<strong class="io hj">扩展</strong> *。当它找到一个扩展时，它遍历下一个字符，直到它找到一个空格或一个新行。c "然后逐个比较工作目录中的文件名，将它们的名称保存在一个名为expansion的数组中，如下所示:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="80af" class="kw jl hi ks b fi kx ky l kz la">char *expansion = {file0.c file1.c file2.c}</span></pre><p id="df55" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">第五步。</strong>这个' *。c '在原始数组中被替换为所有以。在当前目录下，改变数组的原始大小。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="b455" class="kw jl hi ks b fi kx ky l kz la">char *fullstring[] = {ls -l file0.c file1.c file2.c};</span></pre><p id="f7bd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">步骤六。</strong>字符串由C函数<strong class="io hj"> strtok分析。</strong>每次在字符串中发现一个空格，它就把字符串分成一个新的部分。</p><p id="860a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">步骤7。</strong>所有的令牌都保存在一个指针数组中，如下所示:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="2c17" class="kw jl hi ks b fi kx ky l kz la">char *arrayofparts[] = {<br/>                  "ls",       -&gt;token0<br/>                  "-l",       -&gt;token1<br/>                  "file0.c",  -&gt;token2<br/>                  "file1.c",  -&gt;token3<br/>                  "file2.c",  -&gt;token4<br/>                  NULL        -&gt;token5<br/>};</span></pre><p id="1e5c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">步骤8。</strong>当我们有一个过于频繁使用的命令时(像gcc用所有的标志来编译漂亮的程序)，你可以声明一个别名来避免多次编写相同的长字符串。这是针对一个名为<strong class="io hj">别名</strong>的C函数，shell必须检查命令“ls”是否是别名。如果找到别名，它将被其所有内容替换。</p><p id="3c5f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">第九步。</strong>外壳有<strong class="io hj">内置功能</strong>，不依赖于你电脑或虚拟机上已经有的程序。所以，“ls”是和包含的内置比较的。如果发现一个内置函数，就直接执行它。</p><p id="8277" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">第十步。</strong>计算机或虚拟机中的可执行文件可以在非常不同的目录中找到。你的机器有一个名为<strong class="io hj"> PATH </strong>的<strong class="io hj">环境变量</strong>。它列出了所有这些地方。所以，需要在变量PATH包含的所有目录中搜索“ls”。您可以在您的机器中检查这些路径:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="2048" class="kw jl hi ks b fi kx ky l kz la">$ echo $PATH</span></pre><p id="4ce9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">或者</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="3a3b" class="kw jl hi ks b fi kx ky l kz la">$ env</span></pre><p id="b788" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">假设shell是用C编写的，它可以使用宏的声明来处理全局变量，如下所示:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="cb6b" class="kw jl hi ks b fi kx ky l kz la">extern char **environ;</span></pre><p id="0e4c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">或者它可以使用第三个主要原型:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="20b9" class="kw jl hi ks b fi kx ky l kz la">int main(int ac, char **av, char **env);</span></pre><p id="12b9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在任何情况下，所有的环境都被分割成行，以比较行的开头是否与" PATH= "相同。ls位于目录bin中，因此，它被更改为/bin/ls。</p><p id="fdc9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">步骤11。</strong>如果在这些目录中的任何一个中找到该程序，shell将使用<strong class="io hj"> fork </strong>系统调用创建一个<strong class="io hj">子函数</strong>，并使用系统调用wait等待<strong class="io hj">直到该子函数被完全执行。子进程使用<strong class="io hj"> execve </strong>来执行/bin/ls。Execve也需要环境变量。</strong></p><p id="a994" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">然后ls打印所有以结尾的文件的详细描述。c在当前目录中并返回零。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="a218" class="kw jl hi ks b fi kx ky l kz la">$ ls<br/>5_helper2.c  builtins_list.c  helpers_print.c       README.md  str_tok.c<br/>a.out        execute.c        helpers_string.c      shell.c    tokenize.c<br/>builtins.c   find_in_path.c   man_1_simple_shell.1  shell.h</span></pre><p id="4bb5" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">第十二步。</strong>命令ls的返回值打印在<strong class="io hj">标准误差</strong>中。如果ls成功结束，则标准误差显示为零。如果您键入以下内容，则可以显示该标准:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="2e74" class="kw jl hi ks b fi kx ky l kz la">$ echo $?</span></pre><p id="1cc2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">第十三步。</strong>再次显示提示。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="bb68" class="kw jl hi ks b fi kx ky l kz la">$ </span></pre><p id="16d4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">第14步。Getline等待来自命令行的新指令。</strong></p><h1 id="e6e3" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">我的团队</h1><figure class="kn ko kp kq fd ij er es paragraph-image"><div class="er es lb"><img src="../Images/dc773768df170c539a5053b606e97972.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*vT5Xlvhr-1kkPzU_UMNVUg.jpeg"/></div><figcaption class="lc ld et er es le lf bd b be z dx translated">霍尔伯顿学校</figcaption></figure><p id="cb7a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们自己的shell版本是由我在霍尔伯顿学校的团队创造的:</p><ul class=""><li id="e2b9" class="lh li hi io b ip iq it iu ix lj jb lk jf ll jj lm ln lo lp bi translated">Jerson Perez，全栈开发人员</li><li id="ca09" class="lh li hi io b ip lq it lr ix ls jb lt jf lu jj lm ln lo lp bi translated">Edher Ramirez，全栈开发人员</li><li id="02d1" class="lh li hi io b ip lq it lr ix ls jb lt jf lu jj lm ln lo lp bi translated">Natalia Vera，全栈开发人员</li></ul><p id="58bd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">它可以在我们的<a class="ae lg" href="https://github.com/Naveduran/simple_shell" rel="noopener ugc nofollow" target="_blank"> git库</a>中找到。让我们知道你的问题和意见！</p><h1 id="792c" class="jk jl hi bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">关于我</strong></h1><p id="6fad" class="pw-post-body-paragraph im in hi io b ip ki ir is it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj hb bi translated">我是一名来自霍尔伯顿学校的充满激情的软件开发人员，也是一名来自国立大学的心理学家。在我的一生中，我一直在发展有价值的专业技能，成为一个好的倾听者、批判性思考者和团队成员。我被认为是一个非常聪明和有同情心的人。无论是在工作还是学术生活中，我都想创造有意义的经历，并激励我的伴侣。我一直很专注，也很好奇。</p><p id="9837" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果你想和我建立联系，请在GitHub或T2 Twitter上关注我。</p><p id="b335" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我希望你喜欢这次阅读，感谢你的关注。</p><p id="d8c2" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">娜塔莉亚·维拉·杜兰制作。</p></div></div>    
</body>
</html>