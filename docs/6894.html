<html>
<head>
<title>Talk about Go: Network programming — TCP Communication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谈谈 Go:网络编程— TCP 通信</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/talk-about-go-network-programming-tcp-communication-e579fe789626?source=collection_archive---------1-----------------------#2022-06-10">https://medium.com/nerd-for-tech/talk-about-go-network-programming-tcp-communication-e579fe789626?source=collection_archive---------1-----------------------#2022-06-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c100" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在网络分层的七层协议中，我们知道 TCP 在 HTTP 层的下面。本质上，HTTP 数据包主体解析是基于底层 TCP 连接建立的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/62192102b2ee7f2a3e813a77e33e20a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kLDEIUOkdMvbZJFd"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">照片由<a class="ae jt" href="https://unsplash.com/@yoannboyer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">约恩·博耶</a>在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="1da8" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">TCP 协议摘要</h1><p id="a6ac" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated"><strong class="ih hj"> TCP 连接 Distinct </strong>:计算机之间网络连接的建立，也称为握手，本质上是两个文件句柄的关联，即 fd，每个网络连接由四个属性唯一标识:<code class="du kx ky kz la b">&lt;source IP, source port, destination IP, destination port &gt;</code>，所以一台机器的连接数受文件句柄<code class="du kx ky kz la b">ulimit</code>的限制。<br/> <strong class="ih hj"> OS 套接字</strong>:操作系统套接字作为端点，用于在服务器端和客户端程序之间建立双向网络通信链接。</p><h1 id="1cab" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">不同情况下保持活动的说明</h1><ul class=""><li id="6f1d" class="lb lc hi ih b ii ks im kt iq ld iu le iy lf jc lg lh li lj bi translated"><strong class="ih hj">HTTP keepalive:</strong>T15】众所周知，HTTP 连接是无状态的。通常情况下，连接用完就被破坏了。开启 keepalive 可以告诉它保持一段时间的连接，避免频繁的连接重建。</li><li id="c397" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated"><strong class="ih hj"> TCP keepalive: </strong></li></ul><blockquote class="lp"><p id="3bb4" class="lq lr hi bd ls lt lu lv lw lx ly jc dx translated">许多现有的 TCP 协议通过定义某种心跳机制来支持这种错误处理方式，该机制要求每个端点定期发送 PING/PONG 探测，以便检测网络问题以及服务健康状况。</p></blockquote><h1 id="0f16" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf lz kh ki kj ma kl km kn mb kp kq kr bi translated">Linux 网络参数</h1><p id="7afc" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在 Linux 机器上，可以通过以下网络参数设置 TCP keepalive 机制:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="b333" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以上是默认设置，这意味着<strong class="ih hj">初始连接创建将在两小时后每 75 秒重新发送一次(7200 秒)。如果连续 9 次没有收到 ACK 响应，则连接被标记为断开。</strong></p></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><h1 id="b994" class="ju jv hi bd jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr bi translated">代码演示</h1><p id="5e7b" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在 Go native net 包中，可以使用 TCP 连接的保活机制设置以下功能:</p><ul class=""><li id="3123" class="lb lc hi ih b ii ij im in iq mq iu mr iy ms jc lg lh li lj bi translated"><code class="du kx ky kz la b">func (c *TCPConn) SetKeepAlive(keepalive bool) error</code> <br/>是否启用连接检测</li><li id="b381" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated"><code class="du kx ky kz la b">func (c *TCPConn) SetKeepAlivePeriod(d time.Duration) error</code> <br/>连接检测间隔，默认情况下会使用操作系统参数设置</li></ul><p id="b991" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来我们先用一个 TCP 连接演示来交互，然后下次用连接池来集中管理 TCP 连接。</p><p id="c088" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">传输结构</strong> <br/>我们为客户端和服务器端的交互定义了两种结构，传输协议由<strong class="ih hj"> json </strong>演示</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="08a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">服务器端</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="71e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">客户端</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="0055" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">定义连接的选项</strong></p><pre class="je jf jg jh fd mt la mu mv aw mw bi"><span id="9e59" class="mx jv hi la b fi my mz l na nb">type Option struct {<br/>	addr        string<br/>	size        int<br/>	readTimeout time.Duration<br/>	dialTimeout time.Duration<br/>	keepAlive   time.Duration<br/>}</span></pre><p id="3450" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后创建如下连接代码:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="6b13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">异步接收结果</strong><br/><code class="du kx ky kz la b">receiveResp()</code>函数主要执行异步轮询，有几个函数:</p><ul class=""><li id="a0c0" class="lb lc hi ih b ii ij im in iq mq iu mr iy ms jc lg lh li lj bi translated">意识到上下文关闭，通常会执行连接的 cancel()</li><li id="3a72" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">从服务器接收数据并写入结果通道<code class="du kx ky kz la b">retChan</code>，其类型是并发安全的<code class="du kx ky kz la b">sync.Map</code></li><li id="e829" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc lg lh li lj bi translated">监听服务器错误并关闭异常连接</li></ul><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="mc md l"/></div></figure><p id="18b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">发送请求</strong></p><pre class="je jf jg jh fd mt la mu mv aw mw bi"><span id="b7c2" class="mx jv hi la b fi my mz l na nb">func (c *Conn) Send(ctx context.Context, msg *body.Message) (ch chan string, err error) {<br/>	ch = make(chan string)<br/>	c.retChan.Store(msg.Uid, ch)<br/>	js, _ := json.Marshal(msg)</span><span id="bd90" class="mx jv hi la b fi nc mz l na nb">	_, err = c.writer.Write(js)<br/>	if err != nil {<br/>		return<br/>	}</span><span id="cda3" class="mx jv hi la b fi nc mz l na nb">	err = c.writer.Flush()<br/>	// the connection is not closed, could be put into the connection pool later<br/>	//c.tcp.CloseWrite()<br/>	return<br/>}</span></pre><h1 id="6143" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">跑步步骤</h1><ol class=""><li id="1ebe" class="lb lc hi ih b ii ks im kt iq ld iu le iy lf jc nd lh li lj bi translated">开始服务器端监听:</li></ol><pre class="je jf jg jh fd mt la mu mv aw mw bi"><span id="6470" class="mx jv hi la b fi my mz l na nb">=== RUN   TestListenAndServer<br/>2021/05/10 16:58:20 Start server...</span></pre><p id="4bef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.提出请求:</p><pre class="je jf jg jh fd mt la mu mv aw mw bi"><span id="7ab0" class="mx jv hi la b fi my mz l na nb">var OPT = &amp;Option{<br/>	addr:        "0.0.0.0:3000",<br/>	size:        3,<br/>	readTimeout: 3 * time.Second,<br/>	dialTimeout: 3 * time.Second,<br/>	keepAlive:   1 * time.Second,<br/>}</span><span id="8562" class="mx jv hi la b fi nc mz l na nb">func createConn(opt *Option) *Conn {<br/>	c, err := NewConn(opt)<br/>	if err != nil {<br/>		panic(err)<br/>	}<br/>	return c<br/>}</span><span id="e27c" class="mx jv hi la b fi nc mz l na nb">func TestSendMsg(t *testing.T) {<br/>	c := createConn(OPT)<br/>	msg := &amp;body.Message{Uid: "pixel-1", Val: "pixelpig!"}<br/>	rec, err := c.Send(context.Background(), msg)<br/>	if err != nil {<br/>		t.Error(err)<br/>	} else {<br/>		t.Logf("rec1: %+v", &lt;-rec)<br/>	}</span><span id="e497" class="mx jv hi la b fi nc mz l na nb">	msg.Val = "another pig!"<br/>	rec2, err := c.Send(context.Background(), msg)<br/>	if err != nil {<br/>		t.Error(err)<br/>	} else {<br/>		t.Logf("rec2: %+v", &lt;-rec2)<br/>	}<br/>	t.Log("finished")<br/>}</span></pre><p id="2e3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.客户端输出:</p><pre class="je jf jg jh fd mt la mu mv aw mw bi"><span id="ab7e" class="mx jv hi la b fi my mz l na nb">=== RUN   TestSendMsg<br/>    TestSendMsg: conn_test.go:56: rec1: : pixelpig!<br/>    TestSendMsg: conn_test.go:64: rec2: : another pig!<br/>    TestSendMsg: conn_test.go:66: finished<br/>--- PASS: TestSendMsg (9.94s)<br/>PASS</span></pre></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><h1 id="e101" class="ju jv hi bd jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr bi translated">超时和池化</h1><p id="dad5" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">以上是比较简单的点对点交互。实际上，连接交互超时也可以在后面考虑:</p><ol class=""><li id="1eea" class="lb lc hi ih b ii ij im in iq mq iu mr iy ms jc nd lh li lj bi translated">虽然连接结果是异步响应，但我们有必要让响应超时，以防止单个连接继续阻塞。</li><li id="9585" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc nd lh li lj bi translated">我们需要考虑重用，即将健康的连接放入连接池中进行管理。</li></ol><p id="19b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">超时判断</strong> <br/>判断超时的方法有很多种，比较常见的是用一个<code class="du kx ky kz la b">select{}</code>挡和<code class="du kx ky kz la b">time.After()</code>。让我们来看看常见的实现:</p><pre class="je jf jg jh fd mt la mu mv aw mw bi"><span id="2367" class="mx jv hi la b fi my mz l na nb">rec3, err := c.Send(context.Background(), msg)<br/>if err == nil {<br/>	select {<br/>	case resp := &lt;-rec3:<br/>		t.Logf("rec3: %+v", resp)<br/>		return<br/>	case &lt;-time.After(time.Second * 1):<br/>		t.Error("Wait for resp timeout!")<br/>		return<br/>	}<br/>} else {<br/>	t.Error(err)<br/>}</span></pre><p id="32f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">例如:</strong></p><pre class="je jf jg jh fd mt la mu mv aw mw bi"><span id="362d" class="mx jv hi la b fi my mz l na nb">=== RUN   TestSendMsg<br/>    TestSendMsg: conn_test.go:56: rec1: : pixelpig!<br/>    TestSendMsg: conn_test.go:76: Wait for resp timeout!<br/>--- FAIL: TestSendMsg (17.99s)<br/>FAIL</span></pre><p id="158f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">池管理</strong> <br/>这里要考虑的情况稍微复杂一点。你可以先列出困难，然后一个一个地打破它们:</p><ol class=""><li id="3b70" class="lb lc hi ih b ii ij im in iq mq iu mr iy ms jc nd lh li lj bi translated">池中的最大连接数</li><li id="239a" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc nd lh li lj bi translated">更新空闲连接数</li><li id="affc" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc nd lh li lj bi translated">连接获取和返回</li><li id="0891" class="lb lc hi ih b ii lk im ll iq lm iu ln iy lo jc nd lh li lj bi translated">连接关闭</li></ol><p id="a4a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">连接池操作的长度可能比较长，详细解释在本系列的下一部分有所描述:<a class="ae jt" rel="noopener" href="/@pixelpig/talk-about-go-network-programming-tcp-connection-management-f7630a526e17"> <strong class="ih hj">说说 Go: TCP 连接池管理</strong> </a></p><h1 id="4cc0" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">参考链接</h1><p id="5fd8" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated"><strong class="ih hj">关于 TCP keepalive 在 Go 中的注意事项</strong><br/><a class="ae jt" href="https://thenotexpert.com/golang-tcp-keepalive/" rel="noopener ugc nofollow" target="_blank">https://thenotexpert.com/golang-tcp-keepalive/</a><br/><strong class="ih hj">在 Linux 下使用 TCP Keepalive</strong><br/><a class="ae jt" href="https://tldp.org/HOWTO/TCP-Keepalive-HOWTO/usingkeepalive.html" rel="noopener ugc nofollow" target="_blank">https://tldp . org/how to/TCP-Keepalive-how to/Using Keepalive . html</a></p></div></div>    
</body>
</html>