<html>
<head>
<title>Unraveling the Mystery of the Multi-tasking Single Thread</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解开多任务单线程之谜</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/unraveling-the-mystery-of-the-multi-tasking-single-thread-21e0cd98103b?source=collection_archive---------21-----------------------#2021-05-28">https://medium.com/nerd-for-tech/unraveling-the-mystery-of-the-multi-tasking-single-thread-21e0cd98103b?source=collection_archive---------21-----------------------#2021-05-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ddd6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">【JavaScript如何模仿并发并做出承诺</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/5d89e5486986b6389d647fbe6933dd0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cw7VzWcgBwW33JAZOKwiBg.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">这些功能都去哪里了？</figcaption></figure><p id="7c18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在训练营中期，我们被介绍给了<code class="du ju jv jw jx b"><a class="ae jy" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch" rel="noopener ugc nofollow" target="_blank">fetch()</a></code>，我们的第一个异步方法。我知道它涉及到一个叫做<code class="du ju jv jw jx b"><a class="ae jy" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">Promise</a></code>的东西，一个处理承诺返回的<code class="du ju jv jw jx b"><a class="ae jy" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" rel="noopener ugc nofollow" target="_blank">then()</a></code>链，这都是为了在网络请求需要一段时间的情况下允许其他JavaScript代码运行。如果没有这个特性，堆栈可能会被“阻塞”,等待一个更长的过程完成，同时用户将无法与网站进行交互。当时，学习从API获取JSON数据的一般模式就足够了。当我接近bootcamp最后几周的尾声时，我尝试了一个基于用户交互的项目，到处都是异步代码，我发现自己需要理解JavaScript调用栈是如何越来越满的。那么像JS这样的单线程语言是如何设法模拟并发处理的呢？</p><h2 id="fb27" class="jz ka hi bd kb kc kd ke kf kg kh ki kj iq kk kl km iu kn ko kp iy kq kr ks kt bi translated">一个堆栈，配有专职人员</h2><p id="3573" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">JavaScript实际上运行在一个单一的真理调用栈上，这使得它是单线程的。但是幕后的帮手多了很多！异步函数会将代码发送到其他地方，在调用堆栈之外单独处理，并最终放入单独的队列中。一个<a class="ae jy" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" rel="noopener ugc nofollow" target="_blank">事件循环</a>将等待调用栈清空，然后从队列中取出一个带有关联函数(即回调函数)的“消息”并将其放在调用栈中，然后运行。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kz"><img src="../Images/dc9e514c6fba0c4a60a9aafc39bf5c18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*b6jEsTafpMef-mEr"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">照片由<a class="ae jy" href="https://unsplash.com/@picoftasty?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">梅穆</a>在<a class="ae jy" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="498d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我描述一个完全可能的场景(无论如何是一个梦)。想象一下和你妈妈一起吃早餐时有一大盘煎饼。你喜欢煎饼，所以这很棒。她把一个放在你的盘子里，你的工作就是吃掉它。太好了！但是你的妈妈更了解你，当你吃完煎饼后，她会立即在你的盘子里放另一个煎饼，甚至可能会越积越多。在这一切当中，你看着路对面的华夫饼干烤模，说“嗯，我也想要一个华夫饼干”。噗，一个令人欣慰的童年形象出现了，也许是帕特里克·斯图尔特，他说“我会做到的”，然后开始做华夫饼。在那次令人困惑的事件之后，你的母亲继续内疚地让你吃剩下的煎饼。吃所有这些东西需要一些时间，即使是在梦里，华夫饼干已经做好了。然而，在薄煎饼之间夹华夫饼是不允许的，所以P-Stew把它交给莱瓦尔·伯顿，他一直拿着华夫饼干，直到你吃完你的大堆薄煎饼，这时他可以自由地把华夫饼干放到你的盘子里。</p><p id="66e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个场景中，吃掉所有的食物(主要是煎饼)是一个需要完成的大函数执行上下文，你的盘子是调用堆栈，做华夫饼是异步函数，你吃华夫饼是回调函数，帕特里克·斯图尔特是API，莱瓦尔·伯顿是事件循环。</p><p id="170a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我把它弄得更混乱了，让我们来看看它的零件！</p><p id="0c2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">调用栈</em>是JS解释器(比如你的浏览器)在编译阶段跟踪它必须运行的多个函数以及运行顺序的方式。JS调用堆栈是后进先出(LIFO)的，这意味着您必须自上而下地工作。</p><p id="e29c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">(旁注:但是函数不是以先进先出的模式按照代码中的顺序调用的吗？不要将这个堆栈与按顺序编译代码行相混淆。堆栈包含函数被调用<em class="jd">时创建的函数<em class="jd">执行上下文</em>。如果您想到一个函数<em class="jd"> </em>有许多其他嵌套的内部函数，您可以想象在您继续处理外部函数直到到达全局上下文之前，内部函数需要被解析。所以不用担心，栈没有倒！)</em></p><p id="1576" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Alexander Zlatkov撰写的这篇<a class="ae jy" href="https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5" rel="noopener ugc nofollow" target="_blank">博客文章</a>更好地说明了并发模型是如何工作的:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es la"><img src="../Images/2218eb7a1e5b3cad1f51736501cc0fc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*__wPgGBodnci5NWcaa_Aqw.gif"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">动画来自<a class="ae jy" rel="noopener" href="/@zlatkov"> Alexander Zlatkov </a>的“【JavaScript如何工作:事件循环和异步编程的兴起+ 5种更好的异步/等待编码方法</figcaption></figure><p id="9302" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当调用堆栈中轮到一个异步函数时，它仍然被立即处理(并及时离开调用堆栈)，但它实际上是由另一个API处理的，该API将相应地返回一个回调以在队列中等待。就调用堆栈而言，它已经完成，并为下一个函数做好了准备。</p><h2 id="571e" class="jz ka hi bd kb kc kd ke kf kg kh ki kj iq kk kl km iu kn ko kp iy kq kr ks kt bi translated">注意你的承诺和队列</h2><p id="e37c" class="pw-post-body-paragraph if ig hi ih b ii ku ik il im kv io ip iq kw is it iu kx iw ix iy ky ja jb jc hb bi translated">自从引入标准化承诺和async/await函数构造以来，这个单一队列不再是故事的全部。</p><p id="a1a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">像<code class="du ju jv jw jx b">setTimeout</code>或<code class="du ju jv jw jx b">setInterval</code>这样的普通老式异步函数将在浏览器或节点API中处理(它实际上不是JS函数！)发送一个回调函数到上面解释的通用gist/mega breakfast类比中解释的队列，在处理之前等待调用栈清空。即使您将延迟指定为零毫秒，也会发生这种情况。一旦它是异步的，其他一切都优先:</p><pre class="jf jg jh ji fd lb jx lc ld aw le bi"><span id="3907" class="jz ka hi jx b fi lf lg l lh li">setTimeout(() =&gt; console.log("bye!"), 0) <br/>console.log("hi")<br/>console.log("how are you?")<br/>console.log("well, I gotta get going.")</span><span id="06b7" class="jz ka hi jx b fi lj lg l lh li">/* <br/>console output:</span><span id="bc98" class="jz ka hi jx b fi lj lg l lh li">hi<br/>how are you?<br/>well, I gotta get going.<br/>bye! <br/>*/</span></pre><p id="75e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您在浏览器控制台中运行上面的代码，您会看到即使延迟被设置为零，<code class="du ju jv jw jx b">setTimeout</code>中的回调函数也会在所有其他同步代码之后运行。</p><p id="01b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从ES6开始，JS还利用了promises使用的单独的<strong class="ih hj"> <em class="jd">作业队列</em> </strong>。一旦返回承诺的函数(比如<code class="du ju jv jw jx b">fetch</code>)被解析，它们就会被快速跟踪到同步代码中的下一个可用槽。因此，实际上有两个单独的队列在等待调用堆栈过山车，常规队列和快速传递作业队列。这些优先级队列成员也可以用<code class="du ju jv jw jx b">then()</code>方法来表示，比如我们熟悉的<code class="du ju jv jw jx b">fetch('someUrl').then(response =&gt; response.json()).then(data =&gt; handleData(data))</code>模式。<code class="du ju jv jw jx b">then()</code>返回一个<code class="du ju jv jw jx b">Promise</code>，接受两个参数:一个是承诺成功时的回调函数，一个是失败时的回调函数。<code class="du ju jv jw jx b"><a class="ae jy" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises" rel="noopener ugc nofollow" target="_blank">Promise</a></code>对象表示异步操作的最终结果(无论成功与否)。它有三种状态:待定、已完成或已拒绝。承诺的创建要么内置于函数中(如<code class="du ju jv jw jx b">fetch()</code>或<code class="du ju jv jw jx b">then()</code>)，要么你可以用<a class="ae jy" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise" rel="noopener ugc nofollow" target="_blank">承诺构造器</a>显式创建承诺。</p><p id="cc7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用<a class="ae jy" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Async_await" rel="noopener ugc nofollow" target="_blank"> async/await语法</a>也将创造承诺。这是创造的句法糖。一般来说，将<code class="du ju jv jw jx b">async</code>放在函数声明之前会使其异步并返回一个<code class="du ju jv jw jx b">Promise</code>。就是这样！在async函数中，你也可以使用<code class="du ju jv jw jx b">await</code>作为<code class="du ju jv jw jx b">then()</code>，因为它创建了另一个暂停点来等待右边的代码解析，然后再移动到下一个。</p><pre class="jf jg jh ji fd lb jx lc ld aw le bi"><span id="394b" class="jz ka hi jx b fi lf lg l lh li">async function interruption(){<br/>   const message = await "INTERRUPTING".concat(" STARFISH")<br/>   console.log(message)<br/>}</span><span id="58e2" class="jz ka hi jx b fi lj lg l lh li">setTimeout(() =&gt; console.log("bye!"), 0)<br/>interruption()<br/>console.log("hi")<br/>console.log("how are you?")<br/>console.log("well, I gotta get going.")</span><span id="7b89" class="jz ka hi jx b fi lj lg l lh li">/* <br/>console output:</span><span id="fde0" class="jz ka hi jx b fi lj lg l lh li">hi<br/>how are you?<br/>well, I gotta get going.<br/>INTERRUPTING STARFISH<br/>bye!<br/>*/</span></pre><p id="306d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的代码片段示例中，您可以看到，尽管第一个异步函数<code class="du ju jv jw jx b">setTimeout</code>在第二个<code class="du ju jv jw jx b">interruption</code>函数之前被调用，但是由于<code class="du ju jv jw jx b">interruption</code>使用了利用承诺，所以它被放在作业队列中并发出“bye！”从<code class="du ju jv jw jx b">setTimeout</code>开始。</p><p id="6813" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢阅读这篇关于异步函数和JS如何设法看起来像多线程的快速文章！让我知道如果任何术语是关闭或你有其他意见。</p><p id="1506" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我试着在每个帖子里都放一只猫，所以:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lk"><img src="../Images/4fe529ca040beef85965adb93b422a69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PcZGkmfb87tpae5trua8qg.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">金枪鱼的承诺，现状:未实现</figcaption></figure></div><div class="ab cl ll lm gp ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="hb hc hd he hf"><p id="abd2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您仍然有问题(您应该有)，以下是一些很好的参考资料:</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ls lt l"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">说真的，这个视频对我帮助很大。这很有趣。</figcaption></figure><div class="lu lv ez fb lw lx"><a rel="noopener follow" target="_blank" href="/dailyjs/asynchronous-adventures-in-javascript-promises-1e0da27a3b4"><div class="ly ab dw"><div class="lz ab ma cl cj mb"><h2 class="bd hj fi z dy mc ea eb md ed ef hh bi translated">JavaScript中的异步冒险:承诺</h2><div class="me l"><h3 class="bd b fi z dy mc ea eb md ed ef dx translated">为什么承诺？</h3></div><div class="mf l"><p class="bd b fp z dy mc ea eb md ed ef dx translated">medium.com</p></div></div><div class="mg l"><div class="mh l mi mj mk mg ml jo lx"/></div></div></a></div><div class="lu lv ez fb lw lx"><a href="https://codeburst.io/javascript-engines-how-do-they-even-work-from-call-stack-to-promise-dcfce39f0c38" rel="noopener follow" target="_blank"><div class="ly ab dw"><div class="lz ab ma cl cj mb"><h2 class="bd hj fi z dy mc ea eb md ed ef hh bi translated">JavaScript引擎:它们是如何工作的？从调用堆栈到承诺</h2><div class="me l"><h3 class="bd b fi z dy mc ea eb md ed ef dx translated">JavaScript引擎的旋风之旅，从调用堆栈、全局内存、事件循环、回调队列到承诺和…</h3></div><div class="mf l"><p class="bd b fp z dy mc ea eb md ed ef dx translated">codeburst.io</p></div></div><div class="mg l"><div class="mm l mi mj mk mg ml jo lx"/></div></div></a></div></div></div>    
</body>
</html>