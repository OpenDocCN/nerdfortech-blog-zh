<html>
<head>
<title>Dynamic Parallelism in AWS Step Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">AWS阶跃函数中的动态并行性</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/dynamic-parallelism-in-aws-step-functions-530f434dd933?source=collection_archive---------2-----------------------#2021-03-09">https://medium.com/nerd-for-tech/dynamic-parallelism-in-aws-step-functions-530f434dd933?source=collection_archive---------2-----------------------#2021-03-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="07d0" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">使用<a class="ae ix" href="https://www.serverless.com/" rel="noopener ugc nofollow" target="_blank">无服务器</a>框架的示例</h2></div><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es iy"><img src="../Images/6e63a3b40fe020a143dedbd9df58417a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FYUq-PkSdxwCaeTTqXKFlQ.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated"><a class="ae ix" href="https://www.freepik.com/vectors/business" rel="noopener ugc nofollow" target="_blank">vector juice创建的业务向量</a>——<a class="ae ix" href="http://www.freepik.com" rel="noopener ugc nofollow" target="_blank">www.freepik.com</a></figcaption></figure><p id="9060" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><a class="ae ix" href="https://aws.amazon.com/step-functions/" rel="noopener ugc nofollow" target="_blank">“步骤功能”</a>是AWS提供的无服务器编排服务。它可用于定义和管理工作流。AWS步骤功能可用于各种其他AWS服务，如AWS Lambda、AWS Batch和AWS ECS。步骤功能支持顺序、并行和混合工作流。在本文中，我将介绍阶跃函数中的<em class="kk">【动态并行】</em>。</p><p id="eeee" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在动态并行特性出现之前，AWS Step函数只有类似“静态并行工作流”的功能，开发人员必须为每个并行分支指定定义。这种静态并行函数在阶跃函数工作流定义中定义为<code class="du kl km kn ko b">"Type":"Parallel"</code>。在阶跃函数定义中，这些定义的分支如下所示。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es kp"><img src="../Images/544cfba95fcd379c5406e014b59a3d3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*6J3gr6w3p9M85McRy4y9bA.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">来源:<a class="ae ix" href="https://docs.aws.amazon.com/step-functions/latest/dg/amazon-states-language-parallel-state.html" rel="noopener ugc nofollow" target="_blank">https://docs . AWS . Amazon . com/step-functions/latest/DG/Amazon-States-language-parallel-state . html</a></figcaption></figure><p id="0391" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">使用动态并行，您可以开发类似于并行循环的东西。每个并行迭代将完成相同的任务，但根据输入集的不同而略有不同。这样的迭代器在阶跃函数定义中定义为<code class="du kl km kn ko b">"Type":"Map"</code>。这个实现看起来像这样。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es kq"><img src="../Images/d2f41b08840f15b23184e13f85c061e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*p2g1co0hnpbbdjwzAA5MFg.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">“ProcessTaskStep”将在每次迭代中并行执行。</figcaption></figure><p id="9ae7" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在本文中，我使用Lambda函数和阶跃函数定义来演示这个特性。我们的状态机的最终工作流将如下所示。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div class="er es kr"><img src="../Images/19c29e94d80886186b1f85dc6daad368.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*gH1lFSVleblc7LFMnLwy5w.png"/></div></figure><p id="3d61" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这个工作流中，<code class="du kl km kn ko b">FindTasksStep</code>生成一个任务列表。之后，对列表中的每个元素并行执行迭代。在每次迭代中，相应的元素在<code class="du kl km kn ko b">ProcessTasksStep</code>中被处理并保存到S3桶中。完成所有迭代后，结果值被收集在<code class="du kl km kn ko b">SummaryTasksStep</code>中，一个汇总文件也被写入同一个S3桶。</p><figure class="iz ja jb jc fd jd"><div class="bz dy l di"><div class="ks kt l"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">无服务器. yml模板</figcaption></figure><blockquote class="ku kv kw"><p id="fa23" class="jo jp kk jq b jr js ij jt ju jv im jw kx jy jz ka ky kc kd ke kz kg kh ki kj hb bi translated">这是用于此工作流的无服务器框架的模板。<strong class="jq hj">注意</strong>您可以重用<code class="du kl km kn ko b">definition</code>属性下的所有内容(即从第43行到第83行)以及AWS CloudFormation模板。</p></blockquote><p id="5f8e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">定义中最重要的部分是<code class="du kl km kn ko b">ProcessTasksMappedTask</code>。步骤的类型是<code class="du kl km kn ko b">Map</code>,这意味着它是一个映射任务。应该定义<code class="du kl km kn ko b">InputPath</code>和<code class="du kl km kn ko b">ItemsPath</code>来告诉Map任务在哪里寻找并行迭代的输入列表。为此，在前面的步骤中，<code class="du kl km kn ko b">FindTasksStep</code>应该返回一个兼容的数据对象。在该步骤的lambda处理程序中，我在Lambda回调中返回了这样一个数据对象。</p><figure class="iz ja jb jc fd jd"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="d607" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">使用这个返回的对象，可以在<code class="du kl km kn ko b">event-&gt; body-&gt; taskList</code>路径中找到任务列表。这是在中定义的路径</p><pre class="iz ja jb jc fd la ko lb lc aw ld bi"><span id="9e5a" class="le lf hi ko b fi lg lh l li lj">InputPath: "$.body"            <br/>ItemsPath: "$.taskList"</span></pre><p id="6c97" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">阶跃函数定义中的一部分。</p><p id="ca9c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">列表中每个对象的数据都可以通过<code class="du kl km kn ko b">ProcessTaskStep</code>的Lambda处理程序中的<code class="du kl km kn ko b">event</code>参数来访问。处理完每个对象后，可以在<code class="du kl km kn ko b">event-&gt;results</code>对象中访问结果列表。这在中有详细说明</p><pre class="iz ja jb jc fd la ko lb lc aw ld bi"><span id="94cc" class="le lf hi ko b fi lg lh l li lj">ResultPath: "$.results"</span></pre><p id="e7c6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在<code class="du kl km kn ko b">ProcessMappedTask</code>定义中。</p><p id="93b2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">然后这个结果列表在<code class="du kl km kn ko b">SummaryTaskStep</code>的Lambda处理程序中作为<code class="du kl km kn ko b">event.results</code>被访问。</p><blockquote class="ku kv kw"><p id="e50d" class="jo jp kk jq b jr js ij jt ju jv im jw kx jy jz ka ky kc kd ke kz kg kh ki kj hb bi translated">注意，在部署这段代码之前，您需要有一个专用的S3存储桶来存储这个步骤函数的结果。</p></blockquote><p id="23f1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">部署后，我们可以开始执行并观察结果。成功执行后，将在指定的S3存储桶中以下列方式创建文件。</p><figure class="iz ja jb jc fd jd er es paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="er es lk"><img src="../Images/05f08c23e8c15bb1861af408e11a3cf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I4VwmKz6Wa3oYKuuCyHsPA.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">状态机执行一次后创建的文件</figcaption></figure><p id="656e" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">你也可以定义<code class="du kl km kn ko b">MaxConcurrency</code>属性来定义最大并行执行限制。</p><p id="1030" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">完整的源代码可从<a class="ae ix" href="https://github.com/budvinchathura/serverless-aws-dynamic-parallelism" rel="noopener ugc nofollow" target="_blank">https://github . com/budvinchathura/server less-AWS-dynamic-parallelism</a>获得。</p><p id="8bae" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这个例子中，我只使用了带有阶跃函数的AWS Lambda函数。您还可以使用AWS Batch和AWS ECS来创建更复杂的混合工作流。你可以在<a class="ae ix" href="https://www.serverless.com/blog/deploy-hybrid-serverless-cluster-workflows" rel="noopener ugc nofollow" target="_blank">https://www . server less . com/blog/deploy-hybrid-server less-cluster-workflows</a>中找到这样的教程。</p><p id="e675" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">有关动态并行特性的更多解释，请访问AWS的这篇博客文章。</p></div></div>    
</body>
</html>