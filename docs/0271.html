<html>
<head>
<title>Look Beyond One-Hot encoding</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">超越一次性编码</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/look-beyond-one-hot-encoding-f4b264c6a83?source=collection_archive---------1-----------------------#2020-08-30">https://medium.com/nerd-for-tech/look-beyond-one-hot-encoding-f4b264c6a83?source=collection_archive---------1-----------------------#2020-08-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/08b8ed480335ad614dd6de48c48488eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ju9phSZ3IZQCUv3XYn6bBw.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图像源取消飞溅</figcaption></figure><div class=""/><p id="c71f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一键编码将分类列分解为虚拟变量，用1和0表示虚拟变量(新特性)在记录中是否重要。如果我们有少于3-4个类别或值的特性，这似乎没问题。但是当我们有更多的类别时，它开始成为一个棘手的问题。</p><p id="6324" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">对具有大量不同值的列进行热编码会增加维数灾难。假设我们有一个在windows机器上安装了防病毒软件的列。这是一个有100个独特项目的分类特征。当我们试图发现这些反病毒产品将如何影响系统中恶意软件存在的检测时，如果我们进行一次性编码，它将简单地在数据集中添加100列，几乎所有单元都为零。在每一行中，我们将有一个值为1的单元格，其余所有单元格的值都为0。类似地，我们将在AV列中有很多不太常见的零。这基本上创建了一个有很多零的稀疏数据集。</p><p id="7d04" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">此外，我们也开始看到这些维度之间的关系。如果我们知道哪个维度的值为1，我们就可以计算出其他维度的值。这是因为我们知道我们默认安装了一个AV，所以其他维度将为零。维度之间存在相关性。</p><p id="c97e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这些额外的维度会增加数据对象内存占用的压力。假设您在一台内存为12GB的机器上加载一个大小为4GB的数据集，一旦您开始对一个包含1000个分类值的列进行一键编码，您的系统就会耗尽内存。</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es js"><img src="../Images/d63b5e64740622d7ab70e948e64ed03e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QH_ekfxe50icNxlQYqcOlQ.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图像源取消飞溅</figcaption></figure><p id="bf7e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">解决这个问题的一种方法是将编码限制在最常见的前<strong class="iw hy"> <em class="jx"> N </em> </strong>类。但是也有其他的选择。让我们探索这些选择。</p><h2 id="8af8" class="jy jz hx bd ka kb kc kd ke kf kg kh ki jf kj kk kl jj km kn ko jn kp kq kr ks bi translated">受监督:</h2><blockquote class="kt ku kv"><p id="5629" class="iu iv jx iw b ix iy iz ja jb jc jd je kw jg jh ji kx jk jl jm ky jo jp jq jr hb bi translated"><strong class="iw hy">目标编码</strong> —特征值替换为各个类别的目标值的平均值</p><p id="3d7f" class="iu iv jx iw b ix iy iz ja jb jc jd je kw jg jh ji kx jk jl jm ky jo jp jq jr hb bi translated"><strong class="iw hy"> LeaveOneOut编码</strong> —类似于target，但它不容易出现异常值，因为它在计算Target均值时忽略了当前记录</p><p id="0515" class="iu iv jx iw b ix iy iz ja jb jc jd je kw jg jh ji kx jk jl jm ky jo jp jq jr hb bi translated"><strong class="iw hy">证据权重</strong> —用比值比对数替换的值。</p></blockquote><figure class="jt ju jv jw fd hk er es paragraph-image"><div class="er es kz"><img src="../Images/a27a53bbf7108a01076061dee00e9f7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*HH2R_sCAwzRk8nVbayNp9g.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">LeaveOneOut编码器的实现</figcaption></figure><h2 id="f4a9" class="jy jz hx bd ka kb kc kd ke kf kg kh ki jf kj kk kl jj km kn ko jn kp kq kr ks bi translated">无人监督的</h2><blockquote class="kt ku kv"><p id="be60" class="iu iv jx iw b ix iy iz ja jb jc jd je kw jg jh ji kx jk jl jm ky jo jp jq jr hb bi translated"><strong class="iw hy">二进制</strong> —做序数编码，把整数转换成二进制代码，把数字拆分成单独的列。列的数量比一位热码编码中的少。</p><p id="4c68" class="iu iv jx iw b ix iy iz ja jb jc jd je kw jg jh ji kx jk jl jm ky jo jp jq jr hb bi translated"><strong class="iw hy">计数/频率</strong> —用该类别的计数替换类别值</p><p id="b257" class="iu iv jx iw b ix iy iz ja jb jc jd je kw jg jh ji kx jk jl jm ky jo jp jq jr hb bi translated"><strong class="iw hy">哈希编码</strong> —类似OneHot但固定维度更少。使用哈希方法(来自hashlib)生成新的n维</p></blockquote><p id="01e3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我不记得在哪里看到过类似的东西，但这很有帮助。</p><figure class="jt ju jv jw fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es la"><img src="../Images/1412a24972e00866120b56330cea2dcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oQMcZAW-0d4nrJSvkD0vJw.png"/></div></div></figure><p id="16a5" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae lb" href="https://github.com/scikit-learn-contrib/category_encoders" rel="noopener ugc nofollow" target="_blank"> category_encoder </a>包包含其他编码器，如CatBoost、M-estimator、Contrast(和/赫尔默特/多项式/后向差分)。阅读它们，了解哪一个适合你的要求。</p></div></div>    
</body>
</html>