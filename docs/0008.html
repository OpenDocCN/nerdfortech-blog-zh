<html>
<head>
<title>Demystifying IBM Streams</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开IBM流的神秘面纱</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/demystifying-ibm-streams-cb2db8615871?source=collection_archive---------3-----------------------#2018-09-03">https://medium.com/nerd-for-tech/demystifying-ibm-streams-cb2db8615871?source=collection_archive---------3-----------------------#2018-09-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="507e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个博客的目的是帮助你建立一个如何在IBM streams中开发SPL程序的框架。在这个博客中，你将了解到—</p><ul class=""><li id="850e" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><em class="jm">数据流和对实时决策系统的需求。</em></li><li id="fefd" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated"><em class="jm"> IBM Streams及其工具包。</em></li><li id="d063" class="jd je hi ih b ii jn im jo iq jp iu jq iy jr jc ji jj jk jl bi translated"><em class="jm">一些SPL电码。</em></li></ul><p id="4106" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们深入了解IBM流的海洋。</p><p id="8593" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">50米亚特兰蒂斯1号潜艇— <strong class="ih hj">流分析</strong></p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es js"><img src="../Images/323589803f24cea7257b4ee0bf70d43b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/0*8jg8aTAxV68Y6u7O.gif"/></div></div></figure><p id="5b5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">流分析(也称为流处理)是一种动态处理大量数据(<strong class="ih hj">流</strong>)的方法。这些数据流是一个超长数据序列的不间断流动。流分析的强大之处在于，它允许每秒数百万个事件的流，并使我们有权构建推荐实时决策的应用程序。</p><p id="de9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">流数据可能包括电子商务购买生成的日志文件、游戏中的玩家活动、来自社交网络的信息、金融股票市场，甚至来自设备的网络日志。</p><blockquote class="ke"><p id="9206" class="kf kg hi bd kh ki kj kk kl km kn jc dx translated">到2021年，全球IP流量将达到每年3.3兆字节(ZB)——思科</p></blockquote><p id="3e7e" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">随着硬件越来越便宜，设备越来越智能，发送和接收的数据量急剧增长。面对不断变化的不断增长的数据量，当今的公司面临的挑战是做出<strong class="ih hj">明智的</strong>、<strong class="ih hj">实时</strong>业务决策，并且在不需要在Hadoop系统中缓存数据的情况下保持竞争优势。</p></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><p id="f2d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jm">300米水肺潜水员</em> <strong class="ih hj"> —什么是IBM Streams？</strong></p><p id="9bd7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">IBM Streams(<strong class="ih hj">IBM info sphere Streams</strong>)是一个专有工具，它有一个开发平台和运行时环境，使企业能够开发和执行接收、过滤和分析大量数据流的应用程序。</p><p id="7fb5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它使用其独特的<strong class="ih hj">流处理语言(SPL) </strong>，并且可以用<strong class="ih hj"> C、C++或Java </strong>应用程序进行扩展，以重用现有的逻辑。它由基于Eclipse的IDE、应用程序图和运行时监控组成，以简化构建和管理应用程序的过程。</p><p id="9dc0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是最简单的可能；我们最喜欢的<strong class="ih hj"> Hello World </strong>应用程序—</p><pre class="jt ju jv jw fd la lb lc ld aw le bi"><span id="ef89" class="lf lg hi lb b fi lh li l lj lk">namespace sample;</span><span id="b783" class="lf lg hi lb b fi ll li l lj lk">composite HelloWorld {<br/>    graph <br/>        stream  Hello = Beacon() {<br/>            param <br/>                iterations: 5u; <br/>            output <br/>                Hello: message = "Hello World!"; <br/>        } <br/>        <br/>        () as Sink = Custom(Hello) { <br/>            logic <br/>                onTuple Hello: <br/>                    printStringLn(message); <br/>        }<br/>}</span></pre><p id="431d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，它使用一个<strong class="ih hj">信标</strong>操作符来生成携带“Hello World”消息的元组。自定义接收操作器从信标接收元组，并在控制台上显示5次。</p><p id="adff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很少外卖—</p><p id="03e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">流是元组的序列，元组是属性的集合。(例如。rstring消息)。流可以是无限的元组序列，例如来自网络传感器的流。</p><p id="b702" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运算符是流处理应用程序的基本构件。它们处理来自输入流的元组，并产生输出流。运算符以下列逻辑模式之一处理输入流。</p><p id="7c18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当每个元组被接收时以及作为一个窗口。</p><p id="c26a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它还处理来自输入流的元组数据，并以输出流的形式生成结果。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es lm"><img src="../Images/c8f89bf4e1b30bdcf684d99e08e456b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kLhN3U9IczCm_qRx.png"/></div></div></figure><p id="9c0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个spl代码编译成功后，一个<strong class="ih hj">。生成sab </strong>文件。streams application bundle (sab)文件是一个单独的、可重定位的文件，其中包含运行应用程序所需的所有工件。当这被提交用于执行时，应用捆绑文件然后被分解成运行时应用。</p></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><p id="23e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1000米巨型太平洋章鱼— <strong class="ih hj">使用匹配文件类型的模式计算指定目录下所有文件的行数。</strong></p><pre class="jt ju jv jw fd la lb lc ld aw le bi"><span id="e217" class="lf lg hi lb b fi lh li l lj lk">use com.ibm.streams.teda.internal::DirScan;</span><span id="c7ca" class="lf lg hi lb b fi ll li l lj lk">composite LineCounter {<br/>    type<br/>    LineCountType = rstring fileName, int32 lineCount;<br/>    graph<br/>        (stream &lt; rstring fileName &gt; MyFileName) = DirectoryScan() {<br/>            param<br/>            directory: getSubmissionTimeValue("Dir");<br/>            ignoreDotFiles: true;<br/>            sleepTime: 10.0;<br/>            pattern: ".*\\.*"; //This takes a regex <br/>        }</span><span id="fdd4" class="lf lg hi lb b fi ll li l lj lk">(stream &lt; rstring line, rstring fileName &gt; Line) = FileSource(MyFileName) {<br/>        param<br/>        format: line;</span><span id="99ac" class="lf lg hi lb b fi ll li l lj lk">output<br/>        Line: fileName = FileName();<br/>    }</span><span id="cd35" class="lf lg hi lb b fi ll li l lj lk">(stream &lt; LineCountType &gt; LineCount) = Custom(Line) {<br/>        logic<br/>        state: {<br/>            mutable int32 _lineCnt = 0;<br/>            mutable rstring _fileName = "";<br/>        }</span><span id="1ce7" class="lf lg hi lb b fi ll li l lj lk">onTuple Line: {<br/>            _lineCnt++;<br/>            _fileName = Line.fileName;<br/>        }</span><span id="6fc3" class="lf lg hi lb b fi ll li l lj lk">onPunct Line: {<br/>            if (currentPunct() == Sys.WindowMarker) {<br/>                mutable LineCountType oTuple = {};<br/>                oTuple.fileName = _fileName;<br/>                oTuple.lineCount = _lineCnt;<br/>                submit(oTuple, LineCount);<br/>                _lineCnt = 0;<br/>                _fileName = "";<br/>            }<br/>        }<br/>    }</span><span id="08de" class="lf lg hi lb b fi ll li l lj lk">stream &lt; LineCountType &gt; outputStream = Throttle(LineCount) {<br/>        param<br/>        rate: 2.0;<br/>    }</span><span id="e740" class="lf lg hi lb b fi ll li l lj lk">() as FileSink_4 = FileSink(outputStream) {<br/>        param<br/>        file: "/dev/stdout";<br/>        flush: 1 u;<br/>    }<br/>}</span></pre><p id="fec5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这使用了一个<strong class="ih hj">节流</strong>算子，它以2秒的间隔输出结果流。通常，该运算符用于根据需要调整水流速度，使其以指定的速率流动。</p></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><p id="ff36" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3800米泰坦尼克号沉船—</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es ln"><img src="../Images/27d9185dc4406c4d419ba561bd95361a.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*AP2mXRfncr0nJRrvXjD3Pg.png"/></div></figure><p id="8ba8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">网络工具包中的<strong class="ih hj"> PacketLiveSource </strong>操作符具有每秒近<strong class="ih hj"> 1M数据包</strong>的性能，并且<strong class="ih hj"> DNSMessageParser </strong>可以作为独立操作符在每个内核上每秒解析<strong class="ih hj"> 600K数据包</strong>。</p><p id="9b71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个IBM流有多么大的马力简直是疯了。</p></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><p id="ecdc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">6000米米尔DSV — <strong class="ih hj">网络工具包</strong></p><p id="d86d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该工具包允许我们分析底层网络数据包，如解析<strong class="ih hj"> DHCP、DNS、Netflow、</strong>使用地理空间数据丰富IPV4和IPV6地址。</p><pre class="jt ju jv jw fd la lb lc ld aw le bi"><span id="4755" class="lf lg hi lb b fi lh li l lj lk">stream &lt; PacketType &gt; PacketLiveStream as PacketsOut = PacketLiveSource() {<br/>    param<br/>        networkInterface: $networkInterface;<br/>        promiscuous: true;<br/>    output<br/>        PacketsOut: captureTime = (float64) CAPTURE_SECONDS() + (float64) CAPTURE_MICROSECONDS() / 1000000.0, ipSourceAddress = convertIPV4AddressNumericToString(IPV4_SRC_ADDRESS()), ipDestinationAddress = convertIPV4AddressNumericToString(IPV4_DST_ADDRESS()), dnsMessage = PAYLOAD_DATA();<br/>}</span></pre><p id="ab35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">PacketLiveSource operator能够从以太网接口捕获实时网络数据包。</p><pre class="jt ju jv jw fd la lb lc ld aw le bi"><span id="44c4" class="lf lg hi lb b fi lh li l lj lk">stream&lt;DNSMessageType&gt; DNSMessageStream as Out = DNSMessageParser(PacketLiveStream){<br/>    logic<br/>        state : {<br/>            map&lt;uint16, rstring&gt; dnsTypes = { 1 : "A", 2 : "NS", 3 : "MD", 4 : "MF", 5 : "CNAME", 6 : "SOA", 7 : "MB", 8 : "MG", 9 : "MR", 10 : "NULL", 11 : "WKS", 12 : "PTR", 13 : "HINFO", 14 : "MINFO", 15 : "MX", 16 : "TXT", 28 : "AAAA" } ;<br/>            map&lt;uint8, rstring&gt; dnsResponseCodes = { 0 : "OK", 1 : "Format Error", 2 : "Server Failure", 3 : "Name Error", 4 : "[not implemented]", 5 : "Server Refused" } ;<br/>        }</span><span id="5c91" class="lf lg hi lb b fi ll li l lj lk">    param<br/>        messageAttribute : dnsMessage ;<br/>    output<br/>        Out : captureTime = formatEpochTime(captureTime), isResponse = DNS_RESPONSE_FLAG(), responseCode = DNS_RESPONSE_CODE()in dnsResponseCodes ? dnsResponseCodes [ DNS_RESPONSE_CODE()] :(rstring)DNS_RESPONSE_CODE(), questionName = DNS_QUESTION_NAME(), questionType = DNS_QUESTION_TYPE()in dnsTypes ? dnsTypes [ DNS_QUESTION_TYPE()] :(rstring)DNS_QUESTION_TYPE(), answerNames = DNS_ANSWER_NAMES(), answerTTLs = DNS_ANSWER_TTLS(), answerData = DNS_ANSWER_DATA(), nameserverNames = DNS_NAMESERVER_NAMES();<br/>}</span></pre><p id="04bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此运算符解析输入元组中接收的各个DNS消息字段，并发出包含DNS消息数据的元组。然后，用户可以使用DNS解析器结果函数来进一步处理有效负载数据。</p></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><p id="d208" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">7700米深水鱼— <strong class="ih hj">自定义操作员</strong></p><p id="a161" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">自定义操作符是一个特殊的逻辑相关操作符，它可以接收和发送任意数量的流，本身不做任何事情。因此，它提供了一个用于定制的白板。让我们看看如何根据值对地图进行排序。</p><pre class="jt ju jv jw fd la lb lc ld aw le bi"><span id="034b" class="lf lg hi lb b fi lh li l lj lk">()as CustomSort = Custom(outputStream){<br/>    logic<br/>        state:{<br/>            mutable map&lt;rstring,int32&gt; keyValueMap = {"e":10,"b":-24,"c":50,"a":-32,"d":230};<br/>            mutable list&lt;int32&gt; valueList;<br/>            mutable list&lt;rstring&gt; keyList = keys(keyValueMap);<br/>            mutable int32 i = 0;<br/>            mutable int32 j = 0;<br/>            mutable int32 currentCount;<br/>            mutable rstring currentKey;<br/>        }</span><span id="5c51" class="lf lg hi lb b fi ll li l lj lk">    onTuple outputStream :{<br/>        mutable rstring tempKey;<br/>        while(i &lt; size(keyList)){<br/>            tempKey = keyList[ i ];<br/>            appendM(valueList, keyValueMap[ tempKey ]) ;<br/>            i++;<br/>        }<br/>        i=1;<br/>        while (i &lt; size(valueList)){<br/>            currentCount = valueList[ i ];<br/>            currentKey = keyList[ i ];<br/>            j = i-1;<br/>            while (j &gt;= 0 &amp;&amp; valueList[ j ] &lt; currentCount){<br/>                valueList[ j+1 ] = valueList[ j ];<br/>                keyList[ j+1 ] = keyList[ j ];<br/>                j = j-1;<br/>            }<br/>            valueList[ j+1 ] = currentCount;<br/>            keyList[ j+1 ] = currentKey;<br/>            i ++;<br/>            printStringLn("Sorted Values-&gt;"+ (rstring)valueList) ;<br/>            printStringLn("Sorted Key-&gt;"+(rstring)keyList) ;<br/>        }<br/>        shutdownPE();<br/>    }<br/>}</span></pre><p id="fd5e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">shutdownPE() —关闭处理元素(PE)。这将停止当前的PE。什么是体育？当您编译流处理应用程序时，构成数据流图的操作符和流关系被分解成一组单独的执行单元，称为PEs。</p></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><p id="ab3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这不是我们深潜的结束。这片海洋提供了更多。前往水下最深处的旅程仍在继续。我希望在我的下一篇文章之前发现一些丢失的海盗宝藏，但是你继续流！</p><p id="eff0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jm">本博客原帖</em> <a class="ae lo" href="https://kuharanbhowmik.wordpress.com/2018/09/04/demystifying-ibm-streams/" rel="noopener ugc nofollow" target="_blank"> <em class="jm">此处</em> </a> <em class="jm">。</em></p></div></div>    
</body>
</html>