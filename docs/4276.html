<html>
<head>
<title>Implement Service Locator design pattern with get_it — Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用 get_it — Flutter 实现服务定位器设计模式</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/implement-service-locator-design-pattern-with-get-it-flutter-5e50671bbbcb?source=collection_archive---------0-----------------------#2021-07-14">https://medium.com/nerd-for-tech/implement-service-locator-design-pattern-with-get-it-flutter-5e50671bbbcb?source=collection_archive---------0-----------------------#2021-07-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="0a5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将看到如何在 flutter 中使用 get_it 包实现服务定位器设计模式。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/98461a40cf6aa11ea9cb6f69714a65a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1YELyT2GMkFHv5eeywReMQ.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">马库斯·斯皮斯克在<a class="ae jt" href="https://unsplash.com/s/photos/dependency-injection?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="30bd" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">服务定位器设计模式</h1><p id="8cbf" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在服务定位器设计模式中，我们维护一个中央注册中心，当服务消费者或服务客户请求服务时，它提供服务的实例。它与依赖注入非常相似，但它们并不相同。</p><p id="c324" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你不懂设计模式，相信看完这篇文章你就懂了。</p><h1 id="2893" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">为什么我们需要这些？</h1><p id="336b" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我们不做新的东西，除非我们以前做的方式有错误。让我们来看看为什么我们要选择像服务定位器或依赖注入这样的设计模式。</p><p id="6ae9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从一个例子开始，</p><p id="3469" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们想为我们的应用程序创建一个定制的记录器，让我们为它创建一个接口。</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="bde6" class="lc jv hi ky b fi ld le l lf lg">abstract class Logger{<br/>  void log(String msg);<br/>}</span></pre><p id="2b50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我们想要创建两个实现，一个简单的控制台记录器和一个文件记录器。</p><ul class=""><li id="1885" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">控制台日志</li></ul><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lq lr l"/></div></figure><ul class=""><li id="b97b" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">文件记录器</li></ul><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="0d22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你想在你的 flutter 应用中使用它，你会怎么做？</p><ol class=""><li id="0538" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc ls ln lo lp bi translated">创建所需记录器的实例。</li><li id="ada6" class="lh li hi ih b ii lt im lu iq lv iu lw iy lx jc ls ln lo lp bi translated">只需将要记录的消息传递给 log()函数。</li></ol><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="8883" class="lc jv hi ky b fi ld le l lf lg">void main(){<br/>  Logger myLogger = ConsoleLogger();<br/>  //Logger myLogger = FileLogger();<br/>  myLogger.log('file accessed');<br/>}</span></pre><p id="f798" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">方法有什么问题？</p><ul class=""><li id="014c" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">调用方法/类，在本例中是 main()，必须创建 Logger 类的实例，这是不好的。如果您想在多个类中拥有实例，该怎么办？你必须自己到处实例化这个方法。</li><li id="641c" class="lh li hi ih b ii lt im lu iq lv iu lw iy lx jc lm ln lo lp bi translated">你可能会说，好吧，我将声明它为单例。问题解决了！不，这还不够！因为很难对单例进行单元测试，很多时候你都不想要单例。</li></ul><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lq lr l"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">我们不可能模仿 ConsoleLogger 类。</figcaption></figure><ul class=""><li id="796a" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">您可以通过继承的小部件或使用提供者来提供对象，但这会变得非常麻烦，而且如果不传递 buildContext，您就无法访问 UI 外部的对象。</li></ul><p id="4402" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以我们如何克服下面的问题，</p><ol class=""><li id="2213" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc ls ln lo lp bi translated">对客户端类隐藏实例创建。</li><li id="d0bd" class="lh li hi ih b ii lt im lu iq lv iu lw iy lx jc ls ln lo lp bi translated">使单元测试变得容易。</li><li id="6786" class="lh li hi ih b ii lt im lu iq lv iu lw iy lx jc ls ln lo lp bi translated">避免像 provider 或 Redux 那样用特殊的小部件来访问数据，使 UI 树变得杂乱。</li></ol><p id="41e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">我们可以使用 get_it 包</strong></p></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><h2 id="2794" class="lc jv hi bd jw mf mg mh ka mi mj mk ke iq ml mm ki iu mn mo km iy mp mq kq mr bi translated">get_it 包</h2><p id="1244" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">将 get_it 添加到您的 pubspec.yaml 文件中，</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="b82b" class="lc jv hi ky b fi ld le l lf lg">dependencies:<br/>  <strong class="ky hj">get_it: ^7.1.4</strong></span></pre><p id="7d9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我之前提到的</p><p id="e7f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在服务定位器设计模式中，我们维护一个<strong class="ih hj">中央注册中心</strong>，它提供不同接口的实现。它非常类似于依赖注入，但它们并不相同。</p><p id="01af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将在一个方法下注册所有实例，并在调用 runApp()之前从 main()调用实例，以确保在应用程序启动之前注册每个实例，</p><p id="999d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">定位器.镖</strong></p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="824b" class="lc jv hi ky b fi ld le l lf lg">import 'package:get_it/get_it.dart';</span><span id="bb5c" class="lc jv hi ky b fi ms le l lf lg"><strong class="ky hj">final serviceLocator = GetIt.instance</strong>; // GetIt.I is also valid<br/>void <strong class="ky hj">setUp()</strong>{<br/> serviceLocator.registerLazySingleton&lt;Logger&gt;(<br/>               () =&gt; ConsoleLogger());<br/> serviceLocator.registerSingleton&lt;Model&gt;(()=&gt; MyModel());<br/> // register more instances<br/>}</span></pre><p id="efe4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们正在全局声明 serviceLocator 实例，以便我们可以在应用程序中的任何地方访问它。这里的<strong class="ih hj">中央注册中心是 GetIt.instance，</strong>，它保存所有注册的实例。</p><p id="5f28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">setUp()(或者您选择的任何名称)方法是我们注册所有实例的地方。</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="3a35" class="lc jv hi ky b fi ld le l lf lg">void main(){<br/>     <strong class="ky hj">setUp();</strong> //call this method before runApp()<br/>     runApp(MyApp());<br/>}</span></pre><p id="f5bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要获得注册的实例，请使用 get <t>()方法</t></p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="35b2" class="lc jv hi ky b fi ld le l lf lg">Logger logger = serviceLocator.<strong class="ky hj">get&lt;Logger&gt;()</strong>;   </span></pre><p id="dcde" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">get_it 提供了各种注册实例的方法。我们一个一个来看。</p><h2 id="b784" class="lc jv hi bd jw mf mg mh ka mi mj mk ke iq ml mm ki iu mn mo km iy mp mq kq mr bi translated">不同的注册方式</h2><h2 id="0c37" class="lc jv hi bd jw mf mg mh ka mi mj mk ke iq ml mm ki iu mn mo km iy mp mq kq mr bi translated">1.registerSingleton(T 实例)</h2><p id="670d" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我们使用这个方法注册一个单例实例(创建一个实例，每当我们调用 get <t>())时，返回同一个实例)。</t></p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="f906" class="lc jv hi ky b fi ld le l lf lg">serviceLocator.<strong class="ky hj">registerSingleton</strong>&lt;Model&gt;(MyModel());</span></pre><h2 id="ee05" class="lc jv hi bd jw mf mg mh ka mi mj mk ke iq ml mm ki iu mn mo km iy mp mq kq mr bi translated">2 . registerlazysingleton(factory func<t>factory func)</t></h2><p id="0359" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">该方法也用于注册单例实例，但它是延迟注册的，对象仅在第一次调用 get <t>()时实例化，而 registerSingleton 方法在调用 setUp()方法时实例化实例，并使实例随时可用。</t></p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="dbc6" class="lc jv hi ky b fi ld le l lf lg">serviceLocator.<strong class="ky hj">registerLazySingleton</strong>&lt;Model&gt;(()=&gt;MyModel());</span></pre><h2 id="e4c4" class="lc jv hi bd jw mf mg mh ka mi mj mk ke iq ml mm ki iu mn mo km iy mp mq kq mr bi translated">3 .注册工厂(FactoryFunc <t> factoryFunc)</t></h2><p id="f87e" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我们使用这个方法在每次调用 get &lt; T &gt;()时返回 T 类型的新实例</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="4246" class="lc jv hi ky b fi ld le l lf lg">serviceLocator.<strong class="ky hj">registerFactory</strong>&lt;Model&gt;(()=&gt;MyModel());</span></pre><p id="e2ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请记住，您不能使用 registerFactory()动态地将任何参数传递给构造函数。</p><p id="1f04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设您的 MyModel()类有一个参数，</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="25a9" class="lc jv hi ky b fi ld le l lf lg">class MyModel{<br/>     String name;<br/>     MyModel(this.name);<br/>}</span></pre><p id="b118" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如何在 get_it 中注册这个实例？</p><h2 id="213a" class="lc jv hi bd jw mf mg mh ka mi mj mk ke iq ml mm ki iu mn mo km iy mp mq kq mr bi translated">4 . registerFactoryParam(factory func<t factoryfunc=""/></h2><p id="0957" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">Using this method we can instantiate instances that take at most 2 parameters in their constructor.</p><p id="2966" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Consider this model class,</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="112e" class="lc jv hi ky b fi ld le l lf lg">class Person{<br/>     String name;<br/>     int age;<br/>     <strong class="ky hj">MyModel(this.name,this.age);</strong><br/>}</span></pre><p id="8953" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">You can register an instance of Person class using,</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="b2c1" class="lc jv hi ky b fi ld le l lf lg">serviceLocator<br/>  .<strong class="ky hj">registerFactoryParam&lt;Person,String,int&gt;</strong><br/>   ((name, age) =&gt; Person(name,age));</span></pre><blockquote class="mw mx my"><p id="bf41" class="if ig mz ih b ii ij ik il im in io ip na ir is it nb iv iw ix nc iz ja jb jc hb bi translated"><strong class="ih hj">registerFactoryParam&lt;Type，Param1，param 2&gt;T13】</strong></p><p id="4c12" class="if ig mz ih b ii ij ik il im in io ip na ir is it nb iv iw ix nc iz ja jb jc hb bi translated">Type:要注册的类的类型</p><p id="41c3" class="if ig mz ih b ii ij ik il im in io ip na ir is it nb iv iw ix nc iz ja jb jc hb bi translated">Param1:第一个参数的类型</p><p id="5e48" class="if ig mz ih b ii ij ik il im in io ip na ir is it nb iv iw ix nc iz ja jb jc hb bi translated">Param2:第二个参数的类型</p></blockquote><p id="0ae4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要获取实例，</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="e45c" class="lc jv hi ky b fi ld le l lf lg">var logger = serviceLocator.get&lt;Person&gt;<strong class="ky hj">(param1:'user',param2: 20)</strong>;</span></pre><p id="fe53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果只需要一个实例，将<strong class="ih hj"> void </strong>设置为第二个参数</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="cbc8" class="lc jv hi ky b fi ld le l lf lg">serviceLocator<br/>  .registerFactoryParam&lt;MyModel,String,void&gt;<br/>   ((name, _) =&gt; MyModel(name,20));</span></pre><p id="6298" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么不需要传递 param2，</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="7e07" class="lc jv hi ky b fi ld le l lf lg">var logger = serviceLocator.get&lt;Person&gt;<strong class="ky hj">(param1:'user')</strong>;</span></pre><h2 id="0002" class="lc jv hi bd jw mf mg mh ka mi mj mk ke iq ml mm ki iu mn mo km iy mp mq kq mr bi translated">5.registerFactoryAsync(FactoryFuncAsync<t>func)</t></h2><p id="2440" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">有时我们需要异步实例化一个对象，我们可以用这种方法注册这些类型的对象。</p><p id="f5a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">考虑一个例子，</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="6320" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，最近的事件只能异步创建。我们可以使用</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="651e" class="lc jv hi ky b fi ld le l lf lg">serviceLocator.<strong class="ky hj">registerFactoryAsync</strong>&lt;Event&gt;(<br/>               () =&gt; <strong class="ky hj">Event.<em class="mz">createRecentEvent</em>()</strong>);</span></pre><p id="05d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了得到那个实例，我们必须使用<strong class="ih hj"> getAsync &lt; T &gt;()，</strong>它将返回 Future &lt; T &gt;</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="63a5" class="lc jv hi ky b fi ld le l lf lg">void main() async{<br/>    Event event = await serviceLocator.<strong class="ky hj">getAsync&lt;Event&gt;()</strong>;<br/>    //...<br/>} </span></pre><p id="95a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们对以上指定的所有方法都有异步支持，比如</p><ul class=""><li id="ca7f" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated"><strong class="ih hj">registerSingletonAsync()</strong></li><li id="14ae" class="lh li hi ih b ii lt im lu iq lv iu lw iy lx jc lm ln lo lp bi translated"><strong class="ih hj">registerLazySingletonAsync()</strong></li><li id="026d" class="lh li hi ih b ii lt im lu iq lv iu lw iy lx jc lm ln lo lp bi translated"><strong class="ih hj">registerfactoryparamsync()</strong></li></ul><p id="37d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更多信息，请查看 get_it 的<a class="ae jt" href="https://pub.dev/packages/get_it" rel="noopener ugc nofollow" target="_blank">正式文档</a></p></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><h2 id="9f34" class="lc jv hi bd jw mf mg mh ka mi mj mk ke iq ml mm ki iu mn mo km iy mp mq kq mr bi translated">使用名称注册</h2><p id="401c" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">如果你想注册同类型的两个实例，我们可以这样做吗？</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lq lr l"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">没有意义的代码😵</figcaption></figure><p id="303b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不，我们不能，它会抛出一个错误，因为默认情况下 get_it 只允许类型注册一次。您可以通过设置来更改它</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="0f4a" class="lc jv hi ky b fi ld le l lf lg">void setUp(){<br/><strong class="ky hj">     serviceLocator.allowReassignment=true;<br/></strong>     //registrations<br/>}</span></pre><p id="218a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是当你调用<strong class="ih hj">get&lt;WebService&gt;()</strong>时，你会得到最后注册的 web service。那么我们如何拥有同一个类的两个实例并在我们的代码中使用它们呢？</p><h2 id="592e" class="lc jv hi bd jw mf mg mh ka mi mj mk ke iq ml mm ki iu mn mo km iy mp mq kq mr bi translated"><strong class="ak">实例名参数</strong></h2><p id="b8a1" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">instanceName 是一个关键字参数，我们可以在注册实例时将它传递给任何注册方法。如果我们使用 instanceName，我们的实例用名称<strong class="ih hj">和类型</strong>注册。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="b4e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以通过，</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="96d9" class="lc jv hi ky b fi ld le l lf lg">var webserive = serviceLocator<br/>                 .get&lt;MyWebService&gt;(<strong class="ky hj">instanceName: 'v2'</strong>); <br/>                 // get the second registred webservice</span></pre><blockquote class="mw mx my"><p id="5fd6" class="if ig mz ih b ii ij ik il im in io ip na ir is it nb iv iw ix nc iz ja jb jc hb bi translated">所有<strong class="ih hj">相同类型的注册实例必须有唯一的实例名</strong>。</p></blockquote><p id="1c1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="64d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了获得实例，</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="5369" class="lc jv hi ky b fi ld le l lf lg">var webserive = serviceLocator<br/>                 .get&lt;MyWebService&gt;<strong class="ky hj">(instanceName: 'v2')</strong>; <br/>                 //will return the second registred MyWebService<br/>var db = serviceLocator<br/>                 .get&lt;MyDatabase&gt;<strong class="ky hj">(instanceName: 'v2')</strong>;<br/>                 //will return the second registred MyDatabase</span></pre><p id="1b90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以用 get_it 做的事情还有很多，官方文档什么都有涵盖，你可以在这里<a class="ae jt" href="https://pub.dev/packages/get_it" rel="noopener ugc nofollow" target="_blank">看一下</a>。</p><h2 id="716e" class="lc jv hi bd jw mf mg mh ka mi mj mk ke iq ml mm ki iu mn mo km iy mp mq kq mr bi translated">处置参数</h2><p id="b127" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">有时我们需要做一些事情，比如关闭一个流，注销时写入日志，或者重置已注册的实例。可以在 dispose 参数中指定的。</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="eec4" class="lc jv hi ky b fi ld le l lf lg">serviceLocator.registerSingleton(<br/>         MyWebService(),<br/>         dispose: (webservice) =&gt; webservice.closeConnection());</span></pre><p id="763b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个注册方法都有 dispose 功能。</p><h2 id="b99a" class="lc jv hi bd jw mf mg mh ka mi mj mk ke iq ml mm ki iu mn mo km iy mp mq kq mr bi translated"><strong class="ak">取消实例注册</strong></h2><p id="9620" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">当我们不再需要某个实例或者想要重新初始化它时，我们可以注销该实例。</p><p id="f0b5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">语法是</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="2c41" class="lc jv hi ky b fi ld le l lf lg"><strong class="ky hj">void</strong> unregister&lt;T&gt;({Object instance,String instanceName, <strong class="ky hj">void</strong> Function(T) disposingFunction})</span></pre><blockquote class="mw mx my"><p id="092e" class="if ig mz ih b ii ij ik il im in io ip na ir is it nb iv iw ix nc iz ja jb jc hb bi translated"><strong class="ih hj">实例:</strong>要取消注册的实例。</p><p id="bd91" class="if ig mz ih b ii ij ik il im in io ip na ir is it nb iv iw ix nc iz ja jb jc hb bi translated"><strong class="ih hj"> instanceName: </strong>要取消注册的已注册实例的名称。</p><p id="322a" class="if ig mz ih b ii ij ik il im in io ip na ir is it nb iv iw ix nc iz ja jb jc hb bi translated"><strong class="ih hj"> disposingFunction : </strong>注销时要调用的函数。</p></blockquote><ol class=""><li id="ee08" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc ls ln lo lp bi translated">要仅通过<strong class="ih hj">键入</strong>来取消注册，请使用</li></ol><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="8393" class="lc jv hi ky b fi ld le l lf lg">serviceLocator.unregister<strong class="ky hj">&lt;MyWebService&gt;</strong>();</span></pre><p id="c6c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.若要按 instanceName 取消注册，请使用</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="6f94" class="lc jv hi ky b fi ld le l lf lg">serviceLocator.unregister&lt;MyWebService&gt;<strong class="ky hj">(instanceName:'v1')</strong>;</span></pre><p id="8248" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.若要由实例本身注销，请使用</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="e537" class="lc jv hi ky b fi ld le l lf lg">var myWebservice = serviceLocator<br/>                     .get&lt;MyWebService&gt;(instanceName:'v1');<br/>// ....<br/>serviceLocator.unregister&lt;MyWebService&gt;<strong class="ky hj">(instance:myWebservice)</strong>;</span></pre><blockquote class="mw mx my"><p id="ead1" class="if ig mz ih b ii ij ik il im in io ip na ir is it nb iv iw ix nc iz ja jb jc hb bi translated">当您指定了<strong class="ih hj">实例</strong>参数时，<strong class="ih hj">实例名</strong>参数不被考虑</p></blockquote><ul class=""><li id="c186" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">如果您想在注销实例之前执行任何处置功能，您可以使用<strong class="ih hj"> disposingFunction() </strong></li></ul><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="c97f" class="lc jv hi ky b fi ld le l lf lg">serviceLocator.unregister&lt;MyWebService&gt;(<br/>   <strong class="ky hj">disposingFunction: (webservice)=&gt; webservice.closeConnection()</strong>);</span></pre><blockquote class="mw mx my"><p id="0571" class="if ig mz ih b ii ij ik il im in io ip na ir is it nb iv iw ix nc iz ja jb jc hb bi translated">当指定 disposingFunction() <strong class="ih hj">，</strong>时，不考虑注册实例时指定的 dispose 函数。</p></blockquote><p id="93f4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要取消注册<strong class="ih hj"> lazySingletons </strong>使用，</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="0c3d" class="lc jv hi ky b fi ld le l lf lg"><strong class="ky hj">void</strong> resetLazySingleton&lt;T&gt;({Object instance,<br/>                            String instanceName,<br/>                            <strong class="ky hj">void</strong> Function(T) disposingFunction})</span></pre></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><h2 id="0148" class="lc jv hi bd jw mf mg mh ka mi mj mk ke iq ml mm ki iu mn mo km iy mp mq kq mr bi translated">完全重置 GetIt</h2><p id="6e12" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">您可以完全删除所有已注册的实例，并使用<strong class="ih hj"> reset() </strong>功能重新开始。</p><p id="3277" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">语法是:</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="7f54" class="lc jv hi ky b fi ld le l lf lg">Future&lt;<strong class="ky hj">void</strong>&gt; reset({bool dispose = <strong class="ky hj">true</strong>});</span></pre><p id="57bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们在进行单元测试时，当我们想要频繁地清除所有注册的实例(对于每个测试或每个组)时，这种方法非常方便。</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="4bee" class="lc jv hi ky b fi ld le l lf lg">await serviceLocator.<strong class="ky hj">reset()</strong>;</span></pre><ul class=""><li id="3460" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc lm ln lo lp bi translated">如果在注册时我们已经指定了一个类型，那么将调用每个注册类型的 dispose 函数。</li><li id="b4c8" class="lh li hi ih b ii lt im lu iq lv iu lw iy lx jc lm ln lo lp bi translated">If <code class="du mt mu mv ky b"><strong class="ih hj">dispose=false, </strong></code>不调用任何 dispose 函数，注销所有已注册的类型。</li></ul><h1 id="8e7e" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">ServiceLocator 设计模式？</h1><p id="a405" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">如果你看看 get_it 是如何工作的，你可以清楚地看到它只是帮助我们找到(定位)我们已经创建的实例(服务)。这就是为什么它属于服务定位器设计模式，而不属于依赖注入。</p><p id="110d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">依赖注入</strong></p><p id="b7dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">依赖注入为您解决了依赖性。它将在后台为您创建实例的依赖关系。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="d230" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你对上面的类进行依赖注入，当你试图创建一个 HybridLogger 时，consoleLogger 和 fileLogger <strong class="ih hj">将被注入</strong> <strong class="ih hj"> you </strong>。您不希望手动创建依赖项并将其传递给构造函数。</p><p id="f021" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是使用 service Locator 你必须手动注入依赖关系，据我所知，我们可以通过两种方式手动注入依赖关系，</p><ol class=""><li id="96eb" class="lh li hi ih b ii ij im in iq lj iu lk iy ll jc ls ln lo lp bi translated"><strong class="ih hj">在类内使用 serviceLocator(GetIt.instance)(不推荐)</strong></li></ol><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="b683" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码不好。为什么？我们可能会忘记注册依赖项(ConsoleLogger 或 FileLogger)，<strong class="ih hj">，这可能会引发运行时错误。</strong></p><p id="f9c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">示例:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="2aac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2。构造函数注入+ get_it(良好实践)</strong></p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="d27a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将帮助我们通过<code class="du mt mu mv ky b">get_it </code>实现依赖注入(在某种程度上)，但是我们仍然必须创建所有的实例并手动传递它们。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lq lr l"/></div></figure><p id="35c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这确保了我们注册了所有的依赖项。但是当我们的应用程序变得太大时，最好使用依赖注入包，比如<a class="ae jt" href="https://pub.dev/packages/injectable" rel="noopener ugc nofollow" target="_blank">injectible</a>。</p><blockquote class="mw mx my"><p id="de40" class="if ig mz ih b ii ij ik il im in io ip na ir is it nb iv iw ix nc iz ja jb jc hb bi translated">主要区别在于依赖关系是如何定位的，在服务定位器中，客户端代码请求依赖关系，在 DI 容器中，我们使用容器来创建所有对象，并将依赖关系作为构造函数参数(或属性)注入。</p></blockquote></div><div class="ab cl ly lz gp ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="hb hc hd he hf"><p id="658e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望您对 get_it 以及如何使用 get_it 包有效地管理我们的依赖关系有所了解，get_it 包中有太多值得探索的内容。请不要忘记查看<a class="ae jt" href="https://pub.dev/packages/get_it" rel="noopener ugc nofollow" target="_blank">官方文档</a>。</p><p id="65cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你在这篇文章中发现了任何错误的信息，请在评论中指出，这将会有很大的帮助。感谢你的阅读，鼓掌👏如果你喜欢这篇文章。</p></div></div>    
</body>
</html>