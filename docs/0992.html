<html>
<head>
<title>Golang Basic Unit Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang 基本单元测试</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/golang-basic-unit-testing-7398a65aeb98?source=collection_archive---------9-----------------------#2021-02-28">https://medium.com/nerd-for-tech/golang-basic-unit-testing-7398a65aeb98?source=collection_archive---------9-----------------------#2021-02-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/777ebfe116ea2629b24e01e6341799b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BRZ4pWZGYRB1FTSe"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">neon brand(【https://unsplash.com/photos/60krlMMeWxU】T2)的积分</figcaption></figure><p id="f402" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">简而言之，基本上你需要测试你写的代码，以确保你做得正确。如果你有一个将两个数相加的函数，你将<strong class="ix hj">期望</strong>结果<strong class="ix hj">是这两个数的<strong class="ix hj">和</strong>，通过编写单元测试，你确保当函数用给定的参数运行时，它将返回正确的/期望的结果或行为。</strong></p><p id="b342" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这篇文章将仅仅用一些例子和解释来覆盖 golang 单元测试的基础，更高级和复杂的单元测试/甚至模拟一个函数将在另一篇文章中讨论。</p><h1 id="7e18" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">功能和单元测试</h1><p id="b88a" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">声明:我不会讨论 TDD，这将集中在如何创建单元测试，如果你有一个函数，你想测试它。</p><p id="749b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设我们有一个只有一个文件(user.go)的包“user ”,该文件包含几个内容:</p><ol class=""><li id="41ed" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">“人”的结构</li><li id="0e32" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">“人”的方法</li><li id="5192" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">与此用户包和人员结构相关的一些错误</li></ol><p id="a743" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此类人员可以具有以下属性:</p><ul class=""><li id="d139" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lk lc ld le bi translated">名称(字符串)</li><li id="4758" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lk lc ld le bi translated">朋友(一部分人)</li></ul><p id="18d5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们还将在 person 结构中附加一些方法:</p><ul class=""><li id="16ac" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lk lc ld le bi translated">ChangeName(名称字符串)</li><li id="e186" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lk lc ld le bi translated">AddNewFriend(好友)</li></ul><p id="e5f9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从简单的开始，假设我们实现了如下的 ChangeName 函数:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="d2cc" class="lu ju hi lq b fi lv lw l lx ly">package user</span><span id="64ba" class="lu ju hi lq b fi lz lw l lx ly">import "errors"</span><span id="7d9d" class="lu ju hi lq b fi lz lw l lx ly">var (</span><span id="88c8" class="lu ju hi lq b fi lz lw l lx ly">    ErrorPersonNameEmpty = errors.New("Person name must exist")</span><span id="7433" class="lu ju hi lq b fi lz lw l lx ly">)</span><span id="0c7c" class="lu ju hi lq b fi lz lw l lx ly">type Person struct {</span><span id="8e4a" class="lu ju hi lq b fi lz lw l lx ly">   Name    string</span><span id="d6ca" class="lu ju hi lq b fi lz lw l lx ly">   Friends []Person</span><span id="f23b" class="lu ju hi lq b fi lz lw l lx ly">}</span><span id="534b" class="lu ju hi lq b fi lz lw l lx ly">func (p *Person) ChangeName(name string) error {<br/>   if name == "" {</span><span id="a4c4" class="lu ju hi lq b fi lz lw l lx ly">      return ErrorPersonNameEmpty</span><span id="8141" class="lu ju hi lq b fi lz lw l lx ly">   }</span><span id="9130" class="lu ju hi lq b fi lz lw l lx ly">   p.Name = name<br/>   <br/>   return nil</span><span id="f50e" class="lu ju hi lq b fi lz lw l lx ly">}</span></pre><p id="6ecc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在“user”包中另存为“user.go”，然后新建一个文件“user_test.go”。因为我们想测试 ChangeName 函数，所以我们创建了 TestPerson_ChangeName 函数，如下所示:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="1950" class="lu ju hi lq b fi lv lw l lx ly">package user</span><span id="442f" class="lu ju hi lq b fi lz lw l lx ly">import (</span><span id="8fb0" class="lu ju hi lq b fi lz lw l lx ly">  “testing”</span><span id="c082" class="lu ju hi lq b fi lz lw l lx ly">)</span><span id="8932" class="lu ju hi lq b fi lz lw l lx ly">func TestPerson_ChangeName(t *testing.T) {</span><span id="e1ef" class="lu ju hi lq b fi lz lw l lx ly">  p := &amp;Person{</span><span id="63e2" class="lu ju hi lq b fi lz lw l lx ly">    Name: “Wuzz”,</span><span id="384d" class="lu ju hi lq b fi lz lw l lx ly">  }</span><span id="14e2" class="lu ju hi lq b fi lz lw l lx ly">  p.ChangeName(“Bert”)</span><span id="4ef1" class="lu ju hi lq b fi lz lw l lx ly">  if err != nil {</span><span id="727a" class="lu ju hi lq b fi lz lw l lx ly">    t.Errorf("ChangeName fail, expecting nil error got %v", err)</span><span id="ed74" class="lu ju hi lq b fi lz lw l lx ly">  }</span><span id="fd25" class="lu ju hi lq b fi lz lw l lx ly">  <br/>  if p.Name != “Bert” {</span><span id="8074" class="lu ju hi lq b fi lz lw l lx ly">    t.Errorf(“ChangeName fail, expecting %v, got %v”, “Bert”, p.Name)</span><span id="cc09" class="lu ju hi lq b fi lz lw l lx ly">  }</span><span id="2983" class="lu ju hi lq b fi lz lw l lx ly">}</span></pre><p id="5d04" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们创建一个名为“Wuzz”的 person 指针对象，然后调用 ChangeName 方法，将“Bert”作为 person 的新名称，然后将该函数返回的错误与 nil 进行比较，因为我们预计在将名称更改为“Bert”时不会出现错误。之后，我们比较人名，最后我们期望 person 对象的名称更改为“Bert ”,如果没有达到期望值，就会引发一个测试错误，并显示一条附加消息，显示我们的期望值和我们得到的值之间的差异。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/dfa25d44d9aa34dbd667b7bdbcc80dfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TMQc0DMtkh1oTCtNPgco2w.png"/></div></div></figure><p id="58d8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我使用的是可视化代码，测试我们创建的单元测试非常简单，只需点击函数上方的 run test 即可。或者你可以通过终端手动运行它，点击“运行^YourTestName".测试”您还可以通过使用根项目文件夹中的这个基本命令<code class="du mb mc md lq b">go test ./...</code>来运行当前项目中的所有单元测试。如果它打印出“ok ”,那么它意味着单元测试通过了，假设我们通过<code class="du mb mc md lq b">if p.Name != “Abcd"</code>将第 13 行中的期望值和错误消息的第 19 行一起更改为其他值。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es me"><img src="../Images/a62900d812d9e80a2a800dfa3a1a4000.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A6rIfDoEvHjX3dR8-AtT6A.png"/></div></div></figure><p id="4713" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，由于错误的预期，单元测试将失败，并显示我们在第 14 行中描述的错误消息。现在，当我们将名称改为空字符串时，我们需要覆盖测试用例，因为我们的逻辑包括检查当名称为空字符串时，它将返回一个错误。我们有两个选择，用不同的逻辑和期望创建一个新的测试函数(即:“TestPerson_ChangeNameToEmpty”，<strong class="ix hj">或</strong>，更好的是我们可以创建更多的动态测试函数，允许我们修改参数和期望。尝试修改单元测试，如下所示:</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mf"><img src="../Images/0232fc3a057127508614200c7851e9cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ivpf-ukHvKyeO17-KoF83Q.png"/></div></div></figure><p id="ae48" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们通过创建一个匿名结构片来改变它，这个匿名结构片将我们的测试用例一个接一个地分组，每个测试用例都有自己的参数、测试名和输出期望。然后我们将循环测试用例，通过<code class="du mb mc md lq b">tt.Run</code>运行测试用例，创建 person 对象，然后用当前测试用例的新名称更改名称，并相应地断言期望。</p><p id="272a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">再次运行测试，它将通过。这种结构比前一种更好，因为现在我们可以在 struct 对象的数组中添加新的测试用例。继续在测试用例切片上为 ChangeName with empty string 参数添加新的测试用例。我们希望此人的姓名不要更改，并且返回的错误类型为 ErrorPersonNampeEmpty。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mg"><img src="../Images/e5ed6acc718ae2a351d4cd945861ed9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cQLBP2l6qdmARvDB09mtpQ.png"/></div></div></figure><p id="aa0d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们转到第二个 person 方法，创建 AddNewFriend 方法，该方法将在 person Friends 属性的参数中追加一个 person。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="d037" class="lu ju hi lq b fi lv lw l lx ly">func (p *Person) AddNewFriend(friend Person) {</span><span id="a39d" class="lu ju hi lq b fi lz lw l lx ly">    p.Friends = append(p.Friends, friend)</span><span id="7f28" class="lu ju hi lq b fi lz lw l lx ly">}</span></pre><p id="dbaa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如您所看到的，测试将是一个简单的测试，就像您创建一个人，添加新朋友，传入另一个人对象(作为其朋友)，然后我们需要断言此人的朋友数量正在增加，并且其新朋友存在于属性中。</p><p id="75d4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以这样写</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/adcd88d30c590f05f88dcf3a769a23ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xTGUPkSRgqbeuL7-RJAzuA.png"/></div></div></figure><p id="9370" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们有多个朋友的参数，然后在测试用例中我们将他们添加为它的朋友，然后最终我们期望人(Mark)的朋友将与我们的新朋友参数相同。我们使用 DeepEqual 来确保 friends 数组及其对应的值相等。再次运行测试用例，我们将看到它通过。假设现在由于某种原因，我们修改了函数 AddNewFriend 并插入了一个这样的逻辑。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="74bc" class="lu ju hi lq b fi lv lw l lx ly">func (p *Person) AddNewFriend(friend Person) {</span><span id="103e" class="lu ju hi lq b fi lz lw l lx ly">  if friend.Name != “Bob” {</span><span id="de90" class="lu ju hi lq b fi lz lw l lx ly">    p.Friends = append(p.Friends, friend)</span><span id="cc76" class="lu ju hi lq b fi lz lw l lx ly">  }</span><span id="8651" class="lu ju hi lq b fi lz lw l lx ly">}</span></pre><p id="a9be" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果朋友的名字是鲍勃，我们不会添加为新朋友(鲍勃是有毒的，我们不想要有毒的朋友，例如，爱你鲍勃)。再次运行测试，我们将看到它失败。</p><figure class="ll lm ln lo fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/720210c18dd8c51f32e170a2024a6125.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5DpMnWNiOOzMN20_EAQdOQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">由于 Bob 未被添加为朋友，所以失败，但我们希望朋友是 Claire 和 Bob</figcaption></figure><p id="1886" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这很好，因为如果有人修改我们的函数，他们可能不知道函数结果所预期的效果或任何边缘情况，所以有一个<strong class="ix hj">强大的单元测试和测试用例</strong>在其中<strong class="ix hj">可以防止</strong>某人甚至你自己<strong class="ix hj">修改某些东西和破坏</strong>任何现有的特性/流程。你可以从你相关函数的失败测试案例中知道。</p></div><div class="ab cl mj mk gp ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hb hc hd he hf"><p id="f7b5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">希望这对你有用，我们将在另一篇文章上对更复杂的断言和嘲讽进行阐述。祝你今天愉快<strong class="ix hj"> :) </strong></p></div></div>    
</body>
</html>