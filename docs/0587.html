<html>
<head>
<title>Microservice Architecture: Sidecar Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微服务架构:边车模式</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/microservice-design-pattern-sidecar-sidekick-pattern-dbcea9bed783?source=collection_archive---------0-----------------------#2021-01-23">https://medium.com/nerd-for-tech/microservice-design-pattern-sidecar-sidekick-pattern-dbcea9bed783?source=collection_archive---------0-----------------------#2021-01-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7abebdc9e65710d2c4978c8413c121c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b2F4OPWS_ZEW_kUA1jM5Bg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">边车模式</figcaption></figure><p id="9718" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在微服务架构中，多个服务/应用通常需要日志记录、配置、监控和网络服务等常见功能，这种情况非常普遍。这些功能可以在同一个容器或单独的容器中作为单独的服务来实现和运行。</p><p id="c966" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="js">在同一应用中实现核心逻辑和支持功能:</em></p><p id="e68e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当它们在同一个应用程序中实现时，通过有效利用共享资源，它们被紧密地联系在一起并在同一个进程中运行。在这种情况下，这些组件没有很好地分离，它们相互依赖，这可能导致一个组件的故障反过来影响另一个组件或整个应用程序。</p><p id="87c6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="js">在单独的应用程序中实现核心逻辑和支持功能:</em></p><p id="ae0d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当应用程序被分离成服务时，每个服务可以用最适合所需功能的不同语言和技术来开发。在这种情况下，每个服务都有自己的依赖项\库来访问底层平台和与主应用程序共享的资源。当我们在不同的主机上部署两个应用程序时，它还会增加应用程序的延迟，并增加托管、部署和管理方面的复杂性。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="8039" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> Sidecar 模式(或 Sidekick 模式)？</strong></p><p id="ca35" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">库伯内特斯边车概念越来越受欢迎。这是容器世界中的一个普遍原则，容器应该解决一个问题&amp;它应该做得很好。Sidecar 模式通过将核心业务逻辑从扩展原始功能的附加任务中分离出来实现了这一原则。</p><p id="ed0f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Sidecar 模式是由两个容器组成的单节点模式。</p><p id="58b6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">第一个是应用程序容器，它包含应用程序的核心逻辑(主应用程序)。没有这个容器，应用程序就不会存在。</p><p id="7450" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">此外，还有一个 Sidecar 容器，用于通过在同一个容器组(Pod)上并行运行另一个容器来扩展/增强主应用程序的功能。因为 sidecar 运行在与主应用程序容器相同的 Pod 上，所以它共享资源——文件系统、磁盘、网络等。,</p><p id="24ca" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">它还允许将同一应用程序的组件(用不同的技术实现)部署到一个单独的、隔离的和封装的容器中。当跨微服务架构共享公共组件(例如:日志记录、监控、配置属性等)具有优势时，这被证明是非常有用的..)</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ka"><img src="../Images/26c60ae531e1902124db2ab5a1d8665e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eDcxLf2SRpxCgwKt_Gzzsg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">例:边车:有两个容器的豆荚</figcaption></figure></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="2084" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">什么是 Pod？</strong></p><p id="76ef" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Pod 是 Kubernetes (K8S)中部署的基本原子单位。</p><p id="ffde" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在 K8S 中，pod 是一组包含一个或多个共享存储和网络的容器。Sidecar 充当 pod 中的实用容器，它松散地耦合到主应用程序容器。Pod 可以被认为是运行多个容器的消费者群体(用 Kafka 术语来说)。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="3ace" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">边车模式什么时候有用？</strong></p><ul class=""><li id="f97a" class="kf kg hi iw b ix iy jb jc jf kh jj ki jn kj jr kk kl km kn bi translated">当服务/组件用多种语言或技术实现时。</li><li id="147f" class="kf kg hi iw b ix ko jb kp jf kq jj kr jn ks jr kk kl km kn bi translated">服务/组件必须位于运行主应用程序的同一容器组(pod)或主机上。</li><li id="8a91" class="kf kg hi iw b ix ko jb kp jf kq jj kr jn ks jr kk kl km kn bi translated">服务/组件由远程团队或不同的组织拥有。</li><li id="f49f" class="kf kg hi iw b ix ko jb kp jf kq jj kr jn ks jr kk kl km kn bi translated">一种服务，可以独立更新，不依赖于主应用程序，但与主应用程序共享相同的生命周期。</li><li id="590d" class="kf kg hi iw b ix ko jb kp jf kq jj kr jn ks jr kk kl km kn bi translated">如果我们需要控制组件或服务的资源限制。</li></ul><p id="802e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj">例句</strong>:</p><p id="f241" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">1.将 HTTPS 加入传统服务<br/> 2。带边车的动态配置<br/> 3。带边车的日志聚合器</p><p id="e074" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> <em class="js">将 HTTPS 添加到遗留服务</em> </strong></p><p id="13c6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">考虑一个通过未加密的 HTTP 服务请求的遗留 web 服务。我们需要增强同一个遗留系统，以满足 HTTPS 未来的服务请求。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es kt"><img src="../Images/20b7fbde2701bf09b235afa02d5d8490.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*23frGSPjof5yz_-J-4ikxg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">示例:示例:将 HTTPS 添加到旧服务</figcaption></figure><p id="267d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">遗留应用被配置为专门在本地主机上服务请求，这意味着只有与服务器共享本地网络的服务能够访问遗留应用。除了主容器(遗留应用程序)之外，我们可以添加 Nginx Sidecar 容器，它运行在与主容器相同的网络名称空间中，这样它就可以访问运行在 localhost 上的服务。</p><p id="fd6b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">同时，Nginx 终止 pod 外部 IP 地址上的 HTTPS 流量，并将该流量委托给遗留应用程序。</p><p id="22a7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> <em class="js">带边车的动态配置</em> </strong></p><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ku"><img src="../Images/2faddb752cef99bc9ecdcc71707767ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4IzaHMpT8UbHWGISAJiuww.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">示例:示例:带边车的动态配置</figcaption></figure><p id="7620" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当遗留应用程序启动时，它从文件系统加载其配置。</p><p id="8a77" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">当 configuration manager 启动时，它会检查存储在本地文件系统上的配置和存储在云上的配置之间的差异。如果有差异，那么配置管理器将新的配置下载到本地文件系统，并通知遗留应用程序使用新的配置重新配置自己(例如:可以是 EDD 或编排机制来选择新的配置更改)</p><p id="282d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> <em class="js">带边车的原木聚合器</em> </strong></p><p id="4fde" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">假设我们有一个 web 服务器，它正在生成访问/错误日志，这些日志对于在特定时间间隔/内存空间之外保存在卷上来说并不重要。但是，访问/错误日志有助于调试应用程序的错误/缺陷。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kv"><img src="../Images/4f679979613f2937c607333cf1bfa647.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YErpHm7ftsrCNUs0unVWuA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">示例:带边车的日志聚合器</figcaption></figure><p id="1a02" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">根据关注点分离原则，我们可以通过部署一个单独的容器来捕获访问/错误日志，并将其从 web 服务器传输到日志聚合器，从而实现 Sidecar 模式。</p><p id="9f1d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Web 服务器很好地完成了它的任务，为客户端请求提供服务&amp; Sidecar 容器处理访问/错误日志。因为容器运行在同一个 pod 上，所以我们可以使用一个共享卷来读/写日志。</p></div></div>    
</body>
</html>