# 随着新输入系统| Unity 移动

> 原文：<https://medium.com/nerd-for-tech/moving-with-the-new-input-system-unity-a6c9cb100808?source=collection_archive---------0----------------------->

## 统一指南

## 关于如何在 Unity 中使用新的输入系统实现移动的快速指南

![](img/b63bfafdec136d0d22383a0b9a71f47b.png)

**目标**:在 2D 游戏中，使用 Unity 中的新输入系统为我们的玩家设置水平移动。

在上一篇文章中，我介绍了[如何用 Unity](/nerd-for-tech/animated-tiles-unity-a9fa47103296) 为我们的游戏引入动画效果。现在，是时候开始使用 Unity 中的新输入系统实现一个简单的水平移动机制来设置播放器了。

# 玩家精灵

首先，让我们看一下我们为玩家动画准备的精灵表:

![](img/42f32f579a645a835c1cdd5e73d71728.png)![](img/8be9ec2ddc60bd0b4c8e2d96e60b73a3.png)

然后，为了得到我们播放器的初始精灵，让我们使用精灵编辑器分割*空闲的*精灵表:

![](img/52670c50d6bbcb90db3f75ec097fc013.png)![](img/0367d30c16713c9530399b64ca635a2f.png)![](img/9d2c724ba56852cad9c4de06fccff10b.png)

切片后，让我们创建一个新的空游戏对象来包含初始的玩家精灵，以便更容易管理它的所有组件:

![](img/b7e41737a32b908a7f40c7d69f7f16c9.png)![](img/88c859f8af126a1f904e4bff7fc24ff9.png)![](img/df14ea25a5b84630b2fb5633b434b06f.png)

# 播放器组件

接下来，让我们创建一个新脚本并将其附加到玩家游戏对象:

![](img/0b9b3d3b3542924768f2abb5bffcfac1.png)![](img/1dcfcfb5e3e470e5e12ffd588aaadc3c.png)![](img/1877cb99ca371cc296b3c1e9b7f793e0.png)

此外，为了处理玩家的运动和与环境的碰撞，让我们附加一个刚体 2D 和一个 2D 碰撞器。一旦附加，我们可以编辑 2D 碰撞器来匹配精灵:

![](img/6269d24d6d6c045c42995dc5792c7d97.png)![](img/18f10a85d912a68a8b6d650b48fd89f9.png)

# 导入新的输入系统

现在，为了能够使用 Unity 的新输入系统，让我们:

*   **点击*窗口>程序包管理器*打开**程序包管理器**。**
*   **选择左上角的****Unity Registry**包。
*   **找到**和**点击底部的安装按钮，安装*****输入系统*** 包。
*   **等待**直到软件包安装完毕。

![](img/35264b141deeed0aa3c7516c1948dd1b.png)![](img/219de3beb95a016e371d2ba5cbdbf1d2.png)![](img/02eaa9fa9e590c917cefd26f11304239.png)

安装完成后，很可能会出现下一个窗口。您可以通过点击*是*来选择禁用旧的输入并启用新的输入系统，或者通过点击*否*来保持相同的设置。

![](img/2a1ff78aafb2e7810f5225370973319a.png)

如果您选择保留旧输入，并希望更改输入处理，您可以:

*   点击*编辑>项目设置*到**打开项目设置**。
*   进入 ***玩家*** 标签页。
*   向下滚动到 ***其他设置*** 部分。
*   更改 ***活动输入处理*** 属性以使用新的输入系统或新旧系统。

> 注意:Unity 编辑器将重新启动以应用对此设置的更改。

![](img/f6636cec56f063512113f4fe50011ad8.png)![](img/96258376936e4c13f51673e8188cae58.png)

# 运动输入

一旦 Unity 编辑器识别出新的输入系统，让我们开始创建一个新的**输入动作资产**来处理来自玩家的输入。您可以通过点击*创建>输入动作*来创建一个:

![](img/6faf3780082cbb40b66a6c093b2bf3df.png)![](img/7ada22399b6867ef3320652c68359a20.png)

然后，要修改输入的动作资产，让我们双击其文件或通过检查器单击 ***编辑资产*** 打开各自的窗口:

![](img/c26d6dbc7c917ac53fa1fd5e1a47f254.png)![](img/e003aea1d83bd7885705de3aea477ec8.png)![](img/8e1607c24ee7c4018ee0dc743a3caba9.png)

在这个窗口中，我们将能够根据我们绑定到它们的输入来确定要执行的操作。

窗口出现提示后，让我们创建一个新的动作地图，通过单击下一步按钮来处理玩家的游戏动作:

> 动作地图代表一组动作，可以根据游戏中发生的事情启用或禁用这些动作来使用不同的输入。例如，我们可以在玩家走路时启用一个动作地图，在玩家开车时启用另一个动作地图。

![](img/6745e44319caef2882861d26c6e55123.png)

接下来，让我们通过以下方式修改动作图中的新动作:

*   表明它是用来移动的。
*   将 ***动作类型*** 属性改为类型**值**。

> value 类型的动作将被持续监视(以便能够在它改变时读取它的值),而 button 类型的动作将在按钮被按下时充当触发器。

*   将 ***控制类型*** 更改为*矢量 2* ，以便将输入限制为我们运动的 X 和 Y 轴值。

![](img/dadf4714caa8dde9e74081c3f07b2689.png)

然后，为了从将被移动动作弯曲的输入接收一个*向量 2* 值，让我们去掉默认绑定槽并创建一个新的 2D 向量合成:

![](img/fd69cd3126a16b275645a11a0341b244.png)

现在，为了指示接收 Vector2 值的输入键，让我们单击每个方向并选择我们想要映射的键。此外，我们可以点击 **Listen** 按钮，然后点击按键，让 Unity 检测需要选择哪个按键:

![](img/5a04be5991c42d46f8a4b29de15bdfb5.png)

最后，不要忘记点击**保存资产**按钮来保存我们对输入行动资产所做的更改:

![](img/14e1272048997c06983a147ba6465672.png)

如果你想了解更多关于新的 Unity 输入系统的信息，你可以访问 Unity 文档:

[](https://docs.unity3d.com/Packages/com.unity.inputsystem@1.0/manual/QuickStartGuide.html) [## 快速入门指南

### 注:有关如何安装新输入系统的信息，请参见安装。开始使用…的最快方法

docs.unity3d.com](https://docs.unity3d.com/Packages/com.unity.inputsystem@1.0/manual/QuickStartGuide.html) 

# 从输入动作资产接收值

现在，为了从移动动作中获得各自的值，让我们:

*   **点击输入行动资产上的**。
*   **通过检查器启用*****生成 C#类*** 属性。
*   **点击**应用**按钮上的**创建 C#类。

这将创建一个新的 C#类，它将包含来自我们修改的资产的输入动作。有了这个类，我们将能够像我们的玩家脚本一样跟踪 MonoBehaviour 组件中的动作。

![](img/35bf96bfcb8bf2737d17dd00fe6d4872.png)![](img/2a481953555dddc15e9c1b5f62a75820.png)![](img/1514b5c2babfe590c02708945ceccd83.png)

我们将使用这个类来使用输入动作资产中的动作。

有关如何使用新输入系统创建动作的更多信息，您可以访问 Unity 文档:

 [## 行动

### 相关页面:输入动作被设计成将输入的逻辑意义与物理输入方式分开…

docs.unity3d.com](https://docs.unity3d.com/Packages/com.unity.inputsystem@1.0/manual/Actions.html#creating-actions) 

一旦生成了 **PlayerActions** 类，让我们打开**播放器**脚本来实现移动。我们将需要下一个全局变量来完成它:

*   速度

这个变量将指示我们的球员的移动速度。

*   玩家动作

这个变量将作为对新的 **PlayerActions** 类的引用，在那里我们将能够从输入中接收运动值。

*   刚体

这个变量将保存一个对我们玩家的**刚体 2D** 的引用。

*   移动输入

该变量将存储来自运动的当前**矢量 2** 值。

![](img/ca6f28861d0dadc04ad1c39b2b4eee60.png)

然后，在 **Awake** 方法中，让我们初始化对播放器的 **PlayerActions** 类和 **Rigidbody2D** 组件的各自引用:

![](img/72db0349e36e1cbe1c8a0e3799a8cf1f.png)

接下来，我们需要通过使用**启用**方法来手动启用玩家最初将使用的动作地图(包含移动动作):

![](img/07ec5c9d22458c2698e6ccb0e85b43b7.png)

同样，让我们通过使用**可禁用的**方法来禁用它，这是处理动作时的一个好习惯:

![](img/fc910bc4b2234b69da53694a4feca4c8.png)

最后，让我们使用 **FixedUpdate** 方法通过以下方式实现我们的玩家的移动:

*   从**运动动作中读取并存储 Vector2 值。**
*   将 Y 轴值设置为 0(暂时固定，直到我们在此轴上应用速度)。
*   将**刚体 2D** 的**速度**设定为输入值乘以速度。

![](img/aa2bb1434978830d1ab7b7e3fd041562.png)

# 测试机芯

在运行游戏之前，让我们:

*   **向我们播放器的**速度**变量指示**一个值。
*   **冻结**刚体 2D** 组件**的 **Z 旋转**(避免向侧面移动时旋转)。

![](img/e8e8ef74e7157fd14c392650868b5045.png)![](img/68cd1d6f3efde8f2d380b409b1d3a1e4.png)

现在，如果我们用 Unity 运行游戏，我们会看到玩家按预期移动:

![](img/3a9240038bd307d730505b4dddbeaa91.png)

就是这样，我们使用了 Unity 的新输入系统来实现玩家的动作！:d .我会在下一篇文章中看到你，在那里我将展示如何使用新的输入系统和带有 Unity 的 Boxcast2D 实现玩家的跳跃。

> *如果你想更多地了解我，欢迎登陆*[***LinkedIn***](https://www.linkedin.com/in/fas444/)**或访问我的* [***网站***](http://fernandoalcasan.com/) *:D**