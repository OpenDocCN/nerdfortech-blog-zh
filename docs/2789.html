<html>
<head>
<title>Styling dynamic strings directly in Android xml with HTML markup</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用HTML标记直接在Android xml中设计动态字符串</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/styling-dynamic-strings-directly-in-xml-7b93cfe380ab?source=collection_archive---------2-----------------------#2021-05-20">https://medium.com/nerd-for-tech/styling-dynamic-strings-directly-in-xml-7b93cfe380ab?source=collection_archive---------2-----------------------#2021-05-20</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/0982cb8c28c34d9f3dbecfac07504d0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J6idjkHx1P7uV1ZFBHbhVg.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图片来自Unsplash，作者Markus Spiske</figcaption></figure><div class=""/><p id="962d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="js">语法高亮</em>  <em class="js"> </em> <strong class="iw hy"> <em class="js">和代码格式化</em> </strong> <em class="js">见原文章</em> <strong class="iw hy"> <em class="js">免费上我的个人博客:</em><a class="ae jt" href="https://sergiosastre.hashnode.dev/styling-dynamic-strings-directly-in-xml" rel="noopener ugc nofollow" target="_blank"><em class="js">https://sergiosastre . hashnode . dev</em></a><em class="js">。</em></strong></p><p id="be1f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在Android中，<code class="du ju jv jw jx b">Strings</code>是处理显示纯文本的视图时最常见的对象之一。在实现用户界面时，经常会出现文本需要某种样式的情况。对于样式化的字符串，我们需要使用<code class="du ju jv jw jx b">CharSequences</code>来代替。Android支持一些现成的html标签，例如，它们可以在xml字符串资源中定义</p><pre class="jy jz ka kb fd kc jx kd ke aw kf bi"><span id="b3d0" class="kg kh hx jx b fi ki kj l kk kl">&lt;string name="lorem_ipsum"&gt;<br/>This is &lt;font color="red"&gt;red&lt;/font&gt; and this &lt;b&gt;&lt;i&gt;bold and italic (nested); &lt;/i&gt;this just bold&lt;/b&gt;,&lt;u&gt;underlined&lt;/u&gt;<br/>&lt;/string&gt;</span></pre><p id="2990" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">并通过调用<code class="du ju jv jw jx b">context.getText(stringRes: Int)</code>解析成一个<code class="du ju jv jw jx b">CharSequence</code>，它会处理所有支持的HTML标签来样式化文本，而不需要我们做任何其他事情。</p><p id="5305" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然而，有时我们需要动态构建字符串的一部分。为了做到这一点，我们需要以<code class="du ju jv jw jx b">%{digit}${type}</code>的形式用占位符标记xml中的动态部分，例如<code class="du ju jv jw jx b">%1$s</code>是作为第一个<code class="du ju jv jw jx b">vararg</code>传递的字符串，<code class="du ju jv jw jx b">%2$d</code>是作为第二个<code class="du ju jv jw jx b">vararg</code>传递的十进制数，在<code class="du ju jv jw jx b">String.format(text: String, vararg args: String)</code>中，调用它来解析占位符。</p><p id="cb77" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然而，如果我们在xml字符串资源中定义了动态占位符和<strong class="iw hy"> HTML标签，事情就变得复杂了，比如像这样。</strong></p><pre class="jy jz ka kb fd kc jx kd ke aw kf bi"><span id="add9" class="kg kh hx jx b fi ki kj l kk kl">&lt;string name="lorem_ipsum"&gt;<br/>This is &lt;font color="red"&gt;red&lt;/font&gt; and this &lt;b&gt;&lt;i&gt;bold and italic (nested); &lt;/i&gt;this just bold&lt;/b&gt;, &lt;u&gt;underlined&lt;/u&gt; and here the placeholder = %1s<br/>&lt;/string&gt;</span></pre><p id="d6f6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果我们看一下<code class="du ju jv jw jx b">String.format(text: String, vararg args: String)</code>的方法签名，它的第一个参数需要一个<code class="du ju jv jw jx b">String</code>而不是一个<code class="du ju jv jw jx b">CharSequence</code>。这意味着，动态文本占位符将被正确替换，但是我们的<code class="du ju jv jw jx b">CharSequence</code>必须转换为<code class="du ju jv jw jx b">String</code>，放弃它的样式。</p><p id="b667" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了处理HTML标记，Android提供了<em class="js"> HtmlCompat </em>。它要求字符串资源对其开头的不安全字符进行编码，即:<code class="du ju jv jw jx b">'&lt;'</code>，变成<code class="du ju jv jw jx b">'&amp;lt;'</code></p><pre class="jy jz ka kb fd kc jx kd ke aw kf bi"><span id="52c4" class="kg kh hx jx b fi ki kj l kk kl">&lt;string name="lorem_ipsum"&gt;<br/>This is &amp;lt;font color="red"&gt;red&amp;lt;/font&gt; and this &amp;lt;b&gt;&amp;lt;i&gt;bold and italic (nested); &amp;lt;/i&gt;this just bold&amp;lt;/b&gt;,&amp;lt;u&gt;underlined&amp;lt;/u&gt; and here the placeholder = %1s<br/>&lt;/string&gt;</span></pre><p id="7061" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">或者，我们可以将<a class="ae jt" href="https://developer.android.com/reference/org/w3c/dom/CDATASection" rel="noopener ugc nofollow" target="_blank"> CDATASections </a>中的资源包装成xml，如下所示:</p><pre class="jy jz ka kb fd kc jx kd ke aw kf bi"><span id="9490" class="kg kh hx jx b fi ki kj l kk kl">&lt;string name="lorem_ipsum"&gt;<br/>&lt;![CDATA[<br/>This is &lt;font color="red"&gt;red&lt;/font&gt; and this &lt;b&gt;&lt;i&gt;bold and   italic (nested); &lt;/i&gt;this just bold&lt;/b&gt;, &lt;u&gt;underlined&lt;/u&gt; and here the placeholder = %1s <br/>]]&gt;<br/>&lt;/string&gt;</span></pre><p id="66e9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在任何情况下，假设我们的动态占位符文本为“placeholder1”，我们可以通过使用<em class="js"> HtmlCompat </em>得到预期的结果，如下所示:</p><pre class="jy jz ka kb fd kc jx kd ke aw kf bi"><span id="8bf2" class="kg kh hx jx b fi ki kj l kk kl">val text = context.getString(R.string.lorem_ipsum) <br/>val dynamicText = String.format(text, "placeholder1") <br/>val dynamicStyledText = <br/>HtmlCompat.fromHtml(dynamicText, HtmlCompat.FROM_HTML_MODE_COMPACT)</span><span id="8544" class="kg kh hx jx b fi km kj l kk kl">textView.text = dynamicStyledText</span></pre><figure class="jy jz ka kb fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kn"><img src="../Images/fbe54939bf6f3b923dd471453ee090a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*y1cuhSvcU6FuAtXB"/></div></div></figure><p id="74fd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">虽然上面的代码看起来运行稳定，但是如果动态占位符文本包含至少一个未转义的HTML字符，例如:<code class="du ju jv jw jx b">&lt;</code>、<code class="du ju jv jw jx b">&gt;</code>、<code class="du ju jv jw jx b">&amp;</code>、<code class="du ju jv jw jx b">\</code>或<code class="du ju jv jw jx b">"</code>，就像在<code class="du ju jv jw jx b">&lt;placeholder1&gt;</code>中一样，结果会有所不同，导致下面的结果</p><figure class="jy jz ka kb fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ko"><img src="../Images/7efe5642e2335f3169596ee4013444be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Xna9s738Oapm7VS0"/></div></div></figure><p id="df57" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">是的，占位符就这么消失了。那是因为在调用<code class="du ju jv jw jx b">HtmlCompat.fromHtml()</code>之前必须对字符进行转义。我们通过在使用<em class="js"> HtmlCompat </em>之前对占位符进行编码来解决这个问题，就像这样</p><pre class="jy jz ka kb fd kc jx kd ke aw kf bi"><span id="3429" class="kg kh hx jx b fi ki kj l kk kl">val text = context.getString(R.string.lorem_ipsum) <br/>val encodedPlaceholder = TextUtils.htmlEncode("&lt;placeholder1&gt;") <br/>val dynamicText = String.format(text, encodedPlaceholder) <br/>val dynamicStyledText = <br/>HtmlCompat.fromHtml(dynamicText, HtmlCompat.FROM_HTML_MODE_COMPACT) </span><span id="9301" class="kg kh hx jx b fi km kj l kk kl">textView.text = dynamicStyledText</span></pre><figure class="jy jz ka kb fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es kn"><img src="../Images/bf27c683f80ea81fa612299d4d8fc948.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-zP8zMsQpOs--wSN"/></div></div></figure><p id="8d4c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">虽然这很有效，而且根据官方文件<a class="ae jt" href="https://developer.android.com/guide/topics/resources/string-resource.html#kotlin" rel="noopener ugc nofollow" target="_blank">这是推荐的方法</a>，但我个人不喜欢以前的任何方法。为什么？</p><ol class=""><li id="00b4" class="kp kq hx iw b ix iy jb jc jf kr jj ks jn kt jr ku kv kw kx bi translated">为了使用动态文本占位符，您最终完全改变了xml字符串资源</li><li id="fa8d" class="kp kq hx iw b ix ky jb kz jf la jj lb jn lc jr ku kv kw kx bi translated">在字符串资源的样式化部分，xml失去了突出显示，因此更难阅读</li></ol><figure class="jy jz ka kb fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ld"><img src="../Images/2130c603028c790f9d52f980e4b05e5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D32dBSStYCBmAjXm"/></div></div></figure><p id="f903" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一个更好的方法是创建一个方法，可以处理带有HTML标记和占位符的原始xml字符串资源。这样做，字符串资源是否包含HTML标记并不重要，该方法只是处理占位符，同时保持由(现有的，如果有的话)HTML标记定义的样式…不需要替换开始的不安全字符或添加<a class="ae jt" href="https://developer.android.com/reference/org/w3c/dom/CDATASection" rel="noopener ugc nofollow" target="_blank"> CDATASections </a>。</p><p id="83a9" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">是的，这是可能的。让我们看看怎么做。</p><h1 id="a15a" class="le kh hx bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">挖掘更好的解决方案</h1><p id="6c4e" class="pw-post-body-paragraph iu iv hx iw b ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn mf jp jq jr hb bi translated">我们已经知道使用<code class="du ju jv jw jx b">context.getText(R.string.lorem_ipsum)</code>会返回样式为<code class="du ju jv jw jx b">CharSequence</code>的字符串资源。如果字符串资源有一个占位符，它将像在xml中一样显示。</p><figure class="jy jz ka kb fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es ko"><img src="../Images/196b50c8c55ee18b1cd88ebd761684b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cSSKLZlOIdkd_yLk"/></div></div></figure><p id="d865" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们也知道<code class="du ju jv jw jx b">HtmlCompat.fromHtml()</code>处理“一些”HTML标签。它的反向方法是存在的，并做完全相反的事情:接受一个<code class="du ju jv jw jx b">Spanned</code>对象，并将其转换为带有相应HTML标签的字符串。我们传递给方法的标志也很重要:<code class="du ju jv jw jx b">HtmlCompat.TO_HTML_PARAGRAPH_LINES_INDIVIDUAL</code>也在HTML字符串的末尾添加了一个新行，我们必须考虑到这一点。因此，我们可以如下获得所需的HTML字符串</p><pre class="jy jz ka kb fd kc jx kd ke aw kf bi"><span id="e5a1" class="kg kh hx jx b fi ki kj l kk kl">// step 2 - toHtml()<br/>val spannedString = SpannedString(styledString) <br/>val htmlString = <br/>HtmlCompat.toHtml( <br/>   spannedString, HtmlCompat.TO_HTML_PARAGRAPH_LINES_INDIVIDUAL <br/>)<br/>.substringBeforeLast('&gt;')<br/>.plus("&gt;")</span></pre><p id="31fa" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这导致了</p><figure class="jy jz ka kb fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mg"><img src="../Images/17d561bf48fed453b8cf927d20d205aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BHwhEfngUHav9EcF"/></div></div></figure><p id="6acb" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">到目前为止，我们已经得到了与第一步的样式化字符串等价的HTML字符串。然而，最终目标是用相应的值替换它的占位符。您可能还记得，我在文章开头提到过，我们可以使用<code class="du ju jv jw jx b">String.format(text: String, vararg args: String)</code>来实现这一点。它不能与<code class="du ju jv jw jx b">CharSequence</code>一起工作，但这就是为什么我们首先把它转换成等价的HTML字符串。</p><pre class="jy jz ka kb fd kc jx kd ke aw kf bi"><span id="1f12" class="kg kh hx jx b fi ki kj l kk kl">// step 3 - String.format()<br/>val dynamicHtmlString = String.format(htmlString, args)</span></pre><figure class="jy jz ka kb fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mh"><img src="../Images/0b3ce4fe75d33f3b4bbf2339cdd9d2e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OQzw5O9drZ3Y_srt"/></div></div></figure><p id="5711" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">只需将HTML文本转换成一个<code class="du ju jv jw jx b">CharSequence</code>，我们就可以得到想要的样式。记得使用<code class="du ju jv jw jx b">HtmlCompat.FROM_HTML_MODE_COMPACT</code>，因为它是我们之前使用的<code class="du ju jv jw jx b">HtmlCompat.TO_HTML_PARAGRAPH_LINES_INDIVIDUAL</code>的反码</p><pre class="jy jz ka kb fd kc jx kd ke aw kf bi"><span id="51a2" class="kg kh hx jx b fi ki kj l kk kl">// step 4 - fromHtml()<br/>val result = <br/>HtmlCompat.fromHtml( <br/>   dynamicStyledString, HtmlCompat.FROM_HTML_MODE_COMPACT <br/>).removeSuffix("\n")</span></pre><figure class="jy jz ka kb fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mi"><img src="../Images/11830d1166f330e90678073c8544979d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R4x16WhGud2QIN0i"/></div></div></figure><p id="7987" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">好了，我们差不多完成了…正如我们在本文开头看到的，如果占位符是包含不安全字符的<code class="du ju jv jw jx b">Strings</code>，它们就不会显示出来。因此，不要忘记我们需要对替换占位符的字符串值进行编码。遵循上述所有步骤的Kotlin扩展函数如下所示</p><pre class="jy jz ka kb fd kc jx kd ke aw kf bi"><span id="ac87" class="kg kh hx jx b fi ki kj l kk kl">fun Context.getHtmlStyledText(<br/>    @StringRes htmlStringRes: Int,<br/>    vararg args: Any<br/>): CharSequence {<br/><br/>    // step 0 - Encode string placeholders  <br/>    val escapedArgs = args.map {<br/>        if (it is String) TextUtils.htmlEncode(it) else it<br/>    }.toTypedArray()<br/><br/>    // step 1 - getText()<br/>    val styledString = Context.getText(htmlStringRes)<br/><br/>    // step 2 - toHtml()<br/>    val spannedString = SpannedString(styledString)<br/>    val htmlString = HtmlCompat.toHtml(<br/>        spannedString,<br/>        HtmlCompat.TO_HTML_PARAGRAPH_LINES_INDIVIDUAL<br/>    )<br/>        .substringBeforeLast('&gt;')<br/>        .plus("&gt;")<br/><br/>    // step 3 - String.format()<br/>    val dynamicStyledString = <br/>        String.format(htmlString, *escapedArgs)<br/><br/>    // step 4 - fromHtml()<br/>    return HtmlCompat.fromHtml(<br/>        dynamicStyledString,<br/>        HtmlCompat.FROM_HTML_MODE_COMPACT<br/>    )<br/>    .removeSuffix("\n")   //fromHtml() adds one new line at the end<br/>}</span></pre><h1 id="a76c" class="le kh hx bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">奖金</h1><p id="37fe" class="pw-post-body-paragraph iu iv hx iw b ix mb iz ja jb mc jd je jf md jh ji jj me jl jm jn mf jp jq jr hb bi translated">同样的想法也适用于复数资源。简单替换</p><pre class="jy jz ka kb fd kc jx kd ke aw kf bi"><span id="c01e" class="kg kh hx jx b fi ki kj l kk kl">// step 1 - getText()<br/>val styledString = context.getText(R.string.lorem_ipsum)</span></pre><p id="259d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">随着</p><pre class="jy jz ka kb fd kc jx kd ke aw kf bi"><span id="7d0a" class="kg kh hx jx b fi ki kj l kk kl">// step 1 - getText()<br/>val styledString =   context.resources.getQuantityText(R.plural.lorem_ipsum, quantity)</span></pre><p id="b2af" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">你可以在这里找到相应的<a class="ae jt" href="https://gist.github.com/sergio-sastre/371191e5067c73af747f3d0939e0db29" rel="noopener ugc nofollow" target="_blank">字符串和复数的工作要点</a></p><p id="06bd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">你喜欢这个帖子吗？你可能也想看看我写的其他文章:</p><ol class=""><li id="4441" class="kp kq hx iw b ix iy jb jc jf kr jj ks jn kt jr ku kv kw kx bi translated"><a class="ae jt" href="https://sergio-sastre.medium.com/an-introduction-to-snapshot-testing-on-android-in-2021-c9826e22deb1" rel="noopener">2021年安卓快照测试介绍</a></li><li id="4b2c" class="kp kq hx iw b ix ky jb kz jf la jj lb jn lc jr ku kv kw kx bi translated"><a class="ae jt" href="https://sergiosastre.hashnode.dev/better-unit-tests-with-parameterized-testing" rel="noopener ugc nofollow" target="_blank">通过参数化测试实现更好的单元测试</a></li><li id="37b8" class="kp kq hx iw b ix ky jb kz jf la jj lb jn lc jr ku kv kw kx bi translated"><a class="ae jt" href="https://sergiosastre.hashnode.dev/writing-bulletproof-code-with-property-based-testing-pbt" rel="noopener ugc nofollow" target="_blank">用基于属性的测试编写防弹代码</a></li></ol></div><div class="ab cl mj mk gp ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hb hc hd he hf"><p id="dec7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="js">原发布于</em><a class="ae jt" href="https://sergiosastre.hashnode.dev/styling-dynamic-strings-directly-in-xml" rel="noopener ugc nofollow" target="_blank"><em class="js">https://sergiosastre . hashnode . dev</em></a><em class="js">。</em></p></div></div>    
</body>
</html>