# 二分搜索法用围棋、Python 和 C

> 原文：<https://medium.com/nerd-for-tech/binary-search-with-go-python-and-c-3eaf3ed5f761?source=collection_archive---------15----------------------->

![](img/9dfe08305d129dc7b0605adbd4475207.png)

澳大利亚八月在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄的照片

*二分搜索法算法*是一种搜索算法，适用于排序集合(例如排序数组)。它将一个集合、该集合的长度和要查找的元素作为输入，并将集合中元素的索引(如果存在)作为输出。

由于算法简单，所以它既高效又易学。

这个算法只做 *O(log n)* 比较。

另一方面，它只对排序的集合有效，这使得它被限制在一些特定的情况下。

这篇文章旨在展示这三种编程语言之间的一些基本差异。该算法本身在许多应用程序中使用，但是，大多数时候，我们不必从头实现它，因为每一个处理数据结构的值得尊敬的库都实现了这一点。

# **伪代码**

该算法的伪代码如下:

```
function BSA(A, n, T): L := 0 R := n − 1 while L <= R: m := floor((L + R) / 2) if A[m] < T: L := m + 1 else if A[m] > T: R := m - 1 else: return m return unsuccessful
```

让我们解释一下这段伪代码:

*   该算法将数组`A`、数组长度`n`和要搜索的元素`T`作为输入；
*   我们初始化两个变量:`L`到`0`和`R`到`n-1`，即数组`A`的第一个和最后一个元素的索引；
*   我们迭代直到`L`变得等于或大于`R`，也就是说我们迭代了整个数组；
*   我们将`m`初始化为 floor 或`(L+R)/2`，即数组中间元素的索引；
*   然后，我们将索引`m`处的元素与所需的元素`T`进行比较:
*   如果`A[m]`比`T`小，我们应该在数组的大半部分搜索`T`:在*【m+1，R】*中的那个；
*   如果`A[m]`大于`T`，我们应该在数组的下半部分搜索`T`:在*【L，m-1】*中的那个；
*   否则`A[m]`等于`T`，我们可以返回`m`，因为我们找到了元素。

# **Python**

让我们看看使用 Python 的 BSA。

Python 中的二进制搜索

如你所见，用 Python 写的 *BSA* 和伪代码非常相似。当我们找不到想要的元素时，我们返回 *-1* 。

# **出发**

*BSA* 的 *Go* 版本如下:

围棋中的二分搜索法

与 *Python* 版本不同，这段代码看起来不像伪代码，因为 Go 的强类型化迫使我们进行两次强制转换( [*第 7 行*](https://gist.github.com/dariodip/d54976e361fec510afe68a64cfa90e82#file-binary-search-go-L7) )。同样在 *Go* 实现中，如果我们找不到元素 *T* ，我们返回 *-1* 。由于算法本身的简单性，无需考虑其他因素。

# **C**

*_BSA_* 的 *C* 版本可能如下:

C 语言中的二进制搜索

*C* 实现看起来与 *Go* 实现非常相似，但是没有强制转换，因为 *C* 具有弱类型。

这是我的第一篇博文。