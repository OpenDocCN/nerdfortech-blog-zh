<html>
<head>
<title>REST-API-Roundtrip with SpringDoc and OpenAPI Generator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">REST-API-与 SpringDoc 和 OpenAPI 生成器的往返</h1>
<blockquote>原文：<a href="https://medium.com/nerd-for-tech/rest-api-roundtrip-with-springdoc-and-openapi-generator-30bd27ccf698?source=collection_archive---------3-----------------------#2021-02-16">https://medium.com/nerd-for-tech/rest-api-roundtrip-with-springdoc-and-openapi-generator-30bd27ccf698?source=collection_archive---------3-----------------------#2021-02-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/e73f600d1b217c77df25d96ad7f65f73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mRuH_5DBqABz2MQK.jpg"/></div></div></figure><p id="0abc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在 Spring Boot 应用程序中提供 JSON REST 端点是显而易见的，就像许多先进的框架一样。只需包含 Spring Boot Web Starter 作为依赖项，定义一个用@RestController 注释的类，并实现至少一个用@RequestMapping(或特定注释)注释的方法作为 HTTP 请求的处理程序。</p><p id="6d4a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，在一个完整的 API 生命周期中，还有更多的事情要做。在本文中，我们介绍了一个<strong class="is hj">自动化工具链</strong>，它帮助<strong class="is hj">将 Spring Boot </strong> <a class="ae jo" href="https://www.viadee.de/seminar/api-design-und-management" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> REST API 开发</strong> </a> <strong class="is hj">专业化，并自动化了大量的手工工作</strong>。</p><h2 id="f992" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">代码优先，但要有规范</h2><p id="cc04" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">在 API 社区中，就像任何传统类型的接口一样，人们经常讨论是从接口规范开始，然后实现呈现 API(API-设计优先)，还是从实现中生成规范(代码优先)。这两种方法都是合理的。在这篇文章中，我们将重点关注代码优先方法的用例，就像 Spring Boot 经常做的那样。</p><p id="a710" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下图说明了代码优先的方法，首先，建立一个 Spring Boot 应用程序(1)，然后，创建 REST 端点和隐式 API)。有时会编写 API 文档，例如，根据 OpenAPI 标准(3)，有时也会创建 API 客户端(4)。</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div class="er es kp"><img src="../Images/0a5e3ba34f6747c876c89c55fead7208.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/0*QOf9N0Vyuq5g-JaO.png"/></div></figure><h2 id="3b60" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">示例:用户 API</h2><p id="ec59" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">作为本文的一个案例，我们提供了一个用户 API 示例项目。这为所展示的工具链提供了参考，并且可能会支持您为自己的环境设置工具链。</p><p id="f470" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">API 允许创建、更新和查询用户。为此，使用 GET、POST、PUT 或 DELETE 以符合 HTTP 的方式提供 REST 操作。</p><p id="7031" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">虽然下面包含了相关的代码片段，但是完整案例的代码在 GitHub 上是公开的:<a class="ae jo" href="https://github.com/viadee/api-roundtrip-spring-boot" rel="noopener ugc nofollow" target="_blank">https://github.com/viadee/api-roundtrip-spring-boot</a></p><h1 id="92b2" class="ku jq hi bd jr kv kw kx jv ky kz la jz lb lc ld kc le lf lg kf lh li lj ki lk bi translated">API-往返——全套服务包</h1><p id="3ad9" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">在本文中，我们将 API 往返称为完整 API 包的<strong class="is hj">开发，包括以下工件:</strong></p><ul class=""><li id="292a" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated"><em class="lu">REST-API</em><br/>API 本身</li><li id="0452" class="ll lm hi is b it lv ix lw jb lx jf ly jj lz jn lq lr ls lt bi translated"><em class="lu"> API 文档</em> <br/>作为 OpenAPI 规范的 API 文档</li><li id="920e" class="ll lm hi is b it lv ix lw jb lx jf ly jj lz jn lq lr ls lt bi translated"><em class="lu"> API-Client </em> <br/>使用 API 的客户端，可以很容易地集成到应用程序中</li><li id="8cd3" class="ll lm hi is b it lv ix lw jb lx jf ly jj lz jn lq lr ls lt bi translated"><em class="lu">集成测试</em> <br/>在部署后，例如在测试环境中，自动测试 API 的功能</li></ul><h2 id="991f" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">现状</h2><p id="fac7" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">对于其他接口类型(如 SOAP 或 CORBA)来说，提供文档(WSDL)和预构建的客户端是相当确定的。然而，这样的工件在 REST APIs 中并不常见。一个重要的原因是缺乏已建立的自动化——或者至少已建立的自动化并不广为人知。</p><p id="afe0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在的集成测试经常使用 Postman、SOAP UI 或者放心等工具。它们都允许向 REST API 发送 JSON 请求。</p><p id="f50c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">由于创建和维护 JSON 请求以及检查结果 JSON 响应的必要性，与最初的 API 开发相比，这通常会导致大量的人工工作。</p><p id="ddfe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">考虑到整体包装，即使是 Spring boot 应用程序中的一个小调整，通常也需要大量的手动操作，而且常常令人烦恼。</p><h2 id="c637" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">自动化得益于 SpringDoc 和 OpenApi 生成器</h2><p id="9d13" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">对于改善现状的有效 REST API 开发，需要一个提供功能的自动化工具链，至少从使用 SOAP 和 CORBA 中可以知道。一方面，这个<strong class="is hj">自动化了重复的手工任务</strong>，另一方面，这个<strong class="is hj">解决了集成测试开发中的媒体中断</strong>。</p><p id="c2cc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">后者是在用 Java 实现集成测试<strong class="is hj">时实现的，就像 Spring Boot 应用程序本身一样。</strong></p><p id="3123" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下图概述了我们在本文中描述的工具链。</p><p id="3eeb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，基于 Spring Boot REST API 实现，使用 SpringDoc 生成一个 OpenAPI 文档。在第二步中，使用 OpenAPI Generator 生成适当的客户端代码和集成测试代码，从而简化 API 文档。</p><p id="0a2c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当然，实现实际的测试逻辑仍然需要手工操作。</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div class="er es ma"><img src="../Images/6d72a94dc78f51806507ae4117ca6c0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/0*WDKh06_PMY5URXJH.png"/></div></figure><p id="367f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">具体来说，工具链由以下组件组成:</p><ul class=""><li id="e9c9" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn lq lr ls lt bi translated"><a class="ae jo" href="https://www.viadee.de/seminar/spring-core-und-boot-schulung/" rel="noopener ugc nofollow" target="_blank"><em class="lu"/></a><em class="lu"><br/></em>实现了 REST-API (1)</li><li id="daad" class="ll lm hi is b it lv ix lw jb lx jf ly jj lz jn lq lr ls lt bi translated"><em class="lu"> SpringDoc <br/> </em>生成 API 文档作为 OpenAPI 规范和 Swagger UI，促进 Spring Boot 应用基础设施。(2)</li><li id="6703" class="ll lm hi is b it lv ix lw jb lx jf ly jj lz jn lq lr ls lt bi translated"><em class="lu"> OpenAPI <br/> </em>根据 SpringDoc 生成的 OpenAPI 规范生成 API 客户端和集成测试的代码。(3)</li><li id="8e7b" class="ll lm hi is b it lv ix lw jb lx jf ly jj lz jn lq lr ls lt bi translated"><em class="lu"> Maven <br/>当然，可以用 Gradle 构建类似的链。</em></li><li id="e07a" class="ll lm hi is b it lv ix lw jb lx jf ly jj lz jn lq lr ls lt bi translated"><em class="lu">集成测试<br/> </em>集成测试的执行取决于具体的环境。在本文中，我们提供了一个例子，在这个例子中，集成测试是在部署本身之后用 Maven 在部署管道中触发的。(4)</li></ul><h1 id="af66" class="ku jq hi bd jr kv kw kx jv ky kz la jz lb lc ld kc le lf lg kf lh li lj ki lk bi translated">API-round trip——简而言之就是工具链</h1><h2 id="1b43" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">Spring Boot API 实施</h2><p id="b19a" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">用户 API 由带有相应 spring 注释的接口定义。应该小心选择方法名。默认情况下，它们将被用作 OpenAPI 规范中的 operationID，并通过它定义生成的 API 客户端的方法名。</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="3708" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">建议显式地<strong class="is hj">指定一个@ResponseStatus </strong>，因为这将在以后自动生成一个更干净的 OpenAPI。</p><p id="af3b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">API 接口由 Spring @RestController 实现。为了简单起见，我们用非持久散列表实现了用户数据的存储。</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="53f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，必须在 pom 文件中添加 Maven 依赖项，并且必须创建并启动@SpringBootApplication。这是通过<a class="ae jo" href="http://localhost:8080/api/users" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/API/users</a>向 API 发送第一个请求所必需的。</p><p id="77ad" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">到目前为止，这是一个简单的 Spring Boot 基础设施。我们的 API 往返的实际工具链从这里开始。</p><h2 id="0910" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">API 文档生成</h2><p id="0cf7" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">对于 SOAP Web 服务，提供一个 WSDL 并让它由 Web 服务基础设施自动生成是很常见的。然而，对于 REST APIs 来说，这还不是现成的。</p><p id="8fe8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> SpringDoc 通过处理 Spring Boot 基础设施和提供额外的配置能力，自动生成 OpenAPI 规范和 Swagger-UI 在线文档，填补了这一空白</strong>。</p><p id="a6f3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了能够在您自己的应用程序中处理 SpringDoc，下面的 Maven-Dependency 就足够了，因为它也间接引用了 SpringDoc 核心:</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="7049" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这意味着在 Spring Boot 应用程序的(新)启动之后，可以立即到达 Swagger UI:<a class="ae jo" href="http://localhost:8080/swagger-ui.html" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/Swagger-UI . html</a></p><p id="c967" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">也可以检索 OpenAPI 规范:<a class="ae jo" href="http://localhost:8080/v3/api-docs" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/v3/API-docs</a></p><p id="e6a5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这两种类型的文档都可以进行广泛的配置和补充。</p><figure class="kq kr ks kt fd ij er es paragraph-image"><div class="er es md"><img src="../Images/ce9972283da8166522ac3ce5a16c9ecc.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*H3kHVz_UotnSHPp7.png"/></div></figure><figure class="kq kr ks kt fd ij er es paragraph-image"><div class="er es me"><img src="../Images/d33367b2b28e636bf881dc26dfea3acb.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/0*41iaB06b_FXPm-Sc.png"/></div></figure><p id="0863" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">SpringDoc 提供了各种注释，例如@OpenAPIDefinition，用于丰富 API 文档的内容，如下例所示:</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="c4a2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">建议在此时添加服务器规范。稍后，在 OpenAPI 文件生成期间，API 将在一个随机的空闲端口上启动，如果没有在这里明确指定，一个相当不熟悉的端口规范将在 API 规范中结束。</p><p id="aa50" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当然，如果 API 端点的最终 URL 是已知的，那么应该在这里输入。</p><p id="4b6e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果 OpenAPI 规范的 JSON 需要用带有缩进和换行符的“漂亮打印机”进行格式化，则应该在 Spring Boot 应用程序.属性或 yaml 文件中添加以下配置:</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="66f5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果需要，Swagger UI 和 OpenAPI 文档的 URL 可以设置在 actuator 或任何其他上下文中。</p><p id="bbbe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，OpenAPI 规范必须存储为本地文件，以便以后的客户端代码生成可以访问它。SpringDoc 为这一步提供了一个 Maven 插件，与 Spring Fox 等类似工具相比，它提供了更多的便利。</p><p id="d678" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在典型的 Spring Boot 配置中，整个依赖关系只在运行时加载和解析，因此，SpringDoc Maven 插件需要一个正在运行的应用程序。该插件从上面提到的 URL 下载 OpenAPI 规范。</p><p id="69c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了实现这一点，SpringDoc Maven 插件在 Maven“集成测试”阶段进行了配置，如下例所示:</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="b340" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除了用于下载 OpenAPI 规范的 URL 之外，还可以通过 outputFileName 和 outputDir 参数来定义目标文件。我们在示例中省略了这些参数，因此默认情况下，该文件被写入 target/openapi.json。</p><p id="5baa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了确保 Spring Boot 应用程序能够在“集成测试”阶段成功启动，我们首先使用 codehaus build-helper-maven-plugin 确定一个空闲端口。然后在“预集成-测试”阶段在 spring-boot-maven-plugin 中配置自由端口，以启动 Spring Boot 应用程序(<goal> start </goal>)并在“后集成-测试”阶段停止它(<goal> stop </goal>)。</p><p id="3496" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">动态端口选择确保 Maven 工具链能够工作，即使应用程序已经在标准端口 8080 上运行。</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="dd02" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，生成 API 文档的第一步已经完成。接下来，我们将重点关注为 API 客户端和集成测试生成代码。</p><h2 id="0d95" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">API 客户端和集成测试生成</h2><p id="331d" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">OpenAPI 规范提供了详细的接口描述，足以实现对 API 端点的有效请求。OpenAPI Generator 是一个非常活跃和成熟的开源工具，用于基于这些规范生成代码和其他工件。我们在往返工具链中使用它来生成代码，这些代码将 REST API 调用封装为易于使用的 Java 接口。</p><p id="332e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">OpenAPI Generator 是从 Swagger Code Gen 项目中派生出来的，旨在实现更轻、更快的开发。到目前为止发布的版本，以及 OpenAPI 生成器的活跃社区都符合创始人的目标。</p><p id="d737" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">同时，有超过 130 种不同的代码生成器，用于客户端和服务器实现，以及文档和其他 API 和数据格式，如 GraphQL 或 protobuf。</p><p id="9496" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">OpenAPI 带有一个 Maven 插件，所以代码生成可以直接集成到整个工作流程中。Gradle 的插件也是可用的。以下示例显示了并发 Maven 插件配置。</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="f205" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个例子展示了使用 Java 代码生成器和 java8 DateLibrary 选项的插件配置，以 java.util.LocalDate 的形式生成日期数据字段。</p><p id="5c58" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，设置了目标代码的各种包，并且生成器被配置为只生成客户机源代码，而不生成进一步的文档或 Gradle 和 Maven 工件。</p><p id="5c90" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不幸的是，在 OpenAPI Generator 的当前版本中，仍然需要指定要生成的基础设施类，因为对“仅客户端代码”设置的功能请求仍然是开放的。</p><p id="9a11" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要将代码生成与上一代 OpenAPI 规范结合起来，需要考虑两件事情:</p><ol class=""><li id="6df8" class="ll lm hi is b it iu ix iy jb ln jf lo jj lp jn mf lr ls lt bi translated">在父 maven 模块中，api 子模块必须放在客户端/集成测试子模块之前</li><li id="1de3" class="ll lm hi is b it lv ix lw jb lx jf ly jj lz jn mf lr ls lt bi translated">OpenAPI 规范(<inputspec>)的代码生成器路径必须引用之前下载的规范</inputspec></li></ol><p id="d612" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要编译用“本地”OpenAPI 生成器设置生成的 Java 客户端代码，需要一些依赖关系。</p><p id="da82" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为 GitHub 上的示例应用程序的一部分，我们提供了一个最小的配置:<a class="ae jo" href="https://github.com/viadee/api-roundtrip-spring-boot/blob/main/client/pom.xml#L24" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/viadee/API-round trip-spring-boot/blob/main/client/POM . XML</a></p><h2 id="75ff" class="jp jq hi bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj bi translated">集成测试执行</h2><p id="2e1f" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">如果除了纯客户端代码之外还生成集成测试，一个有效的策略是将它们实现为单元测试，但是使用 Maven failsafe 而不是经典的 surefire 插件单独运行它们。如果集成测试在一个单独的 maven 模块中，整个设置会变得更加实用，该模块指定了额外的规则，比如不要将集成测试与整个应用程序捆绑在一起。</p><p id="8c24" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">failsafe 插件是成熟的 surefire 插件的一部分，但它默认运行在 Maven 集成测试阶段。</p><p id="a538" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">默认情况下，failsafe 插件附带一个名称过滤器，指定要执行的单元测试类。下面的代码示例根据“*IntegrationTest.java”模式扩展了集成测试的名称筛选器:</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="13af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，以下 Maven 配置确保了在正常测试阶段 surefire 插件不会运行集成测试，并且集成测试代码不会部署或安装在 Maven 存储库中。</p><figure class="kq kr ks kt fd ij"><div class="bz dy l di"><div class="mb mc l"/></div></figure><p id="2057" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在 GitHub 上提供的示例项目中，我们将集成测试执行封装在一个单独的概要文件中，以便在部署管道中运行时获得更多的控制。</p><h1 id="4d5d" class="ku jq hi bd jr kv kw kx jv ky kz la jz lb lc ld kc le lf lg kf lh li lj ki lk bi translated">结论</h1><p id="3fd0" class="pw-post-body-paragraph iq ir hi is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hb bi translated">REST APIs 因其简单性而被广泛采用。然而，这种简单性也带来了许多挑战，尤其是维护和可持续性方面。</p><p id="c349" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">OpenAPI 标准将 REST API 的开发和管理推向了一个新的高度，基于它的生成器和集成为维护困境提供了出路。</p><p id="edaa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">文章中展示的工具链<strong class="is hj">完全基于免费和标准工具</strong>，并利用了 REST APIs 的复杂 Spring Boot 基础设施。类似的自动化也可以用 Quarkus 和 Micronaut 等框架创建，也可以用 JavaScript 或 Python 等其他语言为客户端创建。</p><p id="8d8f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于那些积极想要扩展他们在 API 开发和 API 管理方面的<strong class="is hj">专业知识的人</strong>，我们认为值得看看 OpenAPI、SpringDoc 和 OpenAPI Generator。</p><p id="d84c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">现代 API 是独立的产品，能够显著实现全新的数字商业模式和流程</strong>。对高质量 API 的日益自觉的处理有助于挖掘这一巨大潜力。</p><p id="0b4d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">类似地，自动化，比如本文中介绍的工具链，有助于开发新的质量标准，大大减少了人工工作量。</p><p id="52a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，<a class="ae jo" href="https://www.viadee.de/seminar/api-design-und-management" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> OpenAPI 规范</strong> </a> <strong class="is hj">为许多其他用例提供了基础，如</strong> <a class="ae jo" href="https://www.viadee.de/seminarkategorie/cloud/" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">公共或私有 API 目录</strong> </a> <strong class="is hj">或 API 质量分析</strong>以获得更好、更同质的 API 产品。</p></div><div class="ab cl mg mh gp mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="hb hc hd he hf"><p id="2e35" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lu">你在努力使你的 API 开发专业化吗？我很高兴与你讨论你的想法和问题。给我写个</em> <a class="ae jo" href="mailto:benjamin.klatt@viadee.de" rel="noopener ugc nofollow" target="_blank"> <em class="lu">邮箱</em> </a> <em class="lu">或者上</em><a class="ae jo" href="https://www.linkedin.com/in/dr-benjamin-klatt-4680081/" rel="noopener ugc nofollow" target="_blank"><em class="lu">LinkedIn</em></a><em class="lu">联系就行了。</em></p><figure class="kq kr ks kt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/4951e5895bf2906a03da1b01ff5dd19c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6VyGd49T-Ia998wyLtXilg.jpeg"/></div></div></figure><p id="1243" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Benjamin Klatt 博士是一名集成架构师和敏捷蔻驰。</p><p id="5806" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">他的重点是产品和<a class="ae jo" href="https://www.viadee.de/en/solutions/business-process-management" rel="noopener ugc nofollow" target="_blank">流程的数字化</a>、<a class="ae jo" href="https://www.viadee.de/en/solutions/java/" rel="noopener ugc nofollow" target="_blank">集成架构</a>和<a class="ae jo" href="https://www.viadee.de/en/solutions/agile-methods/" rel="noopener ugc nofollow" target="_blank">敏捷方法</a>。</p><p id="aca2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lu">最初发布于</em><a class="ae jo" href="https://blog.viadee.de/en/rest-api-roundtrip" rel="noopener ugc nofollow" target="_blank"><em class="lu">https://blog . viadee . de</em></a><em class="lu">。</em></p></div></div>    
</body>
</html>